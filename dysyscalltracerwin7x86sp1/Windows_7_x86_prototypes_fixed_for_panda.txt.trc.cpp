#define __STDC_FORMAT_MACROS
#define PLUGIN_MAIN

#include "Windows_7_x86_prototypes_fixed_for_panda.txt.trc.h.dump.h"

#include "panda/plugin.h"
#include "panda/plugin_plugin.h"

#include "osi/osi_types.h"
#include "osi/osi_ext.h"

#include "wintrospection/wintrospection.h"
#include "wintrospection/wintrospection_ext.h"

#include "syscalls2/generated/syscalls_ext_typedefs.h"

#include "panda/rr/rr_log.h"
#include "panda/rr/rr_log_all.h"

extern "C" {
    bool init_plugin(void *);
    void uninit_plugin(void *);
}

FILE * outFile;

/*0 NTSTATUS NtAcceptConnectPort (PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);*/
void on_cb_NtAcceptConnectPort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortContext, uint32_t ConnectionRequest, uint32_t AcceptConnection, uint32_t ServerView, uint32_t ClientView) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x0\",\"syscall_name\" : \"NtAcceptConnectPort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortContext\":\"0x%x\", \"ConnectionRequest\":\"0x%x\", \"AcceptConnection\":\"0x%x\", \"ServerView\":\"0x%x\", \"ClientView\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortContext, ConnectionRequest, AcceptConnection, ServerView, ClientView, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortHandle\" : ");fprintf(outFile, "\"Unable to read PortHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAcceptConnectPort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortContext, uint32_t ConnectionRequest, uint32_t AcceptConnection, uint32_t ServerView, uint32_t ClientView) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x0\",\"syscall_name\" : \"NtAcceptConnectPort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortContext\":\"0x%x\", \"ConnectionRequest\":\"0x%x\", \"AcceptConnection\":\"0x%x\", \"ServerView\":\"0x%x\", \"ClientView\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortContext, ConnectionRequest, AcceptConnection, ServerView, ClientView, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortHandle\" : ");fprintf(outFile, "\"Unable to read PortHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*1 NTSTATUS NtAccessCheck (PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);*/
void on_cb_NtAccessCheck_enter(CPUState *cpu, target_ulong pc, uint32_t SecurityDescriptor, uint32_t ClientToken, uint32_t DesiredAccess, uint32_t GenericMapping, uint32_t PrivilegeSet, uint32_t PrivilegeSetLength, uint32_t GrantedAccess, uint32_t AccessStatus) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x1\",\"syscall_name\" : \"NtAccessCheck\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SecurityDescriptor\":\"0x%x\", \"ClientToken\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"GenericMapping\":\"0x%x\", \"PrivilegeSet\":\"0x%x\", \"PrivilegeSetLength\":\"0x%x\", \"GrantedAccess\":\"0x%x\", \"AccessStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SecurityDescriptor, ClientToken, DesiredAccess, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PrivilegeSetLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PrivilegeSetLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PrivilegeSetLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PrivilegeSetLength\" : ");fprintf(outFile, "\"Unable to read PrivilegeSetLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAccessCheck_return(CPUState *cpu, target_ulong pc, uint32_t SecurityDescriptor, uint32_t ClientToken, uint32_t DesiredAccess, uint32_t GenericMapping, uint32_t PrivilegeSet, uint32_t PrivilegeSetLength, uint32_t GrantedAccess, uint32_t AccessStatus) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x1\",\"syscall_name\" : \"NtAccessCheck\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SecurityDescriptor\":\"0x%x\", \"ClientToken\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"GenericMapping\":\"0x%x\", \"PrivilegeSet\":\"0x%x\", \"PrivilegeSetLength\":\"0x%x\", \"GrantedAccess\":\"0x%x\", \"AccessStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SecurityDescriptor, ClientToken, DesiredAccess, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PrivilegeSetLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PrivilegeSetLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PrivilegeSetLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PrivilegeSetLength\" : ");fprintf(outFile, "\"Unable to read PrivilegeSetLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*2 NTSTATUS NtAccessCheckAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);*/
void on_cb_NtAccessCheckAndAuditAlarm_enter(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t HandleId, uint32_t ObjectTypeName, uint32_t ObjectName, uint32_t SecurityDescriptor, uint32_t DesiredAccess, uint32_t GenericMapping, uint32_t ObjectCreation, uint32_t GrantedAccess, uint32_t AccessStatus, uint32_t GenerateOnClose) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x2\",\"syscall_name\" : \"NtAccessCheckAndAuditAlarm\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"HandleId\":\"0x%x\", \"ObjectTypeName\":\"0x%x\", \"ObjectName\":\"0x%x\", \"SecurityDescriptor\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"GenericMapping\":\"0x%x\", \"ObjectCreation\":\"0x%x\", \"GrantedAccess\":\"0x%x\", \"AccessStatus\":\"0x%x\", \"GenerateOnClose\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, GenerateOnClose, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectTypeName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectTypeName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectTypeName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectTypeName\" : ");fprintf(outFile, "\"Unable to read ObjectTypeName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectName\" : ");fprintf(outFile, "\"Unable to read ObjectName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAccessCheckAndAuditAlarm_return(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t HandleId, uint32_t ObjectTypeName, uint32_t ObjectName, uint32_t SecurityDescriptor, uint32_t DesiredAccess, uint32_t GenericMapping, uint32_t ObjectCreation, uint32_t GrantedAccess, uint32_t AccessStatus, uint32_t GenerateOnClose) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x2\",\"syscall_name\" : \"NtAccessCheckAndAuditAlarm\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"HandleId\":\"0x%x\", \"ObjectTypeName\":\"0x%x\", \"ObjectName\":\"0x%x\", \"SecurityDescriptor\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"GenericMapping\":\"0x%x\", \"ObjectCreation\":\"0x%x\", \"GrantedAccess\":\"0x%x\", \"AccessStatus\":\"0x%x\", \"GenerateOnClose\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, GenerateOnClose, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectTypeName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectTypeName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectTypeName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectTypeName\" : ");fprintf(outFile, "\"Unable to read ObjectTypeName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectName\" : ");fprintf(outFile, "\"Unable to read ObjectName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*3 NTSTATUS NtAccessCheckByType (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);*/
void on_cb_NtAccessCheckByType_enter(CPUState *cpu, target_ulong pc, uint32_t SecurityDescriptor, uint32_t PrincipalSelfSid, uint32_t ClientToken, uint32_t DesiredAccess, uint32_t ObjectTypeList, uint32_t ObjectTypeListLength, uint32_t GenericMapping, uint32_t PrivilegeSet, uint32_t PrivilegeSetLength, uint32_t GrantedAccess, uint32_t AccessStatus) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x3\",\"syscall_name\" : \"NtAccessCheckByType\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SecurityDescriptor\":\"0x%x\", \"PrincipalSelfSid\":\"0x%x\", \"ClientToken\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectTypeList\":\"0x%x\", \"ObjectTypeListLength\":\"0x%x\", \"GenericMapping\":\"0x%x\", \"PrivilegeSet\":\"0x%x\", \"PrivilegeSetLength\":\"0x%x\", \"GrantedAccess\":\"0x%x\", \"AccessStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PrivilegeSetLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PrivilegeSetLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PrivilegeSetLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PrivilegeSetLength\" : ");fprintf(outFile, "\"Unable to read PrivilegeSetLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAccessCheckByType_return(CPUState *cpu, target_ulong pc, uint32_t SecurityDescriptor, uint32_t PrincipalSelfSid, uint32_t ClientToken, uint32_t DesiredAccess, uint32_t ObjectTypeList, uint32_t ObjectTypeListLength, uint32_t GenericMapping, uint32_t PrivilegeSet, uint32_t PrivilegeSetLength, uint32_t GrantedAccess, uint32_t AccessStatus) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x3\",\"syscall_name\" : \"NtAccessCheckByType\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SecurityDescriptor\":\"0x%x\", \"PrincipalSelfSid\":\"0x%x\", \"ClientToken\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectTypeList\":\"0x%x\", \"ObjectTypeListLength\":\"0x%x\", \"GenericMapping\":\"0x%x\", \"PrivilegeSet\":\"0x%x\", \"PrivilegeSetLength\":\"0x%x\", \"GrantedAccess\":\"0x%x\", \"AccessStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PrivilegeSetLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PrivilegeSetLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PrivilegeSetLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PrivilegeSetLength\" : ");fprintf(outFile, "\"Unable to read PrivilegeSetLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*4 NTSTATUS NtAccessCheckByTypeAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);*/
void on_cb_NtAccessCheckByTypeAndAuditAlarm_enter(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t HandleId, uint32_t ObjectTypeName, uint32_t ObjectName, uint32_t SecurityDescriptor, uint32_t PrincipalSelfSid, uint32_t DesiredAccess, uint32_t AuditType, uint32_t Flags, uint32_t ObjectTypeList, uint32_t ObjectTypeListLength, uint32_t GenericMapping, uint32_t ObjectCreation, uint32_t GrantedAccess, uint32_t AccessStatus, uint32_t GenerateOnClose) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x4\",\"syscall_name\" : \"NtAccessCheckByTypeAndAuditAlarm\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"HandleId\":\"0x%x\", \"ObjectTypeName\":\"0x%x\", \"ObjectName\":\"0x%x\", \"SecurityDescriptor\":\"0x%x\", \"PrincipalSelfSid\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"AuditType\":\"0x%x\", \"Flags\":\"0x%x\", \"ObjectTypeList\":\"0x%x\", \"ObjectTypeListLength\":\"0x%x\", \"GenericMapping\":\"0x%x\", \"ObjectCreation\":\"0x%x\", \"GrantedAccess\":\"0x%x\", \"AccessStatus\":\"0x%x\", \"GenerateOnClose\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, GenerateOnClose, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectTypeName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectTypeName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectTypeName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectTypeName\" : ");fprintf(outFile, "\"Unable to read ObjectTypeName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectName\" : ");fprintf(outFile, "\"Unable to read ObjectName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAccessCheckByTypeAndAuditAlarm_return(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t HandleId, uint32_t ObjectTypeName, uint32_t ObjectName, uint32_t SecurityDescriptor, uint32_t PrincipalSelfSid, uint32_t DesiredAccess, uint32_t AuditType, uint32_t Flags, uint32_t ObjectTypeList, uint32_t ObjectTypeListLength, uint32_t GenericMapping, uint32_t ObjectCreation, uint32_t GrantedAccess, uint32_t AccessStatus, uint32_t GenerateOnClose) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x4\",\"syscall_name\" : \"NtAccessCheckByTypeAndAuditAlarm\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"HandleId\":\"0x%x\", \"ObjectTypeName\":\"0x%x\", \"ObjectName\":\"0x%x\", \"SecurityDescriptor\":\"0x%x\", \"PrincipalSelfSid\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"AuditType\":\"0x%x\", \"Flags\":\"0x%x\", \"ObjectTypeList\":\"0x%x\", \"ObjectTypeListLength\":\"0x%x\", \"GenericMapping\":\"0x%x\", \"ObjectCreation\":\"0x%x\", \"GrantedAccess\":\"0x%x\", \"AccessStatus\":\"0x%x\", \"GenerateOnClose\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, GenerateOnClose, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectTypeName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectTypeName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectTypeName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectTypeName\" : ");fprintf(outFile, "\"Unable to read ObjectTypeName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectName\" : ");fprintf(outFile, "\"Unable to read ObjectName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*5 NTSTATUS NtAccessCheckByTypeResultList (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);*/
void on_cb_NtAccessCheckByTypeResultList_enter(CPUState *cpu, target_ulong pc, uint32_t SecurityDescriptor, uint32_t PrincipalSelfSid, uint32_t ClientToken, uint32_t DesiredAccess, uint32_t ObjectTypeList, uint32_t ObjectTypeListLength, uint32_t GenericMapping, uint32_t PrivilegeSet, uint32_t PrivilegeSetLength, uint32_t GrantedAccess, uint32_t AccessStatus) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x5\",\"syscall_name\" : \"NtAccessCheckByTypeResultList\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SecurityDescriptor\":\"0x%x\", \"PrincipalSelfSid\":\"0x%x\", \"ClientToken\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectTypeList\":\"0x%x\", \"ObjectTypeListLength\":\"0x%x\", \"GenericMapping\":\"0x%x\", \"PrivilegeSet\":\"0x%x\", \"PrivilegeSetLength\":\"0x%x\", \"GrantedAccess\":\"0x%x\", \"AccessStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PrivilegeSetLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PrivilegeSetLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PrivilegeSetLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PrivilegeSetLength\" : ");fprintf(outFile, "\"Unable to read PrivilegeSetLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAccessCheckByTypeResultList_return(CPUState *cpu, target_ulong pc, uint32_t SecurityDescriptor, uint32_t PrincipalSelfSid, uint32_t ClientToken, uint32_t DesiredAccess, uint32_t ObjectTypeList, uint32_t ObjectTypeListLength, uint32_t GenericMapping, uint32_t PrivilegeSet, uint32_t PrivilegeSetLength, uint32_t GrantedAccess, uint32_t AccessStatus) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x5\",\"syscall_name\" : \"NtAccessCheckByTypeResultList\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SecurityDescriptor\":\"0x%x\", \"PrincipalSelfSid\":\"0x%x\", \"ClientToken\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectTypeList\":\"0x%x\", \"ObjectTypeListLength\":\"0x%x\", \"GenericMapping\":\"0x%x\", \"PrivilegeSet\":\"0x%x\", \"PrivilegeSetLength\":\"0x%x\", \"GrantedAccess\":\"0x%x\", \"AccessStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PrivilegeSetLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PrivilegeSetLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PrivilegeSetLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PrivilegeSetLength\" : ");fprintf(outFile, "\"Unable to read PrivilegeSetLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*6 NTSTATUS NtAccessCheckByTypeResultListAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);*/
void on_cb_NtAccessCheckByTypeResultListAndAuditAlarm_enter(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t HandleId, uint32_t ObjectTypeName, uint32_t ObjectName, uint32_t SecurityDescriptor, uint32_t PrincipalSelfSid, uint32_t DesiredAccess, uint32_t AuditType, uint32_t Flags, uint32_t ObjectTypeList, uint32_t ObjectTypeListLength, uint32_t GenericMapping, uint32_t ObjectCreation, uint32_t GrantedAccess, uint32_t AccessStatus, uint32_t GenerateOnClose) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x6\",\"syscall_name\" : \"NtAccessCheckByTypeResultListAndAuditAlarm\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"HandleId\":\"0x%x\", \"ObjectTypeName\":\"0x%x\", \"ObjectName\":\"0x%x\", \"SecurityDescriptor\":\"0x%x\", \"PrincipalSelfSid\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"AuditType\":\"0x%x\", \"Flags\":\"0x%x\", \"ObjectTypeList\":\"0x%x\", \"ObjectTypeListLength\":\"0x%x\", \"GenericMapping\":\"0x%x\", \"ObjectCreation\":\"0x%x\", \"GrantedAccess\":\"0x%x\", \"AccessStatus\":\"0x%x\", \"GenerateOnClose\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, GenerateOnClose, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectTypeName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectTypeName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectTypeName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectTypeName\" : ");fprintf(outFile, "\"Unable to read ObjectTypeName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectName\" : ");fprintf(outFile, "\"Unable to read ObjectName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAccessCheckByTypeResultListAndAuditAlarm_return(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t HandleId, uint32_t ObjectTypeName, uint32_t ObjectName, uint32_t SecurityDescriptor, uint32_t PrincipalSelfSid, uint32_t DesiredAccess, uint32_t AuditType, uint32_t Flags, uint32_t ObjectTypeList, uint32_t ObjectTypeListLength, uint32_t GenericMapping, uint32_t ObjectCreation, uint32_t GrantedAccess, uint32_t AccessStatus, uint32_t GenerateOnClose) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x6\",\"syscall_name\" : \"NtAccessCheckByTypeResultListAndAuditAlarm\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"HandleId\":\"0x%x\", \"ObjectTypeName\":\"0x%x\", \"ObjectName\":\"0x%x\", \"SecurityDescriptor\":\"0x%x\", \"PrincipalSelfSid\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"AuditType\":\"0x%x\", \"Flags\":\"0x%x\", \"ObjectTypeList\":\"0x%x\", \"ObjectTypeListLength\":\"0x%x\", \"GenericMapping\":\"0x%x\", \"ObjectCreation\":\"0x%x\", \"GrantedAccess\":\"0x%x\", \"AccessStatus\":\"0x%x\", \"GenerateOnClose\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, GenerateOnClose, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectTypeName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectTypeName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectTypeName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectTypeName\" : ");fprintf(outFile, "\"Unable to read ObjectTypeName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectName\" : ");fprintf(outFile, "\"Unable to read ObjectName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*7 NTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmByHandle (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);*/
void on_cb_NtAccessCheckByTypeResultListAndAuditAlarmByHandle_enter(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t HandleId, uint32_t ClientToken, uint32_t ObjectTypeName, uint32_t ObjectName, uint32_t SecurityDescriptor, uint32_t PrincipalSelfSid, uint32_t DesiredAccess, uint32_t AuditType, uint32_t Flags, uint32_t ObjectTypeList, uint32_t ObjectTypeListLength, uint32_t GenericMapping, uint32_t ObjectCreation, uint32_t GrantedAccess, uint32_t AccessStatus, uint32_t GenerateOnClose) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x7\",\"syscall_name\" : \"NtAccessCheckByTypeResultListAndAuditAlarmByHandle\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"HandleId\":\"0x%x\", \"ClientToken\":\"0x%x\", \"ObjectTypeName\":\"0x%x\", \"ObjectName\":\"0x%x\", \"SecurityDescriptor\":\"0x%x\", \"PrincipalSelfSid\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"AuditType\":\"0x%x\", \"Flags\":\"0x%x\", \"ObjectTypeList\":\"0x%x\", \"ObjectTypeListLength\":\"0x%x\", \"GenericMapping\":\"0x%x\", \"ObjectCreation\":\"0x%x\", \"GrantedAccess\":\"0x%x\", \"AccessStatus\":\"0x%x\", \"GenerateOnClose\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, HandleId, ClientToken, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, GenerateOnClose, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectTypeName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectTypeName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectTypeName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectTypeName\" : ");fprintf(outFile, "\"Unable to read ObjectTypeName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectName\" : ");fprintf(outFile, "\"Unable to read ObjectName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAccessCheckByTypeResultListAndAuditAlarmByHandle_return(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t HandleId, uint32_t ClientToken, uint32_t ObjectTypeName, uint32_t ObjectName, uint32_t SecurityDescriptor, uint32_t PrincipalSelfSid, uint32_t DesiredAccess, uint32_t AuditType, uint32_t Flags, uint32_t ObjectTypeList, uint32_t ObjectTypeListLength, uint32_t GenericMapping, uint32_t ObjectCreation, uint32_t GrantedAccess, uint32_t AccessStatus, uint32_t GenerateOnClose) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x7\",\"syscall_name\" : \"NtAccessCheckByTypeResultListAndAuditAlarmByHandle\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"HandleId\":\"0x%x\", \"ClientToken\":\"0x%x\", \"ObjectTypeName\":\"0x%x\", \"ObjectName\":\"0x%x\", \"SecurityDescriptor\":\"0x%x\", \"PrincipalSelfSid\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"AuditType\":\"0x%x\", \"Flags\":\"0x%x\", \"ObjectTypeList\":\"0x%x\", \"ObjectTypeListLength\":\"0x%x\", \"GenericMapping\":\"0x%x\", \"ObjectCreation\":\"0x%x\", \"GrantedAccess\":\"0x%x\", \"AccessStatus\":\"0x%x\", \"GenerateOnClose\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, HandleId, ClientToken, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, GenerateOnClose, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectTypeName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectTypeName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectTypeName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectTypeName\" : ");fprintf(outFile, "\"Unable to read ObjectTypeName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectName\" : ");fprintf(outFile, "\"Unable to read ObjectName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*8 NTSTATUS NtAddAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);*/
void on_cb_NtAddAtom_enter(CPUState *cpu, target_ulong pc, uint32_t AtomName, uint32_t Length, uint32_t Atom) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x8\",\"syscall_name\" : \"NtAddAtom\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"AtomName\":\"0x%x\", \"Length\":\"0x%x\", \"Atom\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, AtomName, Length, Atom, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAddAtom_return(CPUState *cpu, target_ulong pc, uint32_t AtomName, uint32_t Length, uint32_t Atom) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x8\",\"syscall_name\" : \"NtAddAtom\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"AtomName\":\"0x%x\", \"Length\":\"0x%x\", \"Atom\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, AtomName, Length, Atom, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*9 NTSTATUS NtAddBootEntry (PBOOT_ENTRY BootEntry, PULONG Id);*/
void on_cb_NtAddBootEntry_enter(CPUState *cpu, target_ulong pc, uint32_t BootEntry, uint32_t Id) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x9\",\"syscall_name\" : \"NtAddBootEntry\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"BootEntry\":\"0x%x\", \"Id\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, BootEntry, Id, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Id;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Id;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Id\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Id\" : ");fprintf(outFile, "\"Unable to read Id\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAddBootEntry_return(CPUState *cpu, target_ulong pc, uint32_t BootEntry, uint32_t Id) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x9\",\"syscall_name\" : \"NtAddBootEntry\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"BootEntry\":\"0x%x\", \"Id\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, BootEntry, Id, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Id;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Id;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Id\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Id\" : ");fprintf(outFile, "\"Unable to read Id\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*10 NTSTATUS NtAddDriverEntry (PEFI_DRIVER_ENTRY DriverEntry, PULONG Id);*/
void on_cb_NtAddDriverEntry_enter(CPUState *cpu, target_ulong pc, uint32_t DriverEntry, uint32_t Id) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xa\",\"syscall_name\" : \"NtAddDriverEntry\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DriverEntry\":\"0x%x\", \"Id\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, DriverEntry, Id, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Id;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Id;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Id\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Id\" : ");fprintf(outFile, "\"Unable to read Id\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAddDriverEntry_return(CPUState *cpu, target_ulong pc, uint32_t DriverEntry, uint32_t Id) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xa\",\"syscall_name\" : \"NtAddDriverEntry\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DriverEntry\":\"0x%x\", \"Id\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, DriverEntry, Id, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Id;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Id;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Id\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Id\" : ");fprintf(outFile, "\"Unable to read Id\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*11 NTSTATUS NtAdjustGroupsToken (HANDLE TokenHandle, BOOLEAN ResetToDefault, PTOKEN_GROUPS NewState, ULONG BufferLength, PTOKEN_GROUPS PreviousState, PULONG ReturnLength);*/
void on_cb_NtAdjustGroupsToken_enter(CPUState *cpu, target_ulong pc, uint32_t TokenHandle, uint32_t ResetToDefault, uint32_t NewState, uint32_t BufferLength, uint32_t PreviousState, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xb\",\"syscall_name\" : \"NtAdjustGroupsToken\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TokenHandle\":\"0x%x\", \"ResetToDefault\":\"0x%x\", \"NewState\":\"0x%x\", \"BufferLength\":\"0x%x\", \"PreviousState\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TokenHandle, ResetToDefault, NewState, BufferLength, PreviousState, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAdjustGroupsToken_return(CPUState *cpu, target_ulong pc, uint32_t TokenHandle, uint32_t ResetToDefault, uint32_t NewState, uint32_t BufferLength, uint32_t PreviousState, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xb\",\"syscall_name\" : \"NtAdjustGroupsToken\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TokenHandle\":\"0x%x\", \"ResetToDefault\":\"0x%x\", \"NewState\":\"0x%x\", \"BufferLength\":\"0x%x\", \"PreviousState\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TokenHandle, ResetToDefault, NewState, BufferLength, PreviousState, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*12 NTSTATUS NtAdjustPrivilegesToken (HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);*/
void on_cb_NtAdjustPrivilegesToken_enter(CPUState *cpu, target_ulong pc, uint32_t TokenHandle, uint32_t DisableAllPrivileges, uint32_t NewState, uint32_t BufferLength, uint32_t PreviousState, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xc\",\"syscall_name\" : \"NtAdjustPrivilegesToken\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TokenHandle\":\"0x%x\", \"DisableAllPrivileges\":\"0x%x\", \"NewState\":\"0x%x\", \"BufferLength\":\"0x%x\", \"PreviousState\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TokenHandle, DisableAllPrivileges, NewState, BufferLength, PreviousState, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAdjustPrivilegesToken_return(CPUState *cpu, target_ulong pc, uint32_t TokenHandle, uint32_t DisableAllPrivileges, uint32_t NewState, uint32_t BufferLength, uint32_t PreviousState, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xc\",\"syscall_name\" : \"NtAdjustPrivilegesToken\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TokenHandle\":\"0x%x\", \"DisableAllPrivileges\":\"0x%x\", \"NewState\":\"0x%x\", \"BufferLength\":\"0x%x\", \"PreviousState\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TokenHandle, DisableAllPrivileges, NewState, BufferLength, PreviousState, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*13 NTSTATUS NtAlertResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);*/
void on_cb_NtAlertResumeThread_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t PreviousSuspendCount) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xd\",\"syscall_name\" : \"NtAlertResumeThread\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"PreviousSuspendCount\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, PreviousSuspendCount, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PreviousSuspendCount;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousSuspendCount;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousSuspendCount\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousSuspendCount\" : ");fprintf(outFile, "\"Unable to read PreviousSuspendCount\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlertResumeThread_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t PreviousSuspendCount) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xd\",\"syscall_name\" : \"NtAlertResumeThread\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"PreviousSuspendCount\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, PreviousSuspendCount, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PreviousSuspendCount;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousSuspendCount;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousSuspendCount\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousSuspendCount\" : ");fprintf(outFile, "\"Unable to read PreviousSuspendCount\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*14 NTSTATUS NtAlertThread (HANDLE ThreadHandle);*/
void on_cb_NtAlertThread_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xe\",\"syscall_name\" : \"NtAlertThread\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlertThread_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xe\",\"syscall_name\" : \"NtAlertThread\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*15 NTSTATUS NtAllocateLocallyUniqueId (PLUID Luid);*/
void on_cb_NtAllocateLocallyUniqueId_enter(CPUState *cpu, target_ulong pc, uint32_t Luid) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xf\",\"syscall_name\" : \"NtAllocateLocallyUniqueId\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Luid\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Luid, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAllocateLocallyUniqueId_return(CPUState *cpu, target_ulong pc, uint32_t Luid) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xf\",\"syscall_name\" : \"NtAllocateLocallyUniqueId\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Luid\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Luid, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*16 NTSTATUS NtAllocateReserveObject (PHANDLE MemoryReserveHandle, POBJECT_ATTRIBUTES ObjectAttributes, MEMORY_RESERVE_TYPE Type);*/
void on_cb_NtAllocateReserveObject_enter(CPUState *cpu, target_ulong pc, uint32_t MemoryReserveHandle, uint32_t ObjectAttributes, uint32_t Type) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x10\",\"syscall_name\" : \"NtAllocateReserveObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"MemoryReserveHandle\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"Type\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, MemoryReserveHandle, ObjectAttributes, Type, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = MemoryReserveHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MemoryReserveHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MemoryReserveHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MemoryReserveHandle\" : ");fprintf(outFile, "\"Unable to read MemoryReserveHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAllocateReserveObject_return(CPUState *cpu, target_ulong pc, uint32_t MemoryReserveHandle, uint32_t ObjectAttributes, uint32_t Type) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x10\",\"syscall_name\" : \"NtAllocateReserveObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"MemoryReserveHandle\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"Type\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, MemoryReserveHandle, ObjectAttributes, Type, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = MemoryReserveHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MemoryReserveHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MemoryReserveHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MemoryReserveHandle\" : ");fprintf(outFile, "\"Unable to read MemoryReserveHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*17 NTSTATUS NtAllocateUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);*/
void on_cb_NtAllocateUserPhysicalPages_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t NumberOfPages, uint32_t UserPfnArray) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x11\",\"syscall_name\" : \"NtAllocateUserPhysicalPages\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"NumberOfPages\":\"0x%x\", \"UserPfnArray\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, NumberOfPages, UserPfnArray, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAllocateUserPhysicalPages_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t NumberOfPages, uint32_t UserPfnArray) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x11\",\"syscall_name\" : \"NtAllocateUserPhysicalPages\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"NumberOfPages\":\"0x%x\", \"UserPfnArray\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, NumberOfPages, UserPfnArray, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*18 NTSTATUS NtAllocateUuids (PULARGE_INTEGER Time, PULONG Range, PULONG Sequence, PCHAR Seed);*/
void on_cb_NtAllocateUuids_enter(CPUState *cpu, target_ulong pc, uint32_t Time, uint32_t Range, uint32_t Sequence, uint32_t Seed) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x12\",\"syscall_name\" : \"NtAllocateUuids\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Time\":\"0x%x\", \"Range\":\"0x%x\", \"Sequence\":\"0x%x\", \"Seed\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Time, Range, Sequence, Seed, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Time;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Time;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Time\" : ");dump_ULARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Time\" : ");fprintf(outFile, "\"Unable to read Time\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Range;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Range;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Range\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Range\" : ");fprintf(outFile, "\"Unable to read Range\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Sequence;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Sequence;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Sequence\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Sequence\" : ");fprintf(outFile, "\"Unable to read Sequence\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAllocateUuids_return(CPUState *cpu, target_ulong pc, uint32_t Time, uint32_t Range, uint32_t Sequence, uint32_t Seed) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x12\",\"syscall_name\" : \"NtAllocateUuids\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Time\":\"0x%x\", \"Range\":\"0x%x\", \"Sequence\":\"0x%x\", \"Seed\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Time, Range, Sequence, Seed, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Time;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Time;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Time\" : ");dump_ULARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Time\" : ");fprintf(outFile, "\"Unable to read Time\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Range;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Range;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Range\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Range\" : ");fprintf(outFile, "\"Unable to read Range\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Sequence;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Sequence;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Sequence\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Sequence\" : ");fprintf(outFile, "\"Unable to read Sequence\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*19 NTSTATUS NtAllocateVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);*/
void on_cb_NtAllocateVirtualMemory_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t ZeroBits, uint32_t RegionSize, uint32_t AllocationType, uint32_t Protect) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x13\",\"syscall_name\" : \"NtAllocateVirtualMemory\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"ZeroBits\":\"0x%x\", \"RegionSize\":\"0x%x\", \"AllocationType\":\"0x%x\", \"Protect\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAllocateVirtualMemory_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t ZeroBits, uint32_t RegionSize, uint32_t AllocationType, uint32_t Protect) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x13\",\"syscall_name\" : \"NtAllocateVirtualMemory\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"ZeroBits\":\"0x%x\", \"RegionSize\":\"0x%x\", \"AllocationType\":\"0x%x\", \"Protect\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*20 NTSTATUS NtAlpcAcceptConnectPort (PHANDLE PortHandle, HANDLE ConnectionPortHandle, ULONG Flags, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes, BOOLEAN AcceptConnection);*/
void on_cb_NtAlpcAcceptConnectPort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t ConnectionPortHandle, uint32_t Flags, uint32_t ObjectAttributes, uint32_t PortAttributes, uint32_t PortContext, uint32_t ConnectionRequest, uint32_t ConnectionMessageAttributes, uint32_t AcceptConnection) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x14\",\"syscall_name\" : \"NtAlpcAcceptConnectPort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"ConnectionPortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"PortAttributes\":\"0x%x\", \"PortContext\":\"0x%x\", \"ConnectionRequest\":\"0x%x\", \"ConnectionMessageAttributes\":\"0x%x\", \"AcceptConnection\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, ConnectionPortHandle, Flags, ObjectAttributes, PortAttributes, PortContext, ConnectionRequest, ConnectionMessageAttributes, AcceptConnection, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortHandle\" : ");fprintf(outFile, "\"Unable to read PortHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcAcceptConnectPort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t ConnectionPortHandle, uint32_t Flags, uint32_t ObjectAttributes, uint32_t PortAttributes, uint32_t PortContext, uint32_t ConnectionRequest, uint32_t ConnectionMessageAttributes, uint32_t AcceptConnection) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x14\",\"syscall_name\" : \"NtAlpcAcceptConnectPort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"ConnectionPortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"PortAttributes\":\"0x%x\", \"PortContext\":\"0x%x\", \"ConnectionRequest\":\"0x%x\", \"ConnectionMessageAttributes\":\"0x%x\", \"AcceptConnection\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, ConnectionPortHandle, Flags, ObjectAttributes, PortAttributes, PortContext, ConnectionRequest, ConnectionMessageAttributes, AcceptConnection, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortHandle\" : ");fprintf(outFile, "\"Unable to read PortHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*21 NTSTATUS NtAlpcCancelMessage (HANDLE PortHandle, ULONG Flags, PALPC_CONTEXT_ATTR MessageContext);*/
void on_cb_NtAlpcCancelMessage_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t MessageContext) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x15\",\"syscall_name\" : \"NtAlpcCancelMessage\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"MessageContext\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, MessageContext, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcCancelMessage_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t MessageContext) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x15\",\"syscall_name\" : \"NtAlpcCancelMessage\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"MessageContext\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, MessageContext, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*22 NTSTATUS NtAlpcConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, ULONG Flags, PSID RequiredServerSid, PPORT_MESSAGE ConnectionMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes, PALPC_MESSAGE_ATTRIBUTES InMessageAttributes, PLARGE_INTEGER Timeout);*/
void on_cb_NtAlpcConnectPort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortName, uint32_t ObjectAttributes, uint32_t PortAttributes, uint32_t Flags, uint32_t RequiredServerSid, uint32_t ConnectionMessage, uint32_t BufferLength, uint32_t OutMessageAttributes, uint32_t InMessageAttributes, uint32_t Timeout) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x16\",\"syscall_name\" : \"NtAlpcConnectPort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortName\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"PortAttributes\":\"0x%x\", \"Flags\":\"0x%x\", \"RequiredServerSid\":\"0x%x\", \"ConnectionMessage\":\"0x%x\", \"BufferLength\":\"0x%x\", \"OutMessageAttributes\":\"0x%x\", \"InMessageAttributes\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortName, ObjectAttributes, PortAttributes, Flags, RequiredServerSid, ConnectionMessage, BufferLength, OutMessageAttributes, InMessageAttributes, Timeout, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortHandle\" : ");fprintf(outFile, "\"Unable to read PortHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = PortName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortName\" : ");fprintf(outFile, "\"Unable to read PortName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = BufferLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BufferLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BufferLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BufferLength\" : ");fprintf(outFile, "\"Unable to read BufferLength\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcConnectPort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortName, uint32_t ObjectAttributes, uint32_t PortAttributes, uint32_t Flags, uint32_t RequiredServerSid, uint32_t ConnectionMessage, uint32_t BufferLength, uint32_t OutMessageAttributes, uint32_t InMessageAttributes, uint32_t Timeout) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x16\",\"syscall_name\" : \"NtAlpcConnectPort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortName\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"PortAttributes\":\"0x%x\", \"Flags\":\"0x%x\", \"RequiredServerSid\":\"0x%x\", \"ConnectionMessage\":\"0x%x\", \"BufferLength\":\"0x%x\", \"OutMessageAttributes\":\"0x%x\", \"InMessageAttributes\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortName, ObjectAttributes, PortAttributes, Flags, RequiredServerSid, ConnectionMessage, BufferLength, OutMessageAttributes, InMessageAttributes, Timeout, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortHandle\" : ");fprintf(outFile, "\"Unable to read PortHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = PortName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortName\" : ");fprintf(outFile, "\"Unable to read PortName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = BufferLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BufferLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BufferLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BufferLength\" : ");fprintf(outFile, "\"Unable to read BufferLength\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*23 NTSTATUS NtAlpcCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes);*/
void on_cb_NtAlpcCreatePort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t ObjectAttributes, uint32_t PortAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x17\",\"syscall_name\" : \"NtAlpcCreatePort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"PortAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, ObjectAttributes, PortAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortHandle\" : ");fprintf(outFile, "\"Unable to read PortHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcCreatePort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t ObjectAttributes, uint32_t PortAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x17\",\"syscall_name\" : \"NtAlpcCreatePort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"PortAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, ObjectAttributes, PortAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortHandle\" : ");fprintf(outFile, "\"Unable to read PortHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*24 NTSTATUS NtAlpcCreatePortSection (HANDLE PortHandle, ULONG Flags, HANDLE SectionHandle, SIZE_T SectionSize, PALPC_HANDLE AlpcSectionHandle, PSIZE_T ActualSectionSize);*/
void on_cb_NtAlpcCreatePortSection_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t SectionHandle, uint32_t SectionSize, uint32_t AlpcSectionHandle, uint32_t ActualSectionSize) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x18\",\"syscall_name\" : \"NtAlpcCreatePortSection\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"SectionHandle\":\"0x%x\", \"SectionSize\":\"0x%x\", \"AlpcSectionHandle\":\"0x%x\", \"ActualSectionSize\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, SectionHandle, SectionSize, AlpcSectionHandle, ActualSectionSize, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcCreatePortSection_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t SectionHandle, uint32_t SectionSize, uint32_t AlpcSectionHandle, uint32_t ActualSectionSize) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x18\",\"syscall_name\" : \"NtAlpcCreatePortSection\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"SectionHandle\":\"0x%x\", \"SectionSize\":\"0x%x\", \"AlpcSectionHandle\":\"0x%x\", \"ActualSectionSize\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, SectionHandle, SectionSize, AlpcSectionHandle, ActualSectionSize, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*25 NTSTATUS NtAlpcCreateResourceReserve (HANDLE PortHandle, ULONG Flags, SIZE_T MessageSize, PALPC_HANDLE ResourceId);*/
void on_cb_NtAlpcCreateResourceReserve_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t MessageSize, uint32_t ResourceId) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x19\",\"syscall_name\" : \"NtAlpcCreateResourceReserve\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"MessageSize\":\"0x%x\", \"ResourceId\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, MessageSize, ResourceId, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcCreateResourceReserve_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t MessageSize, uint32_t ResourceId) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x19\",\"syscall_name\" : \"NtAlpcCreateResourceReserve\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"MessageSize\":\"0x%x\", \"ResourceId\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, MessageSize, ResourceId, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*26 NTSTATUS NtAlpcCreateSectionView (HANDLE PortHandle, ULONG Flags, PALPC_DATA_VIEW_ATTR ViewAttributes);*/
void on_cb_NtAlpcCreateSectionView_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t ViewAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x1a\",\"syscall_name\" : \"NtAlpcCreateSectionView\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"ViewAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, ViewAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcCreateSectionView_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t ViewAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x1a\",\"syscall_name\" : \"NtAlpcCreateSectionView\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"ViewAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, ViewAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*27 NTSTATUS NtAlpcCreateSecurityContext (HANDLE PortHandle, ULONG Flags, PALPC_SECURITY_ATTR SecurityAttribute);*/
void on_cb_NtAlpcCreateSecurityContext_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t SecurityAttribute) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x1b\",\"syscall_name\" : \"NtAlpcCreateSecurityContext\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"SecurityAttribute\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, SecurityAttribute, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcCreateSecurityContext_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t SecurityAttribute) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x1b\",\"syscall_name\" : \"NtAlpcCreateSecurityContext\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"SecurityAttribute\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, SecurityAttribute, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*28 NTSTATUS NtAlpcDeletePortSection (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE SectionHandle);*/
void on_cb_NtAlpcDeletePortSection_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t SectionHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x1c\",\"syscall_name\" : \"NtAlpcDeletePortSection\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"SectionHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, SectionHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcDeletePortSection_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t SectionHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x1c\",\"syscall_name\" : \"NtAlpcDeletePortSection\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"SectionHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, SectionHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*29 NTSTATUS NtAlpcDeleteResourceReserve (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ResourceId);*/
void on_cb_NtAlpcDeleteResourceReserve_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t ResourceId) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x1d\",\"syscall_name\" : \"NtAlpcDeleteResourceReserve\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"ResourceId\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, ResourceId, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcDeleteResourceReserve_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t ResourceId) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x1d\",\"syscall_name\" : \"NtAlpcDeleteResourceReserve\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"ResourceId\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, ResourceId, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*30 NTSTATUS NtAlpcDeleteSectionView (HANDLE PortHandle, ULONG Flags, PVOID ViewBase);*/
void on_cb_NtAlpcDeleteSectionView_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t ViewBase) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x1e\",\"syscall_name\" : \"NtAlpcDeleteSectionView\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"ViewBase\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, ViewBase, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcDeleteSectionView_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t ViewBase) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x1e\",\"syscall_name\" : \"NtAlpcDeleteSectionView\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"ViewBase\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, ViewBase, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*31 NTSTATUS NtAlpcDeleteSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);*/
void on_cb_NtAlpcDeleteSecurityContext_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t ContextHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x1f\",\"syscall_name\" : \"NtAlpcDeleteSecurityContext\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"ContextHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, ContextHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcDeleteSecurityContext_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t ContextHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x1f\",\"syscall_name\" : \"NtAlpcDeleteSecurityContext\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"ContextHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, ContextHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*32 NTSTATUS NtAlpcDisconnectPort (HANDLE PortHandle, ULONG Flags);*/
void on_cb_NtAlpcDisconnectPort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x20\",\"syscall_name\" : \"NtAlpcDisconnectPort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcDisconnectPort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x20\",\"syscall_name\" : \"NtAlpcDisconnectPort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*33 NTSTATUS NtAlpcImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE PortMessage, PVOID Reserved);*/
void on_cb_NtAlpcImpersonateClientOfPort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortMessage, uint32_t Reserved) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x21\",\"syscall_name\" : \"NtAlpcImpersonateClientOfPort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortMessage\":\"0x%x\", \"Reserved\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortMessage, Reserved, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcImpersonateClientOfPort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortMessage, uint32_t Reserved) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x21\",\"syscall_name\" : \"NtAlpcImpersonateClientOfPort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortMessage\":\"0x%x\", \"Reserved\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortMessage, Reserved, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*34 NTSTATUS NtAlpcOpenSenderProcess (PHANDLE ProcessHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtAlpcOpenSenderProcess_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t PortHandle, uint32_t PortMessage, uint32_t Flags, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x22\",\"syscall_name\" : \"NtAlpcOpenSenderProcess\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"PortHandle\":\"0x%x\", \"PortMessage\":\"0x%x\", \"Flags\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, PortHandle, PortMessage, Flags, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ProcessHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProcessHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProcessHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProcessHandle\" : ");fprintf(outFile, "\"Unable to read ProcessHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcOpenSenderProcess_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t PortHandle, uint32_t PortMessage, uint32_t Flags, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x22\",\"syscall_name\" : \"NtAlpcOpenSenderProcess\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"PortHandle\":\"0x%x\", \"PortMessage\":\"0x%x\", \"Flags\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, PortHandle, PortMessage, Flags, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ProcessHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProcessHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProcessHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProcessHandle\" : ");fprintf(outFile, "\"Unable to read ProcessHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*35 NTSTATUS NtAlpcOpenSenderThread (PHANDLE ThreadHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtAlpcOpenSenderThread_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t PortHandle, uint32_t PortMessage, uint32_t Flags, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x23\",\"syscall_name\" : \"NtAlpcOpenSenderThread\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"PortHandle\":\"0x%x\", \"PortMessage\":\"0x%x\", \"Flags\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, PortHandle, PortMessage, Flags, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ThreadHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ThreadHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ThreadHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ThreadHandle\" : ");fprintf(outFile, "\"Unable to read ThreadHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcOpenSenderThread_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t PortHandle, uint32_t PortMessage, uint32_t Flags, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x23\",\"syscall_name\" : \"NtAlpcOpenSenderThread\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"PortHandle\":\"0x%x\", \"PortMessage\":\"0x%x\", \"Flags\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, PortHandle, PortMessage, Flags, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ThreadHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ThreadHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ThreadHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ThreadHandle\" : ");fprintf(outFile, "\"Unable to read ThreadHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*36 NTSTATUS NtAlpcQueryInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);*/
void on_cb_NtAlpcQueryInformation_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortInformationClass, uint32_t PortInformation, uint32_t Length, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x24\",\"syscall_name\" : \"NtAlpcQueryInformation\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortInformationClass\":\"0x%x\", \"PortInformation\":\"0x%x\", \"Length\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortInformationClass, PortInformation, Length, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcQueryInformation_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortInformationClass, uint32_t PortInformation, uint32_t Length, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x24\",\"syscall_name\" : \"NtAlpcQueryInformation\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortInformationClass\":\"0x%x\", \"PortInformation\":\"0x%x\", \"Length\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortInformationClass, PortInformation, Length, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*37 NTSTATUS NtAlpcQueryInformationMessage (HANDLE PortHandle, PPORT_MESSAGE PortMessage, ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass, PVOID MessageInformation, ULONG Length, PULONG ReturnLength);*/
void on_cb_NtAlpcQueryInformationMessage_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortMessage, uint32_t MessageInformationClass, uint32_t MessageInformation, uint32_t Length, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x25\",\"syscall_name\" : \"NtAlpcQueryInformationMessage\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortMessage\":\"0x%x\", \"MessageInformationClass\":\"0x%x\", \"MessageInformation\":\"0x%x\", \"Length\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortMessage, MessageInformationClass, MessageInformation, Length, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcQueryInformationMessage_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortMessage, uint32_t MessageInformationClass, uint32_t MessageInformation, uint32_t Length, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x25\",\"syscall_name\" : \"NtAlpcQueryInformationMessage\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortMessage\":\"0x%x\", \"MessageInformationClass\":\"0x%x\", \"MessageInformation\":\"0x%x\", \"Length\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortMessage, MessageInformationClass, MessageInformation, Length, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*38 NTSTATUS NtAlpcRevokeSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);*/
void on_cb_NtAlpcRevokeSecurityContext_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t ContextHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x26\",\"syscall_name\" : \"NtAlpcRevokeSecurityContext\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"ContextHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, ContextHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcRevokeSecurityContext_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t ContextHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x26\",\"syscall_name\" : \"NtAlpcRevokeSecurityContext\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"ContextHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, ContextHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*39 NTSTATUS NtAlpcSendWaitReceivePort (HANDLE PortHandle, ULONG Flags, PPORT_MESSAGE SendMessage, PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes, PPORT_MESSAGE ReceiveMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes, PLARGE_INTEGER Timeout);*/
void on_cb_NtAlpcSendWaitReceivePort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t SendMessage, uint32_t SendMessageAttributes, uint32_t ReceiveMessage, uint32_t BufferLength, uint32_t ReceiveMessageAttributes, uint32_t Timeout) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x27\",\"syscall_name\" : \"NtAlpcSendWaitReceivePort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"SendMessage\":\"0x%x\", \"SendMessageAttributes\":\"0x%x\", \"ReceiveMessage\":\"0x%x\", \"BufferLength\":\"0x%x\", \"ReceiveMessageAttributes\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, SendMessage, SendMessageAttributes, ReceiveMessage, BufferLength, ReceiveMessageAttributes, Timeout, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BufferLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BufferLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BufferLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BufferLength\" : ");fprintf(outFile, "\"Unable to read BufferLength\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcSendWaitReceivePort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Flags, uint32_t SendMessage, uint32_t SendMessageAttributes, uint32_t ReceiveMessage, uint32_t BufferLength, uint32_t ReceiveMessageAttributes, uint32_t Timeout) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x27\",\"syscall_name\" : \"NtAlpcSendWaitReceivePort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"SendMessage\":\"0x%x\", \"SendMessageAttributes\":\"0x%x\", \"ReceiveMessage\":\"0x%x\", \"BufferLength\":\"0x%x\", \"ReceiveMessageAttributes\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Flags, SendMessage, SendMessageAttributes, ReceiveMessage, BufferLength, ReceiveMessageAttributes, Timeout, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BufferLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BufferLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BufferLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BufferLength\" : ");fprintf(outFile, "\"Unable to read BufferLength\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*40 NTSTATUS NtAlpcSetInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length);*/
void on_cb_NtAlpcSetInformation_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortInformationClass, uint32_t PortInformation, uint32_t Length) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x28\",\"syscall_name\" : \"NtAlpcSetInformation\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortInformationClass\":\"0x%x\", \"PortInformation\":\"0x%x\", \"Length\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortInformationClass, PortInformation, Length, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAlpcSetInformation_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortInformationClass, uint32_t PortInformation, uint32_t Length) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x28\",\"syscall_name\" : \"NtAlpcSetInformation\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortInformationClass\":\"0x%x\", \"PortInformation\":\"0x%x\", \"Length\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortInformationClass, PortInformation, Length, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*41 NTSTATUS NtApphelpCacheControl (APPHELPCOMMAND type, PVOID buf);*/
void on_cb_NtApphelpCacheControl_enter(CPUState *cpu, target_ulong pc, uint32_t type, uint32_t buf) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x29\",\"syscall_name\" : \"NtApphelpCacheControl\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"type\":\"0x%x\", \"buf\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, type, buf, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtApphelpCacheControl_return(CPUState *cpu, target_ulong pc, uint32_t type, uint32_t buf) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x29\",\"syscall_name\" : \"NtApphelpCacheControl\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"type\":\"0x%x\", \"buf\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, type, buf, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*42 NTSTATUS NtAreMappedFilesTheSame (PVOID File1MappedAsAnImage, PVOID File2MappedAsFile);*/
void on_cb_NtAreMappedFilesTheSame_enter(CPUState *cpu, target_ulong pc, uint32_t File1MappedAsAnImage, uint32_t File2MappedAsFile) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x2a\",\"syscall_name\" : \"NtAreMappedFilesTheSame\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"File1MappedAsAnImage\":\"0x%x\", \"File2MappedAsFile\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, File1MappedAsAnImage, File2MappedAsFile, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAreMappedFilesTheSame_return(CPUState *cpu, target_ulong pc, uint32_t File1MappedAsAnImage, uint32_t File2MappedAsFile) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x2a\",\"syscall_name\" : \"NtAreMappedFilesTheSame\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"File1MappedAsAnImage\":\"0x%x\", \"File2MappedAsFile\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, File1MappedAsAnImage, File2MappedAsFile, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*43 NTSTATUS NtAssignProcessToJobObject (HANDLE JobHandle, HANDLE ProcessHandle);*/
void on_cb_NtAssignProcessToJobObject_enter(CPUState *cpu, target_ulong pc, uint32_t JobHandle, uint32_t ProcessHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x2b\",\"syscall_name\" : \"NtAssignProcessToJobObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"JobHandle\":\"0x%x\", \"ProcessHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, JobHandle, ProcessHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtAssignProcessToJobObject_return(CPUState *cpu, target_ulong pc, uint32_t JobHandle, uint32_t ProcessHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x2b\",\"syscall_name\" : \"NtAssignProcessToJobObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"JobHandle\":\"0x%x\", \"ProcessHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, JobHandle, ProcessHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*44 NTSTATUS NtCallbackReturn (PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status);*/
void on_cb_NtCallbackReturn_enter(CPUState *cpu, target_ulong pc, uint32_t OutputBuffer, uint32_t OutputLength, uint32_t Status) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x2c\",\"syscall_name\" : \"NtCallbackReturn\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"OutputBuffer\":\"0x%x\", \"OutputLength\":\"0x%x\", \"Status\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, OutputBuffer, OutputLength, Status, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCallbackReturn_return(CPUState *cpu, target_ulong pc, uint32_t OutputBuffer, uint32_t OutputLength, uint32_t Status) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x2c\",\"syscall_name\" : \"NtCallbackReturn\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"OutputBuffer\":\"0x%x\", \"OutputLength\":\"0x%x\", \"Status\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, OutputBuffer, OutputLength, Status, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*45 NTSTATUS NtCancelIoFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);*/
void on_cb_NtCancelIoFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x2d\",\"syscall_name\" : \"NtCancelIoFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCancelIoFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x2d\",\"syscall_name\" : \"NtCancelIoFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*46 NTSTATUS NtCancelIoFileEx (HANDLE FileHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);*/
void on_cb_NtCancelIoFileEx_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoRequestToCancel, uint32_t IoStatusBlock) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x2e\",\"syscall_name\" : \"NtCancelIoFileEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoRequestToCancel\":\"0x%x\", \"IoStatusBlock\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoRequestToCancel, IoStatusBlock, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCancelIoFileEx_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoRequestToCancel, uint32_t IoStatusBlock) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x2e\",\"syscall_name\" : \"NtCancelIoFileEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoRequestToCancel\":\"0x%x\", \"IoStatusBlock\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoRequestToCancel, IoStatusBlock, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*47 NTSTATUS NtCancelSynchronousIoFile (HANDLE ThreadHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);*/
void on_cb_NtCancelSynchronousIoFile_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t IoRequestToCancel, uint32_t IoStatusBlock) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x2f\",\"syscall_name\" : \"NtCancelSynchronousIoFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"IoRequestToCancel\":\"0x%x\", \"IoStatusBlock\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, IoRequestToCancel, IoStatusBlock, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCancelSynchronousIoFile_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t IoRequestToCancel, uint32_t IoStatusBlock) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x2f\",\"syscall_name\" : \"NtCancelSynchronousIoFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"IoRequestToCancel\":\"0x%x\", \"IoStatusBlock\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, IoRequestToCancel, IoStatusBlock, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*48 NTSTATUS NtCancelTimer (HANDLE TimerHandle, PBOOLEAN CurrentState);*/
void on_cb_NtCancelTimer_enter(CPUState *cpu, target_ulong pc, uint32_t TimerHandle, uint32_t CurrentState) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x30\",\"syscall_name\" : \"NtCancelTimer\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TimerHandle\":\"0x%x\", \"CurrentState\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TimerHandle, CurrentState, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCancelTimer_return(CPUState *cpu, target_ulong pc, uint32_t TimerHandle, uint32_t CurrentState) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x30\",\"syscall_name\" : \"NtCancelTimer\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TimerHandle\":\"0x%x\", \"CurrentState\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TimerHandle, CurrentState, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*49 NTSTATUS NtClearEvent (HANDLE EventHandle);*/
void on_cb_NtClearEvent_enter(CPUState *cpu, target_ulong pc, uint32_t EventHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x31\",\"syscall_name\" : \"NtClearEvent\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtClearEvent_return(CPUState *cpu, target_ulong pc, uint32_t EventHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x31\",\"syscall_name\" : \"NtClearEvent\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*50 NTSTATUS NtClose (HANDLE Handle);*/
void on_cb_NtClose_enter(CPUState *cpu, target_ulong pc, uint32_t Handle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x32\",\"syscall_name\" : \"NtClose\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Handle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Handle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtClose_return(CPUState *cpu, target_ulong pc, uint32_t Handle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x32\",\"syscall_name\" : \"NtClose\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Handle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Handle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*51 NTSTATUS NtCloseObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);*/
void on_cb_NtCloseObjectAuditAlarm_enter(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t HandleId, uint32_t GenerateOnClose) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x33\",\"syscall_name\" : \"NtCloseObjectAuditAlarm\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"HandleId\":\"0x%x\", \"GenerateOnClose\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, HandleId, GenerateOnClose, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCloseObjectAuditAlarm_return(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t HandleId, uint32_t GenerateOnClose) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x33\",\"syscall_name\" : \"NtCloseObjectAuditAlarm\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"HandleId\":\"0x%x\", \"GenerateOnClose\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, HandleId, GenerateOnClose, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*52 NTSTATUS NtCommitComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);*/
void on_cb_NtCommitComplete_enter(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x34\",\"syscall_name\" : \"NtCommitComplete\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCommitComplete_return(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x34\",\"syscall_name\" : \"NtCommitComplete\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*53 NTSTATUS NtCommitEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);*/
void on_cb_NtCommitEnlistment_enter(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x35\",\"syscall_name\" : \"NtCommitEnlistment\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCommitEnlistment_return(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x35\",\"syscall_name\" : \"NtCommitEnlistment\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*54 NTSTATUS NtCommitTransaction (HANDLE TransactionHandle, BOOLEAN Wait);*/
void on_cb_NtCommitTransaction_enter(CPUState *cpu, target_ulong pc, uint32_t TransactionHandle, uint32_t Wait) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x36\",\"syscall_name\" : \"NtCommitTransaction\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionHandle\":\"0x%x\", \"Wait\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TransactionHandle, Wait, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCommitTransaction_return(CPUState *cpu, target_ulong pc, uint32_t TransactionHandle, uint32_t Wait) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x36\",\"syscall_name\" : \"NtCommitTransaction\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionHandle\":\"0x%x\", \"Wait\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TransactionHandle, Wait, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*55 NTSTATUS NtCompactKeys (ULONG Count, HANDLE KeyArray[]);*/
void on_cb_NtCompactKeys_enter(CPUState *cpu, target_ulong pc, uint32_t Count, uint32_t KeyArray) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x37\",\"syscall_name\" : \"NtCompactKeys\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Count\":\"0x%x\", \"KeyArray\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Count, KeyArray, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCompactKeys_return(CPUState *cpu, target_ulong pc, uint32_t Count, uint32_t KeyArray) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x37\",\"syscall_name\" : \"NtCompactKeys\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Count\":\"0x%x\", \"KeyArray\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Count, KeyArray, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*56 NTSTATUS NtCompareTokens (HANDLE FirstTokenHandle, HANDLE SecondTokenHandle, PBOOLEAN Equal);*/
void on_cb_NtCompareTokens_enter(CPUState *cpu, target_ulong pc, uint32_t FirstTokenHandle, uint32_t SecondTokenHandle, uint32_t Equal) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x38\",\"syscall_name\" : \"NtCompareTokens\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FirstTokenHandle\":\"0x%x\", \"SecondTokenHandle\":\"0x%x\", \"Equal\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FirstTokenHandle, SecondTokenHandle, Equal, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCompareTokens_return(CPUState *cpu, target_ulong pc, uint32_t FirstTokenHandle, uint32_t SecondTokenHandle, uint32_t Equal) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x38\",\"syscall_name\" : \"NtCompareTokens\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FirstTokenHandle\":\"0x%x\", \"SecondTokenHandle\":\"0x%x\", \"Equal\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FirstTokenHandle, SecondTokenHandle, Equal, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*57 NTSTATUS NtCompleteConnectPort (HANDLE PortHandle);*/
void on_cb_NtCompleteConnectPort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x39\",\"syscall_name\" : \"NtCompleteConnectPort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCompleteConnectPort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x39\",\"syscall_name\" : \"NtCompleteConnectPort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*58 NTSTATUS NtCompressKey (HANDLE Key);*/
void on_cb_NtCompressKey_enter(CPUState *cpu, target_ulong pc, uint32_t Key) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x3a\",\"syscall_name\" : \"NtCompressKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Key\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Key, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCompressKey_return(CPUState *cpu, target_ulong pc, uint32_t Key) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x3a\",\"syscall_name\" : \"NtCompressKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Key\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Key, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*59 NTSTATUS NtConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);*/
void on_cb_NtConnectPort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortName, uint32_t SecurityQos, uint32_t ClientView, uint32_t ServerView, uint32_t MaxMessageLength, uint32_t ConnectionInformation, uint32_t ConnectionInformationLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x3b\",\"syscall_name\" : \"NtConnectPort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortName\":\"0x%x\", \"SecurityQos\":\"0x%x\", \"ClientView\":\"0x%x\", \"ServerView\":\"0x%x\", \"MaxMessageLength\":\"0x%x\", \"ConnectionInformation\":\"0x%x\", \"ConnectionInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortName, SecurityQos, ClientView, ServerView, MaxMessageLength, ConnectionInformation, ConnectionInformationLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortHandle\" : ");fprintf(outFile, "\"Unable to read PortHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = PortName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortName\" : ");fprintf(outFile, "\"Unable to read PortName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = MaxMessageLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MaxMessageLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MaxMessageLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MaxMessageLength\" : ");fprintf(outFile, "\"Unable to read MaxMessageLength\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ConnectionInformationLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ConnectionInformationLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ConnectionInformationLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ConnectionInformationLength\" : ");fprintf(outFile, "\"Unable to read ConnectionInformationLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtConnectPort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortName, uint32_t SecurityQos, uint32_t ClientView, uint32_t ServerView, uint32_t MaxMessageLength, uint32_t ConnectionInformation, uint32_t ConnectionInformationLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x3b\",\"syscall_name\" : \"NtConnectPort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortName\":\"0x%x\", \"SecurityQos\":\"0x%x\", \"ClientView\":\"0x%x\", \"ServerView\":\"0x%x\", \"MaxMessageLength\":\"0x%x\", \"ConnectionInformation\":\"0x%x\", \"ConnectionInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortName, SecurityQos, ClientView, ServerView, MaxMessageLength, ConnectionInformation, ConnectionInformationLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortHandle\" : ");fprintf(outFile, "\"Unable to read PortHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = PortName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortName\" : ");fprintf(outFile, "\"Unable to read PortName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = MaxMessageLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MaxMessageLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MaxMessageLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MaxMessageLength\" : ");fprintf(outFile, "\"Unable to read MaxMessageLength\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ConnectionInformationLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ConnectionInformationLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ConnectionInformationLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ConnectionInformationLength\" : ");fprintf(outFile, "\"Unable to read ConnectionInformationLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*60 NTSTATUS NtContinue (PCONTEXT ContextRecord, BOOLEAN TestAlert);*/
void on_cb_NtContinue_enter(CPUState *cpu, target_ulong pc, uint32_t ContextRecord, uint32_t TestAlert) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x3c\",\"syscall_name\" : \"NtContinue\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ContextRecord\":\"0x%x\", \"TestAlert\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ContextRecord, TestAlert, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtContinue_return(CPUState *cpu, target_ulong pc, uint32_t ContextRecord, uint32_t TestAlert) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x3c\",\"syscall_name\" : \"NtContinue\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ContextRecord\":\"0x%x\", \"TestAlert\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ContextRecord, TestAlert, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*61 NTSTATUS NtCreateDebugObject (PHANDLE DebugObjectHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);*/
void on_cb_NtCreateDebugObject_enter(CPUState *cpu, target_ulong pc, uint32_t DebugObjectHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t Flags) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x3d\",\"syscall_name\" : \"NtCreateDebugObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DebugObjectHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, DebugObjectHandle, DesiredAccess, ObjectAttributes, Flags, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DebugObjectHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DebugObjectHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DebugObjectHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DebugObjectHandle\" : ");fprintf(outFile, "\"Unable to read DebugObjectHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateDebugObject_return(CPUState *cpu, target_ulong pc, uint32_t DebugObjectHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t Flags) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x3d\",\"syscall_name\" : \"NtCreateDebugObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DebugObjectHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, DebugObjectHandle, DesiredAccess, ObjectAttributes, Flags, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DebugObjectHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DebugObjectHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DebugObjectHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DebugObjectHandle\" : ");fprintf(outFile, "\"Unable to read DebugObjectHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*62 NTSTATUS NtCreateDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtCreateDirectoryObject_enter(CPUState *cpu, target_ulong pc, uint32_t DirectoryHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x3e\",\"syscall_name\" : \"NtCreateDirectoryObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DirectoryHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, DirectoryHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DirectoryHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DirectoryHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DirectoryHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DirectoryHandle\" : ");fprintf(outFile, "\"Unable to read DirectoryHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateDirectoryObject_return(CPUState *cpu, target_ulong pc, uint32_t DirectoryHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x3e\",\"syscall_name\" : \"NtCreateDirectoryObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DirectoryHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, DirectoryHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DirectoryHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DirectoryHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DirectoryHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DirectoryHandle\" : ");fprintf(outFile, "\"Unable to read DirectoryHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*63 NTSTATUS NtCreateEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, HANDLE TransactionHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, NOTIFICATION_MASK NotificationMask, PVOID EnlistmentKey);*/
void on_cb_NtCreateEnlistment_enter(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t DesiredAccess, uint32_t ResourceManagerHandle, uint32_t TransactionHandle, uint32_t ObjectAttributes, uint32_t CreateOptions, uint32_t NotificationMask, uint32_t EnlistmentKey) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x3f\",\"syscall_name\" : \"NtCreateEnlistment\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ResourceManagerHandle\":\"0x%x\", \"TransactionHandle\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"NotificationMask\":\"0x%x\", \"EnlistmentKey\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, DesiredAccess, ResourceManagerHandle, TransactionHandle, ObjectAttributes, CreateOptions, NotificationMask, EnlistmentKey, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = EnlistmentHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = EnlistmentHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"EnlistmentHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"EnlistmentHandle\" : ");fprintf(outFile, "\"Unable to read EnlistmentHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateEnlistment_return(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t DesiredAccess, uint32_t ResourceManagerHandle, uint32_t TransactionHandle, uint32_t ObjectAttributes, uint32_t CreateOptions, uint32_t NotificationMask, uint32_t EnlistmentKey) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x3f\",\"syscall_name\" : \"NtCreateEnlistment\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ResourceManagerHandle\":\"0x%x\", \"TransactionHandle\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"NotificationMask\":\"0x%x\", \"EnlistmentKey\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, DesiredAccess, ResourceManagerHandle, TransactionHandle, ObjectAttributes, CreateOptions, NotificationMask, EnlistmentKey, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = EnlistmentHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = EnlistmentHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"EnlistmentHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"EnlistmentHandle\" : ");fprintf(outFile, "\"Unable to read EnlistmentHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*64 NTSTATUS NtCreateEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);*/
void on_cb_NtCreateEvent_enter(CPUState *cpu, target_ulong pc, uint32_t EventHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t EventType, uint32_t InitialState) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x40\",\"syscall_name\" : \"NtCreateEvent\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"EventType\":\"0x%x\", \"InitialState\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventHandle, DesiredAccess, ObjectAttributes, EventType, InitialState, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = EventHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = EventHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"EventHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"EventHandle\" : ");fprintf(outFile, "\"Unable to read EventHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateEvent_return(CPUState *cpu, target_ulong pc, uint32_t EventHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t EventType, uint32_t InitialState) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x40\",\"syscall_name\" : \"NtCreateEvent\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"EventType\":\"0x%x\", \"InitialState\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventHandle, DesiredAccess, ObjectAttributes, EventType, InitialState, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = EventHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = EventHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"EventHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"EventHandle\" : ");fprintf(outFile, "\"Unable to read EventHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*65 NTSTATUS NtCreateEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtCreateEventPair_enter(CPUState *cpu, target_ulong pc, uint32_t EventPairHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x41\",\"syscall_name\" : \"NtCreateEventPair\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventPairHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventPairHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = EventPairHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = EventPairHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"EventPairHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"EventPairHandle\" : ");fprintf(outFile, "\"Unable to read EventPairHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateEventPair_return(CPUState *cpu, target_ulong pc, uint32_t EventPairHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x41\",\"syscall_name\" : \"NtCreateEventPair\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventPairHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventPairHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = EventPairHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = EventPairHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"EventPairHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"EventPairHandle\" : ");fprintf(outFile, "\"Unable to read EventPairHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*66 NTSTATUS NtCreateFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);*/
void on_cb_NtCreateFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t IoStatusBlock, uint32_t AllocationSize, uint32_t FileAttributes, uint32_t ShareAccess, uint32_t CreateDisposition, uint32_t CreateOptions, uint32_t EaBuffer, uint32_t EaLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x42\",\"syscall_name\" : \"NtCreateFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"AllocationSize\":\"0x%x\", \"FileAttributes\":\"0x%x\", \"ShareAccess\":\"0x%x\", \"CreateDisposition\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"EaBuffer\":\"0x%x\", \"EaLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, EaBuffer, EaLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = FileHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = FileHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"FileHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"FileHandle\" : ");fprintf(outFile, "\"Unable to read FileHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = AllocationSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = AllocationSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"AllocationSize\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"AllocationSize\" : ");fprintf(outFile, "\"Unable to read AllocationSize\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t IoStatusBlock, uint32_t AllocationSize, uint32_t FileAttributes, uint32_t ShareAccess, uint32_t CreateDisposition, uint32_t CreateOptions, uint32_t EaBuffer, uint32_t EaLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x42\",\"syscall_name\" : \"NtCreateFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"AllocationSize\":\"0x%x\", \"FileAttributes\":\"0x%x\", \"ShareAccess\":\"0x%x\", \"CreateDisposition\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"EaBuffer\":\"0x%x\", \"EaLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, EaBuffer, EaLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = FileHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = FileHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"FileHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"FileHandle\" : ");fprintf(outFile, "\"Unable to read FileHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = AllocationSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = AllocationSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"AllocationSize\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"AllocationSize\" : ");fprintf(outFile, "\"Unable to read AllocationSize\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*67 NTSTATUS NtCreateIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count);*/
void on_cb_NtCreateIoCompletion_enter(CPUState *cpu, target_ulong pc, uint32_t IoCompletionHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t Count) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x43\",\"syscall_name\" : \"NtCreateIoCompletion\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"IoCompletionHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"Count\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, IoCompletionHandle, DesiredAccess, ObjectAttributes, Count, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = IoCompletionHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = IoCompletionHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"IoCompletionHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"IoCompletionHandle\" : ");fprintf(outFile, "\"Unable to read IoCompletionHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateIoCompletion_return(CPUState *cpu, target_ulong pc, uint32_t IoCompletionHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t Count) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x43\",\"syscall_name\" : \"NtCreateIoCompletion\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"IoCompletionHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"Count\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, IoCompletionHandle, DesiredAccess, ObjectAttributes, Count, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = IoCompletionHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = IoCompletionHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"IoCompletionHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"IoCompletionHandle\" : ");fprintf(outFile, "\"Unable to read IoCompletionHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*68 NTSTATUS NtCreateJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtCreateJobObject_enter(CPUState *cpu, target_ulong pc, uint32_t JobHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x44\",\"syscall_name\" : \"NtCreateJobObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"JobHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, JobHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = JobHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = JobHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"JobHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"JobHandle\" : ");fprintf(outFile, "\"Unable to read JobHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateJobObject_return(CPUState *cpu, target_ulong pc, uint32_t JobHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x44\",\"syscall_name\" : \"NtCreateJobObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"JobHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, JobHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = JobHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = JobHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"JobHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"JobHandle\" : ");fprintf(outFile, "\"Unable to read JobHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*69 NTSTATUS NtCreateJobSet (ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);*/
void on_cb_NtCreateJobSet_enter(CPUState *cpu, target_ulong pc, uint32_t NumJob, uint32_t UserJobSet, uint32_t Flags) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x45\",\"syscall_name\" : \"NtCreateJobSet\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"NumJob\":\"0x%x\", \"UserJobSet\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, NumJob, UserJobSet, Flags, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateJobSet_return(CPUState *cpu, target_ulong pc, uint32_t NumJob, uint32_t UserJobSet, uint32_t Flags) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x45\",\"syscall_name\" : \"NtCreateJobSet\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"NumJob\":\"0x%x\", \"UserJobSet\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, NumJob, UserJobSet, Flags, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*70 NTSTATUS NtCreateKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);*/
void on_cb_NtCreateKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t TitleIndex, uint32_t Class, uint32_t CreateOptions, uint32_t Disposition) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x46\",\"syscall_name\" : \"NtCreateKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"TitleIndex\":\"0x%x\", \"Class\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"Disposition\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, DesiredAccess, ObjectAttributes, TitleIndex, Class, CreateOptions, Disposition, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyHandle\" : ");fprintf(outFile, "\"Unable to read KeyHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Class;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Class;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Class\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Class\" : ");fprintf(outFile, "\"Unable to read Class\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Disposition;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Disposition;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Disposition\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Disposition\" : ");fprintf(outFile, "\"Unable to read Disposition\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t TitleIndex, uint32_t Class, uint32_t CreateOptions, uint32_t Disposition) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x46\",\"syscall_name\" : \"NtCreateKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"TitleIndex\":\"0x%x\", \"Class\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"Disposition\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, DesiredAccess, ObjectAttributes, TitleIndex, Class, CreateOptions, Disposition, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyHandle\" : ");fprintf(outFile, "\"Unable to read KeyHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Class;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Class;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Class\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Class\" : ");fprintf(outFile, "\"Unable to read Class\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Disposition;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Disposition;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Disposition\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Disposition\" : ");fprintf(outFile, "\"Unable to read Disposition\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*71 NTSTATUS NtCreateKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);*/
void on_cb_NtCreateKeyedEvent_enter(CPUState *cpu, target_ulong pc, uint32_t KeyedEventHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t Flags) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x47\",\"syscall_name\" : \"NtCreateKeyedEvent\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyedEventHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyedEventHandle, DesiredAccess, ObjectAttributes, Flags, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyedEventHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyedEventHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyedEventHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyedEventHandle\" : ");fprintf(outFile, "\"Unable to read KeyedEventHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateKeyedEvent_return(CPUState *cpu, target_ulong pc, uint32_t KeyedEventHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t Flags) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x47\",\"syscall_name\" : \"NtCreateKeyedEvent\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyedEventHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyedEventHandle, DesiredAccess, ObjectAttributes, Flags, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyedEventHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyedEventHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyedEventHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyedEventHandle\" : ");fprintf(outFile, "\"Unable to read KeyedEventHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*72 NTSTATUS NtCreateKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, HANDLE TransactionHandle, PULONG Disposition);*/
void on_cb_NtCreateKeyTransacted_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t TitleIndex, uint32_t Class, uint32_t CreateOptions, uint32_t TransactionHandle, uint32_t Disposition) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x48\",\"syscall_name\" : \"NtCreateKeyTransacted\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"TitleIndex\":\"0x%x\", \"Class\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"TransactionHandle\":\"0x%x\", \"Disposition\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, DesiredAccess, ObjectAttributes, TitleIndex, Class, CreateOptions, TransactionHandle, Disposition, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyHandle\" : ");fprintf(outFile, "\"Unable to read KeyHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Class;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Class;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Class\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Class\" : ");fprintf(outFile, "\"Unable to read Class\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Disposition;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Disposition;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Disposition\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Disposition\" : ");fprintf(outFile, "\"Unable to read Disposition\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateKeyTransacted_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t TitleIndex, uint32_t Class, uint32_t CreateOptions, uint32_t TransactionHandle, uint32_t Disposition) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x48\",\"syscall_name\" : \"NtCreateKeyTransacted\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"TitleIndex\":\"0x%x\", \"Class\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"TransactionHandle\":\"0x%x\", \"Disposition\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, DesiredAccess, ObjectAttributes, TitleIndex, Class, CreateOptions, TransactionHandle, Disposition, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyHandle\" : ");fprintf(outFile, "\"Unable to read KeyHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Class;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Class;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Class\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Class\" : ");fprintf(outFile, "\"Unable to read Class\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Disposition;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Disposition;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Disposition\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Disposition\" : ");fprintf(outFile, "\"Unable to read Disposition\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*73 NTSTATUS NtCreateMailslotFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);*/
void on_cb_NtCreateMailslotFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t IoStatusBlock, uint32_t CreateOptions, uint32_t MailslotQuota, uint32_t MaximumMessageSize, uint32_t ReadTimeout) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x49\",\"syscall_name\" : \"NtCreateMailslotFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"MailslotQuota\":\"0x%x\", \"MaximumMessageSize\":\"0x%x\", \"ReadTimeout\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, CreateOptions, MailslotQuota, MaximumMessageSize, ReadTimeout, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = FileHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = FileHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"FileHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"FileHandle\" : ");fprintf(outFile, "\"Unable to read FileHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ReadTimeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReadTimeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReadTimeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReadTimeout\" : ");fprintf(outFile, "\"Unable to read ReadTimeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateMailslotFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t IoStatusBlock, uint32_t CreateOptions, uint32_t MailslotQuota, uint32_t MaximumMessageSize, uint32_t ReadTimeout) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x49\",\"syscall_name\" : \"NtCreateMailslotFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"MailslotQuota\":\"0x%x\", \"MaximumMessageSize\":\"0x%x\", \"ReadTimeout\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, CreateOptions, MailslotQuota, MaximumMessageSize, ReadTimeout, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = FileHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = FileHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"FileHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"FileHandle\" : ");fprintf(outFile, "\"Unable to read FileHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ReadTimeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReadTimeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReadTimeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReadTimeout\" : ");fprintf(outFile, "\"Unable to read ReadTimeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*74 NTSTATUS NtCreateMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner);*/
void on_cb_NtCreateMutant_enter(CPUState *cpu, target_ulong pc, uint32_t MutantHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t InitialOwner) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x4a\",\"syscall_name\" : \"NtCreateMutant\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"MutantHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"InitialOwner\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, MutantHandle, DesiredAccess, ObjectAttributes, InitialOwner, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = MutantHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MutantHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MutantHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MutantHandle\" : ");fprintf(outFile, "\"Unable to read MutantHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateMutant_return(CPUState *cpu, target_ulong pc, uint32_t MutantHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t InitialOwner) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x4a\",\"syscall_name\" : \"NtCreateMutant\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"MutantHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"InitialOwner\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, MutantHandle, DesiredAccess, ObjectAttributes, InitialOwner, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = MutantHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MutantHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MutantHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MutantHandle\" : ");fprintf(outFile, "\"Unable to read MutantHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*75 NTSTATUS NtCreateNamedPipeFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);*/
void on_cb_NtCreateNamedPipeFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t IoStatusBlock, uint32_t ShareAccess, uint32_t CreateDisposition, uint32_t CreateOptions, uint32_t NamedPipeType, uint32_t ReadMode, uint32_t CompletionMode, uint32_t MaximumInstances, uint32_t InboundQuota, uint32_t OutboundQuota, uint32_t DefaultTimeout) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x4b\",\"syscall_name\" : \"NtCreateNamedPipeFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"ShareAccess\":\"0x%x\", \"CreateDisposition\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"NamedPipeType\":\"0x%x\", \"ReadMode\":\"0x%x\", \"CompletionMode\":\"0x%x\", \"MaximumInstances\":\"0x%x\", \"InboundQuota\":\"0x%x\", \"OutboundQuota\":\"0x%x\", \"DefaultTimeout\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, ShareAccess, CreateDisposition, CreateOptions, NamedPipeType, ReadMode, CompletionMode, MaximumInstances, InboundQuota, OutboundQuota, DefaultTimeout, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = FileHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = FileHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"FileHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"FileHandle\" : ");fprintf(outFile, "\"Unable to read FileHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = DefaultTimeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DefaultTimeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DefaultTimeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DefaultTimeout\" : ");fprintf(outFile, "\"Unable to read DefaultTimeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateNamedPipeFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t IoStatusBlock, uint32_t ShareAccess, uint32_t CreateDisposition, uint32_t CreateOptions, uint32_t NamedPipeType, uint32_t ReadMode, uint32_t CompletionMode, uint32_t MaximumInstances, uint32_t InboundQuota, uint32_t OutboundQuota, uint32_t DefaultTimeout) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x4b\",\"syscall_name\" : \"NtCreateNamedPipeFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"ShareAccess\":\"0x%x\", \"CreateDisposition\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"NamedPipeType\":\"0x%x\", \"ReadMode\":\"0x%x\", \"CompletionMode\":\"0x%x\", \"MaximumInstances\":\"0x%x\", \"InboundQuota\":\"0x%x\", \"OutboundQuota\":\"0x%x\", \"DefaultTimeout\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, ShareAccess, CreateDisposition, CreateOptions, NamedPipeType, ReadMode, CompletionMode, MaximumInstances, InboundQuota, OutboundQuota, DefaultTimeout, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = FileHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = FileHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"FileHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"FileHandle\" : ");fprintf(outFile, "\"Unable to read FileHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = DefaultTimeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DefaultTimeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DefaultTimeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DefaultTimeout\" : ");fprintf(outFile, "\"Unable to read DefaultTimeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*76 NTSTATUS NtCreatePagingFile (PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);*/
void on_cb_NtCreatePagingFile_enter(CPUState *cpu, target_ulong pc, uint32_t PageFileName, uint32_t MinimumSize, uint32_t MaximumSize, uint32_t Priority) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x4c\",\"syscall_name\" : \"NtCreatePagingFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PageFileName\":\"0x%x\", \"MinimumSize\":\"0x%x\", \"MaximumSize\":\"0x%x\", \"Priority\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PageFileName, MinimumSize, MaximumSize, Priority, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PageFileName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PageFileName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PageFileName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PageFileName\" : ");fprintf(outFile, "\"Unable to read PageFileName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = MinimumSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MinimumSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MinimumSize\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MinimumSize\" : ");fprintf(outFile, "\"Unable to read MinimumSize\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = MaximumSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MaximumSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MaximumSize\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MaximumSize\" : ");fprintf(outFile, "\"Unable to read MaximumSize\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreatePagingFile_return(CPUState *cpu, target_ulong pc, uint32_t PageFileName, uint32_t MinimumSize, uint32_t MaximumSize, uint32_t Priority) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x4c\",\"syscall_name\" : \"NtCreatePagingFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PageFileName\":\"0x%x\", \"MinimumSize\":\"0x%x\", \"MaximumSize\":\"0x%x\", \"Priority\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PageFileName, MinimumSize, MaximumSize, Priority, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PageFileName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PageFileName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PageFileName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PageFileName\" : ");fprintf(outFile, "\"Unable to read PageFileName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = MinimumSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MinimumSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MinimumSize\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MinimumSize\" : ");fprintf(outFile, "\"Unable to read MinimumSize\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = MaximumSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MaximumSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MaximumSize\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MaximumSize\" : ");fprintf(outFile, "\"Unable to read MaximumSize\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*77 NTSTATUS NtCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);*/
void on_cb_NtCreatePort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t ObjectAttributes, uint32_t MaxConnectionInfoLength, uint32_t MaxMessageLength, uint32_t MaxPoolUsage) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x4d\",\"syscall_name\" : \"NtCreatePort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"MaxConnectionInfoLength\":\"0x%x\", \"MaxMessageLength\":\"0x%x\", \"MaxPoolUsage\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, ObjectAttributes, MaxConnectionInfoLength, MaxMessageLength, MaxPoolUsage, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortHandle\" : ");fprintf(outFile, "\"Unable to read PortHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreatePort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t ObjectAttributes, uint32_t MaxConnectionInfoLength, uint32_t MaxMessageLength, uint32_t MaxPoolUsage) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x4d\",\"syscall_name\" : \"NtCreatePort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"MaxConnectionInfoLength\":\"0x%x\", \"MaxMessageLength\":\"0x%x\", \"MaxPoolUsage\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, ObjectAttributes, MaxConnectionInfoLength, MaxMessageLength, MaxPoolUsage, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortHandle\" : ");fprintf(outFile, "\"Unable to read PortHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*78 NTSTATUS NtCreatePrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);*/
void on_cb_NtCreatePrivateNamespace_enter(CPUState *cpu, target_ulong pc, uint32_t NamespaceHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t BoundaryDescriptor) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x4e\",\"syscall_name\" : \"NtCreatePrivateNamespace\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"NamespaceHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"BoundaryDescriptor\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, NamespaceHandle, DesiredAccess, ObjectAttributes, BoundaryDescriptor, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NamespaceHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NamespaceHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NamespaceHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NamespaceHandle\" : ");fprintf(outFile, "\"Unable to read NamespaceHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreatePrivateNamespace_return(CPUState *cpu, target_ulong pc, uint32_t NamespaceHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t BoundaryDescriptor) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x4e\",\"syscall_name\" : \"NtCreatePrivateNamespace\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"NamespaceHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"BoundaryDescriptor\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, NamespaceHandle, DesiredAccess, ObjectAttributes, BoundaryDescriptor, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NamespaceHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NamespaceHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NamespaceHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NamespaceHandle\" : ");fprintf(outFile, "\"Unable to read NamespaceHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*79 NTSTATUS NtCreateProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);*/
void on_cb_NtCreateProcess_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t ParentProcess, uint32_t InheritObjectTable, uint32_t SectionHandle, uint32_t DebugPort, uint32_t ExceptionPort) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x4f\",\"syscall_name\" : \"NtCreateProcess\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"ParentProcess\":\"0x%x\", \"InheritObjectTable\":\"0x%x\", \"SectionHandle\":\"0x%x\", \"DebugPort\":\"0x%x\", \"ExceptionPort\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, DesiredAccess, ObjectAttributes, ParentProcess, InheritObjectTable, SectionHandle, DebugPort, ExceptionPort, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ProcessHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProcessHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProcessHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProcessHandle\" : ");fprintf(outFile, "\"Unable to read ProcessHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateProcess_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t ParentProcess, uint32_t InheritObjectTable, uint32_t SectionHandle, uint32_t DebugPort, uint32_t ExceptionPort) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x4f\",\"syscall_name\" : \"NtCreateProcess\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"ParentProcess\":\"0x%x\", \"InheritObjectTable\":\"0x%x\", \"SectionHandle\":\"0x%x\", \"DebugPort\":\"0x%x\", \"ExceptionPort\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, DesiredAccess, ObjectAttributes, ParentProcess, InheritObjectTable, SectionHandle, DebugPort, ExceptionPort, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ProcessHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProcessHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProcessHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProcessHandle\" : ");fprintf(outFile, "\"Unable to read ProcessHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*80 NTSTATUS NtCreateProcessEx (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);*/
void on_cb_NtCreateProcessEx_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t ParentProcess, uint32_t Flags, uint32_t SectionHandle, uint32_t DebugPort, uint32_t ExceptionPort, uint32_t JobMemberLevel) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x50\",\"syscall_name\" : \"NtCreateProcessEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"ParentProcess\":\"0x%x\", \"Flags\":\"0x%x\", \"SectionHandle\":\"0x%x\", \"DebugPort\":\"0x%x\", \"ExceptionPort\":\"0x%x\", \"JobMemberLevel\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, DesiredAccess, ObjectAttributes, ParentProcess, Flags, SectionHandle, DebugPort, ExceptionPort, JobMemberLevel, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ProcessHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProcessHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProcessHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProcessHandle\" : ");fprintf(outFile, "\"Unable to read ProcessHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateProcessEx_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t ParentProcess, uint32_t Flags, uint32_t SectionHandle, uint32_t DebugPort, uint32_t ExceptionPort, uint32_t JobMemberLevel) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x50\",\"syscall_name\" : \"NtCreateProcessEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"ParentProcess\":\"0x%x\", \"Flags\":\"0x%x\", \"SectionHandle\":\"0x%x\", \"DebugPort\":\"0x%x\", \"ExceptionPort\":\"0x%x\", \"JobMemberLevel\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, DesiredAccess, ObjectAttributes, ParentProcess, Flags, SectionHandle, DebugPort, ExceptionPort, JobMemberLevel, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ProcessHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProcessHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProcessHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProcessHandle\" : ");fprintf(outFile, "\"Unable to read ProcessHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*81 NTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);*/
void on_cb_NtCreateProfile_enter(CPUState *cpu, target_ulong pc, uint32_t ProfileHandle, uint32_t Process, uint32_t RangeBase, uint32_t RangeSize, uint32_t BucketSize, uint32_t Buffer, uint32_t BufferSize, uint32_t ProfileSource, uint32_t Affinity) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x51\",\"syscall_name\" : \"NtCreateProfile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProfileHandle\":\"0x%x\", \"Process\":\"0x%x\", \"RangeBase\":\"0x%x\", \"RangeSize\":\"0x%x\", \"BucketSize\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\", \"ProfileSource\":\"0x%x\", \"Affinity\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProfileHandle, Process, RangeBase, RangeSize, BucketSize, Buffer, BufferSize, ProfileSource, Affinity, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ProfileHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProfileHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProfileHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProfileHandle\" : ");fprintf(outFile, "\"Unable to read ProfileHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Buffer;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Buffer;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Buffer\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Buffer\" : ");fprintf(outFile, "\"Unable to read Buffer\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateProfile_return(CPUState *cpu, target_ulong pc, uint32_t ProfileHandle, uint32_t Process, uint32_t RangeBase, uint32_t RangeSize, uint32_t BucketSize, uint32_t Buffer, uint32_t BufferSize, uint32_t ProfileSource, uint32_t Affinity) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x51\",\"syscall_name\" : \"NtCreateProfile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProfileHandle\":\"0x%x\", \"Process\":\"0x%x\", \"RangeBase\":\"0x%x\", \"RangeSize\":\"0x%x\", \"BucketSize\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\", \"ProfileSource\":\"0x%x\", \"Affinity\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProfileHandle, Process, RangeBase, RangeSize, BucketSize, Buffer, BufferSize, ProfileSource, Affinity, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ProfileHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProfileHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProfileHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProfileHandle\" : ");fprintf(outFile, "\"Unable to read ProfileHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Buffer;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Buffer;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Buffer\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Buffer\" : ");fprintf(outFile, "\"Unable to read Buffer\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*82 NTSTATUS NtCreateProfileEx (PHANDLE ProfileHandle, HANDLE Process, PVOID ProfileBase, SIZE_T ProfileSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, ULONG GroupAffinityCount, PGROUP_AFFINITY GroupAffinity);*/
void on_cb_NtCreateProfileEx_enter(CPUState *cpu, target_ulong pc, uint32_t ProfileHandle, uint32_t Process, uint32_t ProfileBase, uint32_t ProfileSize, uint32_t BucketSize, uint32_t Buffer, uint32_t BufferSize, uint32_t ProfileSource, uint32_t GroupAffinityCount, uint32_t GroupAffinity) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x52\",\"syscall_name\" : \"NtCreateProfileEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProfileHandle\":\"0x%x\", \"Process\":\"0x%x\", \"ProfileBase\":\"0x%x\", \"ProfileSize\":\"0x%x\", \"BucketSize\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\", \"ProfileSource\":\"0x%x\", \"GroupAffinityCount\":\"0x%x\", \"GroupAffinity\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProfileHandle, Process, ProfileBase, ProfileSize, BucketSize, Buffer, BufferSize, ProfileSource, GroupAffinityCount, GroupAffinity, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ProfileHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProfileHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProfileHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProfileHandle\" : ");fprintf(outFile, "\"Unable to read ProfileHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Buffer;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Buffer;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Buffer\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Buffer\" : ");fprintf(outFile, "\"Unable to read Buffer\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateProfileEx_return(CPUState *cpu, target_ulong pc, uint32_t ProfileHandle, uint32_t Process, uint32_t ProfileBase, uint32_t ProfileSize, uint32_t BucketSize, uint32_t Buffer, uint32_t BufferSize, uint32_t ProfileSource, uint32_t GroupAffinityCount, uint32_t GroupAffinity) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x52\",\"syscall_name\" : \"NtCreateProfileEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProfileHandle\":\"0x%x\", \"Process\":\"0x%x\", \"ProfileBase\":\"0x%x\", \"ProfileSize\":\"0x%x\", \"BucketSize\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\", \"ProfileSource\":\"0x%x\", \"GroupAffinityCount\":\"0x%x\", \"GroupAffinity\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProfileHandle, Process, ProfileBase, ProfileSize, BucketSize, Buffer, BufferSize, ProfileSource, GroupAffinityCount, GroupAffinity, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ProfileHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProfileHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProfileHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProfileHandle\" : ");fprintf(outFile, "\"Unable to read ProfileHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Buffer;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Buffer;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Buffer\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Buffer\" : ");fprintf(outFile, "\"Unable to read Buffer\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*83 NTSTATUS NtCreateResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID RmGuid, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, PUNICODE_STRING Description);*/
void on_cb_NtCreateResourceManager_enter(CPUState *cpu, target_ulong pc, uint32_t ResourceManagerHandle, uint32_t DesiredAccess, uint32_t TmHandle, uint32_t RmGuid, uint32_t ObjectAttributes, uint32_t CreateOptions, uint32_t Description) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x53\",\"syscall_name\" : \"NtCreateResourceManager\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManagerHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"TmHandle\":\"0x%x\", \"RmGuid\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"Description\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ResourceManagerHandle, DesiredAccess, TmHandle, RmGuid, ObjectAttributes, CreateOptions, Description, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ResourceManagerHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ResourceManagerHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ResourceManagerHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ResourceManagerHandle\" : ");fprintf(outFile, "\"Unable to read ResourceManagerHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Description;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Description;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Description\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Description\" : ");fprintf(outFile, "\"Unable to read Description\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateResourceManager_return(CPUState *cpu, target_ulong pc, uint32_t ResourceManagerHandle, uint32_t DesiredAccess, uint32_t TmHandle, uint32_t RmGuid, uint32_t ObjectAttributes, uint32_t CreateOptions, uint32_t Description) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x53\",\"syscall_name\" : \"NtCreateResourceManager\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManagerHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"TmHandle\":\"0x%x\", \"RmGuid\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"Description\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ResourceManagerHandle, DesiredAccess, TmHandle, RmGuid, ObjectAttributes, CreateOptions, Description, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ResourceManagerHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ResourceManagerHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ResourceManagerHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ResourceManagerHandle\" : ");fprintf(outFile, "\"Unable to read ResourceManagerHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Description;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Description;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Description\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Description\" : ");fprintf(outFile, "\"Unable to read Description\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*84 NTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);*/
void on_cb_NtCreateSection_enter(CPUState *cpu, target_ulong pc, uint32_t SectionHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t MaximumSize, uint32_t SectionPageProtection, uint32_t AllocationAttributes, uint32_t FileHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x54\",\"syscall_name\" : \"NtCreateSection\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SectionHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"MaximumSize\":\"0x%x\", \"SectionPageProtection\":\"0x%x\", \"AllocationAttributes\":\"0x%x\", \"FileHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SectionHandle, DesiredAccess, ObjectAttributes, MaximumSize, SectionPageProtection, AllocationAttributes, FileHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SectionHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SectionHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SectionHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SectionHandle\" : ");fprintf(outFile, "\"Unable to read SectionHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = MaximumSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MaximumSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MaximumSize\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MaximumSize\" : ");fprintf(outFile, "\"Unable to read MaximumSize\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateSection_return(CPUState *cpu, target_ulong pc, uint32_t SectionHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t MaximumSize, uint32_t SectionPageProtection, uint32_t AllocationAttributes, uint32_t FileHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x54\",\"syscall_name\" : \"NtCreateSection\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SectionHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"MaximumSize\":\"0x%x\", \"SectionPageProtection\":\"0x%x\", \"AllocationAttributes\":\"0x%x\", \"FileHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SectionHandle, DesiredAccess, ObjectAttributes, MaximumSize, SectionPageProtection, AllocationAttributes, FileHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SectionHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SectionHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SectionHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SectionHandle\" : ");fprintf(outFile, "\"Unable to read SectionHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = MaximumSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MaximumSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MaximumSize\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MaximumSize\" : ");fprintf(outFile, "\"Unable to read MaximumSize\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*85 NTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);*/
void on_cb_NtCreateSemaphore_enter(CPUState *cpu, target_ulong pc, uint32_t SemaphoreHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, int32_t InitialCount, int32_t MaximumCount) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x55\",\"syscall_name\" : \"NtCreateSemaphore\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SemaphoreHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"InitialCount\":\"0x%x\", \"MaximumCount\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SemaphoreHandle, DesiredAccess, ObjectAttributes, InitialCount, MaximumCount, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SemaphoreHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SemaphoreHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SemaphoreHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SemaphoreHandle\" : ");fprintf(outFile, "\"Unable to read SemaphoreHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateSemaphore_return(CPUState *cpu, target_ulong pc, uint32_t SemaphoreHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, int32_t InitialCount, int32_t MaximumCount) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x55\",\"syscall_name\" : \"NtCreateSemaphore\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SemaphoreHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"InitialCount\":\"0x%x\", \"MaximumCount\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SemaphoreHandle, DesiredAccess, ObjectAttributes, InitialCount, MaximumCount, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SemaphoreHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SemaphoreHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SemaphoreHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SemaphoreHandle\" : ");fprintf(outFile, "\"Unable to read SemaphoreHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*86 NTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);*/
void on_cb_NtCreateSymbolicLinkObject_enter(CPUState *cpu, target_ulong pc, uint32_t LinkHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t LinkTarget) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x56\",\"syscall_name\" : \"NtCreateSymbolicLinkObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"LinkHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"LinkTarget\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, LinkHandle, DesiredAccess, ObjectAttributes, LinkTarget, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = LinkHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = LinkHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"LinkHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"LinkHandle\" : ");fprintf(outFile, "\"Unable to read LinkHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = LinkTarget;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = LinkTarget;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"LinkTarget\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"LinkTarget\" : ");fprintf(outFile, "\"Unable to read LinkTarget\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateSymbolicLinkObject_return(CPUState *cpu, target_ulong pc, uint32_t LinkHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t LinkTarget) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x56\",\"syscall_name\" : \"NtCreateSymbolicLinkObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"LinkHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"LinkTarget\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, LinkHandle, DesiredAccess, ObjectAttributes, LinkTarget, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = LinkHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = LinkHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"LinkHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"LinkHandle\" : ");fprintf(outFile, "\"Unable to read LinkHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = LinkTarget;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = LinkTarget;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"LinkTarget\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"LinkTarget\" : ");fprintf(outFile, "\"Unable to read LinkTarget\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*87 NTSTATUS NtCreateThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);*/
void on_cb_NtCreateThread_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t ProcessHandle, uint32_t ClientId, uint32_t ThreadContext, uint32_t InitialTeb, uint32_t CreateSuspended) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x57\",\"syscall_name\" : \"NtCreateThread\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"ProcessHandle\":\"0x%x\", \"ClientId\":\"0x%x\", \"ThreadContext\":\"0x%x\", \"InitialTeb\":\"0x%x\", \"CreateSuspended\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, ClientId, ThreadContext, InitialTeb, CreateSuspended, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ThreadHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ThreadHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ThreadHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ThreadHandle\" : ");fprintf(outFile, "\"Unable to read ThreadHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateThread_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t ProcessHandle, uint32_t ClientId, uint32_t ThreadContext, uint32_t InitialTeb, uint32_t CreateSuspended) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x57\",\"syscall_name\" : \"NtCreateThread\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"ProcessHandle\":\"0x%x\", \"ClientId\":\"0x%x\", \"ThreadContext\":\"0x%x\", \"InitialTeb\":\"0x%x\", \"CreateSuspended\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, ClientId, ThreadContext, InitialTeb, CreateSuspended, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ThreadHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ThreadHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ThreadHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ThreadHandle\" : ");fprintf(outFile, "\"Unable to read ThreadHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*88 NTSTATUS NtCreateThreadEx (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, ULONG_PTR ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PPS_ATTRIBUTE_LIST AttributeList);*/
void on_cb_NtCreateThreadEx_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t ProcessHandle, uint32_t StartRoutine, uint32_t Argument, uint32_t CreateFlags, uint32_t ZeroBits, uint32_t StackSize, uint32_t MaximumStackSize, uint32_t AttributeList) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x58\",\"syscall_name\" : \"NtCreateThreadEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"ProcessHandle\":\"0x%x\", \"StartRoutine\":\"0x%x\", \"Argument\":\"0x%x\", \"CreateFlags\":\"0x%x\", \"ZeroBits\":\"0x%x\", \"StackSize\":\"0x%x\", \"MaximumStackSize\":\"0x%x\", \"AttributeList\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, StartRoutine, Argument, CreateFlags, ZeroBits, StackSize, MaximumStackSize, AttributeList, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ThreadHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ThreadHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ThreadHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ThreadHandle\" : ");fprintf(outFile, "\"Unable to read ThreadHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateThreadEx_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t ProcessHandle, uint32_t StartRoutine, uint32_t Argument, uint32_t CreateFlags, uint32_t ZeroBits, uint32_t StackSize, uint32_t MaximumStackSize, uint32_t AttributeList) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x58\",\"syscall_name\" : \"NtCreateThreadEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"ProcessHandle\":\"0x%x\", \"StartRoutine\":\"0x%x\", \"Argument\":\"0x%x\", \"CreateFlags\":\"0x%x\", \"ZeroBits\":\"0x%x\", \"StackSize\":\"0x%x\", \"MaximumStackSize\":\"0x%x\", \"AttributeList\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, StartRoutine, Argument, CreateFlags, ZeroBits, StackSize, MaximumStackSize, AttributeList, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ThreadHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ThreadHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ThreadHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ThreadHandle\" : ");fprintf(outFile, "\"Unable to read ThreadHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*89 NTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);*/
void on_cb_NtCreateTimer_enter(CPUState *cpu, target_ulong pc, uint32_t TimerHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t TimerType) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x59\",\"syscall_name\" : \"NtCreateTimer\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TimerHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"TimerType\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TimerHandle, DesiredAccess, ObjectAttributes, TimerType, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TimerHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TimerHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TimerHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TimerHandle\" : ");fprintf(outFile, "\"Unable to read TimerHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateTimer_return(CPUState *cpu, target_ulong pc, uint32_t TimerHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t TimerType) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x59\",\"syscall_name\" : \"NtCreateTimer\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TimerHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"TimerType\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TimerHandle, DesiredAccess, ObjectAttributes, TimerType, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TimerHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TimerHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TimerHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TimerHandle\" : ");fprintf(outFile, "\"Unable to read TimerHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*90 NTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);*/
void on_cb_NtCreateToken_enter(CPUState *cpu, target_ulong pc, uint32_t TokenHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t TokenType, uint32_t AuthenticationId, uint32_t ExpirationTime, uint32_t User, uint32_t Groups, uint32_t Privileges, uint32_t Owner, uint32_t PrimaryGroup, uint32_t DefaultDacl, uint32_t TokenSource) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x5a\",\"syscall_name\" : \"NtCreateToken\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TokenHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"TokenType\":\"0x%x\", \"AuthenticationId\":\"0x%x\", \"ExpirationTime\":\"0x%x\", \"User\":\"0x%x\", \"Groups\":\"0x%x\", \"Privileges\":\"0x%x\", \"Owner\":\"0x%x\", \"PrimaryGroup\":\"0x%x\", \"DefaultDacl\":\"0x%x\", \"TokenSource\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TokenHandle, DesiredAccess, ObjectAttributes, TokenType, AuthenticationId, ExpirationTime, User, Groups, Privileges, Owner, PrimaryGroup, DefaultDacl, TokenSource, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TokenHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TokenHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TokenHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TokenHandle\" : ");fprintf(outFile, "\"Unable to read TokenHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ExpirationTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ExpirationTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ExpirationTime\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ExpirationTime\" : ");fprintf(outFile, "\"Unable to read ExpirationTime\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateToken_return(CPUState *cpu, target_ulong pc, uint32_t TokenHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t TokenType, uint32_t AuthenticationId, uint32_t ExpirationTime, uint32_t User, uint32_t Groups, uint32_t Privileges, uint32_t Owner, uint32_t PrimaryGroup, uint32_t DefaultDacl, uint32_t TokenSource) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x5a\",\"syscall_name\" : \"NtCreateToken\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TokenHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"TokenType\":\"0x%x\", \"AuthenticationId\":\"0x%x\", \"ExpirationTime\":\"0x%x\", \"User\":\"0x%x\", \"Groups\":\"0x%x\", \"Privileges\":\"0x%x\", \"Owner\":\"0x%x\", \"PrimaryGroup\":\"0x%x\", \"DefaultDacl\":\"0x%x\", \"TokenSource\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TokenHandle, DesiredAccess, ObjectAttributes, TokenType, AuthenticationId, ExpirationTime, User, Groups, Privileges, Owner, PrimaryGroup, DefaultDacl, TokenSource, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TokenHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TokenHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TokenHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TokenHandle\" : ");fprintf(outFile, "\"Unable to read TokenHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ExpirationTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ExpirationTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ExpirationTime\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ExpirationTime\" : ");fprintf(outFile, "\"Unable to read ExpirationTime\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*91 NTSTATUS NtCreateTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle, ULONG CreateOptions, ULONG IsolationLevel, ULONG IsolationFlags, PLARGE_INTEGER Timeout, PUNICODE_STRING Description);*/
void on_cb_NtCreateTransaction_enter(CPUState *cpu, target_ulong pc, uint32_t TransactionHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t Uow, uint32_t TmHandle, uint32_t CreateOptions, uint32_t IsolationLevel, uint32_t IsolationFlags, uint32_t Timeout, uint32_t Description) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x5b\",\"syscall_name\" : \"NtCreateTransaction\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"Uow\":\"0x%x\", \"TmHandle\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"IsolationLevel\":\"0x%x\", \"IsolationFlags\":\"0x%x\", \"Timeout\":\"0x%x\", \"Description\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TransactionHandle, DesiredAccess, ObjectAttributes, Uow, TmHandle, CreateOptions, IsolationLevel, IsolationFlags, Timeout, Description, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TransactionHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TransactionHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TransactionHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TransactionHandle\" : ");fprintf(outFile, "\"Unable to read TransactionHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Description;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Description;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Description\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Description\" : ");fprintf(outFile, "\"Unable to read Description\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateTransaction_return(CPUState *cpu, target_ulong pc, uint32_t TransactionHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t Uow, uint32_t TmHandle, uint32_t CreateOptions, uint32_t IsolationLevel, uint32_t IsolationFlags, uint32_t Timeout, uint32_t Description) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x5b\",\"syscall_name\" : \"NtCreateTransaction\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"Uow\":\"0x%x\", \"TmHandle\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"IsolationLevel\":\"0x%x\", \"IsolationFlags\":\"0x%x\", \"Timeout\":\"0x%x\", \"Description\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TransactionHandle, DesiredAccess, ObjectAttributes, Uow, TmHandle, CreateOptions, IsolationLevel, IsolationFlags, Timeout, Description, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TransactionHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TransactionHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TransactionHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TransactionHandle\" : ");fprintf(outFile, "\"Unable to read TransactionHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Description;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Description;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Description\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Description\" : ");fprintf(outFile, "\"Unable to read Description\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*92 NTSTATUS NtCreateTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, ULONG CreateOptions, ULONG CommitStrength);*/
void on_cb_NtCreateTransactionManager_enter(CPUState *cpu, target_ulong pc, uint32_t TmHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t LogFileName, uint32_t CreateOptions, uint32_t CommitStrength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x5c\",\"syscall_name\" : \"NtCreateTransactionManager\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TmHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"LogFileName\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"CommitStrength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TmHandle, DesiredAccess, ObjectAttributes, LogFileName, CreateOptions, CommitStrength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmHandle\" : ");fprintf(outFile, "\"Unable to read TmHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = LogFileName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = LogFileName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"LogFileName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"LogFileName\" : ");fprintf(outFile, "\"Unable to read LogFileName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateTransactionManager_return(CPUState *cpu, target_ulong pc, uint32_t TmHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t LogFileName, uint32_t CreateOptions, uint32_t CommitStrength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x5c\",\"syscall_name\" : \"NtCreateTransactionManager\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TmHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"LogFileName\":\"0x%x\", \"CreateOptions\":\"0x%x\", \"CommitStrength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TmHandle, DesiredAccess, ObjectAttributes, LogFileName, CreateOptions, CommitStrength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmHandle\" : ");fprintf(outFile, "\"Unable to read TmHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = LogFileName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = LogFileName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"LogFileName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"LogFileName\" : ");fprintf(outFile, "\"Unable to read LogFileName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*93 NTSTATUS NtCreateUserProcess (PHANDLE ProcessHandle, PHANDLE ThreadHandle, ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, POBJECT_ATTRIBUTES ProcessObjectAttributes, POBJECT_ATTRIBUTES ThreadObjectAttributes, ULONG ProcessFlags, ULONG ThreadFlags, PRTL_USER_PROCESS_PARAMETERS ProcessParameters, PPROCESS_CREATE_INFO CreateInfo, PPROCESS_ATTRIBUTE_LIST AttributeList);*/
void on_cb_NtCreateUserProcess_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t ThreadHandle, uint32_t ProcessDesiredAccess, uint32_t ThreadDesiredAccess, uint32_t ProcessObjectAttributes, uint32_t ThreadObjectAttributes, uint32_t ProcessFlags, uint32_t ThreadFlags, uint32_t ProcessParameters, uint32_t CreateInfo, uint32_t AttributeList) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x5d\",\"syscall_name\" : \"NtCreateUserProcess\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"ThreadHandle\":\"0x%x\", \"ProcessDesiredAccess\":\"0x%x\", \"ThreadDesiredAccess\":\"0x%x\", \"ProcessObjectAttributes\":\"0x%x\", \"ThreadObjectAttributes\":\"0x%x\", \"ProcessFlags\":\"0x%x\", \"ThreadFlags\":\"0x%x\", \"ProcessParameters\":\"0x%x\", \"CreateInfo\":\"0x%x\", \"AttributeList\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, ThreadHandle, ProcessDesiredAccess, ThreadDesiredAccess, ProcessObjectAttributes, ThreadObjectAttributes, ProcessFlags, ThreadFlags, ProcessParameters, CreateInfo, AttributeList, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ProcessHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProcessHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProcessHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProcessHandle\" : ");fprintf(outFile, "\"Unable to read ProcessHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ThreadHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ThreadHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ThreadHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ThreadHandle\" : ");fprintf(outFile, "\"Unable to read ThreadHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ProcessObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProcessObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProcessObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProcessObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ProcessObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ThreadObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ThreadObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ThreadObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ThreadObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ThreadObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ProcessParameters;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProcessParameters;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            RTL_USER_PROCESS_PARAMETERS pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProcessParameters\" : ");dump_RTL_USER_PROCESS_PARAMETERS(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProcessParameters\" : ");fprintf(outFile, "\"Unable to read ProcessParameters\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateUserProcess_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t ThreadHandle, uint32_t ProcessDesiredAccess, uint32_t ThreadDesiredAccess, uint32_t ProcessObjectAttributes, uint32_t ThreadObjectAttributes, uint32_t ProcessFlags, uint32_t ThreadFlags, uint32_t ProcessParameters, uint32_t CreateInfo, uint32_t AttributeList) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x5d\",\"syscall_name\" : \"NtCreateUserProcess\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"ThreadHandle\":\"0x%x\", \"ProcessDesiredAccess\":\"0x%x\", \"ThreadDesiredAccess\":\"0x%x\", \"ProcessObjectAttributes\":\"0x%x\", \"ThreadObjectAttributes\":\"0x%x\", \"ProcessFlags\":\"0x%x\", \"ThreadFlags\":\"0x%x\", \"ProcessParameters\":\"0x%x\", \"CreateInfo\":\"0x%x\", \"AttributeList\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, ThreadHandle, ProcessDesiredAccess, ThreadDesiredAccess, ProcessObjectAttributes, ThreadObjectAttributes, ProcessFlags, ThreadFlags, ProcessParameters, CreateInfo, AttributeList, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ProcessHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProcessHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProcessHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProcessHandle\" : ");fprintf(outFile, "\"Unable to read ProcessHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ThreadHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ThreadHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ThreadHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ThreadHandle\" : ");fprintf(outFile, "\"Unable to read ThreadHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ProcessObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProcessObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProcessObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProcessObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ProcessObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ThreadObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ThreadObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ThreadObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ThreadObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ThreadObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ProcessParameters;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProcessParameters;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            RTL_USER_PROCESS_PARAMETERS pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProcessParameters\" : ");dump_RTL_USER_PROCESS_PARAMETERS(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProcessParameters\" : ");fprintf(outFile, "\"Unable to read ProcessParameters\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*94 NTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);*/
void on_cb_NtCreateWaitablePort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t ObjectAttributes, uint32_t MaxConnectionInfoLength, uint32_t MaxMessageLength, uint32_t MaxPoolUsage) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x5e\",\"syscall_name\" : \"NtCreateWaitablePort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"MaxConnectionInfoLength\":\"0x%x\", \"MaxMessageLength\":\"0x%x\", \"MaxPoolUsage\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, ObjectAttributes, MaxConnectionInfoLength, MaxMessageLength, MaxPoolUsage, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortHandle\" : ");fprintf(outFile, "\"Unable to read PortHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateWaitablePort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t ObjectAttributes, uint32_t MaxConnectionInfoLength, uint32_t MaxMessageLength, uint32_t MaxPoolUsage) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x5e\",\"syscall_name\" : \"NtCreateWaitablePort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"MaxConnectionInfoLength\":\"0x%x\", \"MaxMessageLength\":\"0x%x\", \"MaxPoolUsage\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, ObjectAttributes, MaxConnectionInfoLength, MaxMessageLength, MaxPoolUsage, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortHandle\" : ");fprintf(outFile, "\"Unable to read PortHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*95 NTSTATUS NtCreateWorkerFactory (PHANDLE WorkerFactoryHandleReturn, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE CompletionPortHandle, HANDLE WorkerProcessHandle, PVOID StartRoutine, PVOID StartParameter, ULONG MaxThreadCount, SIZE_T StackReserve, SIZE_T StackCommit);*/
void on_cb_NtCreateWorkerFactory_enter(CPUState *cpu, target_ulong pc, uint32_t WorkerFactoryHandleReturn, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t CompletionPortHandle, uint32_t WorkerProcessHandle, uint32_t StartRoutine, uint32_t StartParameter, uint32_t MaxThreadCount, uint32_t StackReserve, uint32_t StackCommit) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x5f\",\"syscall_name\" : \"NtCreateWorkerFactory\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"WorkerFactoryHandleReturn\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"CompletionPortHandle\":\"0x%x\", \"WorkerProcessHandle\":\"0x%x\", \"StartRoutine\":\"0x%x\", \"StartParameter\":\"0x%x\", \"MaxThreadCount\":\"0x%x\", \"StackReserve\":\"0x%x\", \"StackCommit\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, WorkerFactoryHandleReturn, DesiredAccess, ObjectAttributes, CompletionPortHandle, WorkerProcessHandle, StartRoutine, StartParameter, MaxThreadCount, StackReserve, StackCommit, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = WorkerFactoryHandleReturn;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = WorkerFactoryHandleReturn;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"WorkerFactoryHandleReturn\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"WorkerFactoryHandleReturn\" : ");fprintf(outFile, "\"Unable to read WorkerFactoryHandleReturn\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtCreateWorkerFactory_return(CPUState *cpu, target_ulong pc, uint32_t WorkerFactoryHandleReturn, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t CompletionPortHandle, uint32_t WorkerProcessHandle, uint32_t StartRoutine, uint32_t StartParameter, uint32_t MaxThreadCount, uint32_t StackReserve, uint32_t StackCommit) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x5f\",\"syscall_name\" : \"NtCreateWorkerFactory\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"WorkerFactoryHandleReturn\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"CompletionPortHandle\":\"0x%x\", \"WorkerProcessHandle\":\"0x%x\", \"StartRoutine\":\"0x%x\", \"StartParameter\":\"0x%x\", \"MaxThreadCount\":\"0x%x\", \"StackReserve\":\"0x%x\", \"StackCommit\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, WorkerFactoryHandleReturn, DesiredAccess, ObjectAttributes, CompletionPortHandle, WorkerProcessHandle, StartRoutine, StartParameter, MaxThreadCount, StackReserve, StackCommit, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = WorkerFactoryHandleReturn;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = WorkerFactoryHandleReturn;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"WorkerFactoryHandleReturn\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"WorkerFactoryHandleReturn\" : ");fprintf(outFile, "\"Unable to read WorkerFactoryHandleReturn\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*96 NTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);*/
void on_cb_NtDebugActiveProcess_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t DebugObjectHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x60\",\"syscall_name\" : \"NtDebugActiveProcess\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"DebugObjectHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, DebugObjectHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDebugActiveProcess_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t DebugObjectHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x60\",\"syscall_name\" : \"NtDebugActiveProcess\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"DebugObjectHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, DebugObjectHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*97 NTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);*/
void on_cb_NtDebugContinue_enter(CPUState *cpu, target_ulong pc, uint32_t DebugObjectHandle, uint32_t ClientId, uint32_t ContinueStatus) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x61\",\"syscall_name\" : \"NtDebugContinue\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DebugObjectHandle\":\"0x%x\", \"ClientId\":\"0x%x\", \"ContinueStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, DebugObjectHandle, ClientId, ContinueStatus, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDebugContinue_return(CPUState *cpu, target_ulong pc, uint32_t DebugObjectHandle, uint32_t ClientId, uint32_t ContinueStatus) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x61\",\"syscall_name\" : \"NtDebugContinue\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DebugObjectHandle\":\"0x%x\", \"ClientId\":\"0x%x\", \"ContinueStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, DebugObjectHandle, ClientId, ContinueStatus, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*98 NTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);*/
void on_cb_NtDelayExecution_enter(CPUState *cpu, target_ulong pc, uint32_t Alertable, uint32_t DelayInterval) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x62\",\"syscall_name\" : \"NtDelayExecution\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Alertable\":\"0x%x\", \"DelayInterval\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Alertable, DelayInterval, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DelayInterval;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DelayInterval;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DelayInterval\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DelayInterval\" : ");fprintf(outFile, "\"Unable to read DelayInterval\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDelayExecution_return(CPUState *cpu, target_ulong pc, uint32_t Alertable, uint32_t DelayInterval) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x62\",\"syscall_name\" : \"NtDelayExecution\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Alertable\":\"0x%x\", \"DelayInterval\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Alertable, DelayInterval, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DelayInterval;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DelayInterval;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DelayInterval\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DelayInterval\" : ");fprintf(outFile, "\"Unable to read DelayInterval\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*99 NTSTATUS NtDeleteAtom (RTL_ATOM Atom);*/
void on_cb_NtDeleteAtom_enter(CPUState *cpu, target_ulong pc, uint32_t Atom) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x63\",\"syscall_name\" : \"NtDeleteAtom\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Atom\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Atom, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDeleteAtom_return(CPUState *cpu, target_ulong pc, uint32_t Atom) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x63\",\"syscall_name\" : \"NtDeleteAtom\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Atom\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Atom, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*100 NTSTATUS NtDeleteBootEntry (ULONG Id);*/
void on_cb_NtDeleteBootEntry_enter(CPUState *cpu, target_ulong pc, uint32_t Id) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x64\",\"syscall_name\" : \"NtDeleteBootEntry\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Id\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Id, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDeleteBootEntry_return(CPUState *cpu, target_ulong pc, uint32_t Id) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x64\",\"syscall_name\" : \"NtDeleteBootEntry\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Id\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Id, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*101 NTSTATUS NtDeleteDriverEntry (ULONG Id);*/
void on_cb_NtDeleteDriverEntry_enter(CPUState *cpu, target_ulong pc, uint32_t Id) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x65\",\"syscall_name\" : \"NtDeleteDriverEntry\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Id\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Id, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDeleteDriverEntry_return(CPUState *cpu, target_ulong pc, uint32_t Id) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x65\",\"syscall_name\" : \"NtDeleteDriverEntry\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Id\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Id, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*102 NTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtDeleteFile_enter(CPUState *cpu, target_ulong pc, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x66\",\"syscall_name\" : \"NtDeleteFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDeleteFile_return(CPUState *cpu, target_ulong pc, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x66\",\"syscall_name\" : \"NtDeleteFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*103 NTSTATUS NtDeleteKey (HANDLE KeyHandle);*/
void on_cb_NtDeleteKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x67\",\"syscall_name\" : \"NtDeleteKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDeleteKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x67\",\"syscall_name\" : \"NtDeleteKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*104 NTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);*/
void on_cb_NtDeleteObjectAuditAlarm_enter(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t HandleId, uint32_t GenerateOnClose) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x68\",\"syscall_name\" : \"NtDeleteObjectAuditAlarm\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"HandleId\":\"0x%x\", \"GenerateOnClose\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, HandleId, GenerateOnClose, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDeleteObjectAuditAlarm_return(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t HandleId, uint32_t GenerateOnClose) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x68\",\"syscall_name\" : \"NtDeleteObjectAuditAlarm\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"HandleId\":\"0x%x\", \"GenerateOnClose\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, HandleId, GenerateOnClose, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*105 NTSTATUS NtDeletePrivateNamespace (HANDLE NamespaceHandle);*/
void on_cb_NtDeletePrivateNamespace_enter(CPUState *cpu, target_ulong pc, uint32_t NamespaceHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x69\",\"syscall_name\" : \"NtDeletePrivateNamespace\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"NamespaceHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, NamespaceHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDeletePrivateNamespace_return(CPUState *cpu, target_ulong pc, uint32_t NamespaceHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x69\",\"syscall_name\" : \"NtDeletePrivateNamespace\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"NamespaceHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, NamespaceHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*106 NTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);*/
void on_cb_NtDeleteValueKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t ValueName) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x6a\",\"syscall_name\" : \"NtDeleteValueKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"ValueName\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, ValueName, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ValueName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ValueName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ValueName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ValueName\" : ");fprintf(outFile, "\"Unable to read ValueName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDeleteValueKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t ValueName) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x6a\",\"syscall_name\" : \"NtDeleteValueKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"ValueName\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, ValueName, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ValueName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ValueName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ValueName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ValueName\" : ");fprintf(outFile, "\"Unable to read ValueName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*107 NTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);*/
void on_cb_NtDeviceIoControlFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t IoControlCode, uint32_t InputBuffer, uint32_t InputBufferLength, uint32_t OutputBuffer, uint32_t OutputBufferLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x6b\",\"syscall_name\" : \"NtDeviceIoControlFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"IoControlCode\":\"0x%x\", \"InputBuffer\":\"0x%x\", \"InputBufferLength\":\"0x%x\", \"OutputBuffer\":\"0x%x\", \"OutputBufferLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, IoControlCode, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDeviceIoControlFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t IoControlCode, uint32_t InputBuffer, uint32_t InputBufferLength, uint32_t OutputBuffer, uint32_t OutputBufferLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x6b\",\"syscall_name\" : \"NtDeviceIoControlFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"IoControlCode\":\"0x%x\", \"InputBuffer\":\"0x%x\", \"InputBufferLength\":\"0x%x\", \"OutputBuffer\":\"0x%x\", \"OutputBufferLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, IoControlCode, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*108 NTSTATUS NtDisableLastKnownGood ();*/
void on_cb_NtDisableLastKnownGood_enter(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x6c\",\"syscall_name\" : \"NtDisableLastKnownGood\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDisableLastKnownGood_return(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x6c\",\"syscall_name\" : \"NtDisableLastKnownGood\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*109 NTSTATUS NtDisplayString (PUNICODE_STRING String);*/
void on_cb_NtDisplayString_enter(CPUState *cpu, target_ulong pc, uint32_t String) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x6d\",\"syscall_name\" : \"NtDisplayString\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"String\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, String, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = String;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = String;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"String\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"String\" : ");fprintf(outFile, "\"Unable to read String\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDisplayString_return(CPUState *cpu, target_ulong pc, uint32_t String) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x6d\",\"syscall_name\" : \"NtDisplayString\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"String\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, String, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = String;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = String;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"String\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"String\" : ");fprintf(outFile, "\"Unable to read String\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*110 NTSTATUS NtDrawText (PUNICODE_STRING Text);*/
void on_cb_NtDrawText_enter(CPUState *cpu, target_ulong pc, uint32_t Text) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x6e\",\"syscall_name\" : \"NtDrawText\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Text\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Text, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Text;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Text;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Text\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Text\" : ");fprintf(outFile, "\"Unable to read Text\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDrawText_return(CPUState *cpu, target_ulong pc, uint32_t Text) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x6e\",\"syscall_name\" : \"NtDrawText\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Text\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Text, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Text;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Text;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Text\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Text\" : ");fprintf(outFile, "\"Unable to read Text\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*111 NTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);*/
void on_cb_NtDuplicateObject_enter(CPUState *cpu, target_ulong pc, uint32_t SourceProcessHandle, uint32_t SourceHandle, uint32_t TargetProcessHandle, uint32_t TargetHandle, uint32_t DesiredAccess, uint32_t HandleAttributes, uint32_t Options) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x6f\",\"syscall_name\" : \"NtDuplicateObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SourceProcessHandle\":\"0x%x\", \"SourceHandle\":\"0x%x\", \"TargetProcessHandle\":\"0x%x\", \"TargetHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"HandleAttributes\":\"0x%x\", \"Options\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SourceProcessHandle, SourceHandle, TargetProcessHandle, TargetHandle, DesiredAccess, HandleAttributes, Options, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetHandle\" : ");fprintf(outFile, "\"Unable to read TargetHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDuplicateObject_return(CPUState *cpu, target_ulong pc, uint32_t SourceProcessHandle, uint32_t SourceHandle, uint32_t TargetProcessHandle, uint32_t TargetHandle, uint32_t DesiredAccess, uint32_t HandleAttributes, uint32_t Options) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x6f\",\"syscall_name\" : \"NtDuplicateObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SourceProcessHandle\":\"0x%x\", \"SourceHandle\":\"0x%x\", \"TargetProcessHandle\":\"0x%x\", \"TargetHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"HandleAttributes\":\"0x%x\", \"Options\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SourceProcessHandle, SourceHandle, TargetProcessHandle, TargetHandle, DesiredAccess, HandleAttributes, Options, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetHandle\" : ");fprintf(outFile, "\"Unable to read TargetHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*112 NTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);*/
void on_cb_NtDuplicateToken_enter(CPUState *cpu, target_ulong pc, uint32_t ExistingTokenHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t EffectiveOnly, uint32_t TokenType, uint32_t NewTokenHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x70\",\"syscall_name\" : \"NtDuplicateToken\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ExistingTokenHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"EffectiveOnly\":\"0x%x\", \"TokenType\":\"0x%x\", \"NewTokenHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ExistingTokenHandle, DesiredAccess, ObjectAttributes, EffectiveOnly, TokenType, NewTokenHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = NewTokenHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NewTokenHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NewTokenHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NewTokenHandle\" : ");fprintf(outFile, "\"Unable to read NewTokenHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtDuplicateToken_return(CPUState *cpu, target_ulong pc, uint32_t ExistingTokenHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t EffectiveOnly, uint32_t TokenType, uint32_t NewTokenHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x70\",\"syscall_name\" : \"NtDuplicateToken\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ExistingTokenHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"EffectiveOnly\":\"0x%x\", \"TokenType\":\"0x%x\", \"NewTokenHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ExistingTokenHandle, DesiredAccess, ObjectAttributes, EffectiveOnly, TokenType, NewTokenHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = NewTokenHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NewTokenHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NewTokenHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NewTokenHandle\" : ");fprintf(outFile, "\"Unable to read NewTokenHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*113 NTSTATUS NtEnableLastKnownGood ();*/
void on_cb_NtEnableLastKnownGood_enter(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x71\",\"syscall_name\" : \"NtEnableLastKnownGood\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtEnableLastKnownGood_return(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x71\",\"syscall_name\" : \"NtEnableLastKnownGood\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*114 NTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);*/
void on_cb_NtEnumerateBootEntries_enter(CPUState *cpu, target_ulong pc, uint32_t Buffer, uint32_t BufferLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x72\",\"syscall_name\" : \"NtEnumerateBootEntries\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Buffer\":\"0x%x\", \"BufferLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Buffer, BufferLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BufferLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BufferLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BufferLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BufferLength\" : ");fprintf(outFile, "\"Unable to read BufferLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtEnumerateBootEntries_return(CPUState *cpu, target_ulong pc, uint32_t Buffer, uint32_t BufferLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x72\",\"syscall_name\" : \"NtEnumerateBootEntries\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Buffer\":\"0x%x\", \"BufferLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Buffer, BufferLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BufferLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BufferLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BufferLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BufferLength\" : ");fprintf(outFile, "\"Unable to read BufferLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*115 NTSTATUS NtEnumerateDriverEntries (PVOID Buffer, PULONG BufferLength);*/
void on_cb_NtEnumerateDriverEntries_enter(CPUState *cpu, target_ulong pc, uint32_t Buffer, uint32_t BufferLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x73\",\"syscall_name\" : \"NtEnumerateDriverEntries\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Buffer\":\"0x%x\", \"BufferLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Buffer, BufferLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BufferLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BufferLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BufferLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BufferLength\" : ");fprintf(outFile, "\"Unable to read BufferLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtEnumerateDriverEntries_return(CPUState *cpu, target_ulong pc, uint32_t Buffer, uint32_t BufferLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x73\",\"syscall_name\" : \"NtEnumerateDriverEntries\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Buffer\":\"0x%x\", \"BufferLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Buffer, BufferLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BufferLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BufferLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BufferLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BufferLength\" : ");fprintf(outFile, "\"Unable to read BufferLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*116 NTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);*/
void on_cb_NtEnumerateKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t Index, uint32_t KeyInformationClass, uint32_t KeyInformation, uint32_t Length, uint32_t ResultLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x74\",\"syscall_name\" : \"NtEnumerateKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"Index\":\"0x%x\", \"KeyInformationClass\":\"0x%x\", \"KeyInformation\":\"0x%x\", \"Length\":\"0x%x\", \"ResultLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, Index, KeyInformationClass, KeyInformation, Length, ResultLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ResultLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ResultLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ResultLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ResultLength\" : ");fprintf(outFile, "\"Unable to read ResultLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtEnumerateKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t Index, uint32_t KeyInformationClass, uint32_t KeyInformation, uint32_t Length, uint32_t ResultLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x74\",\"syscall_name\" : \"NtEnumerateKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"Index\":\"0x%x\", \"KeyInformationClass\":\"0x%x\", \"KeyInformation\":\"0x%x\", \"Length\":\"0x%x\", \"ResultLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, Index, KeyInformationClass, KeyInformation, Length, ResultLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ResultLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ResultLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ResultLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ResultLength\" : ");fprintf(outFile, "\"Unable to read ResultLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*117 NTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);*/
void on_cb_NtEnumerateSystemEnvironmentValuesEx_enter(CPUState *cpu, target_ulong pc, uint32_t InformationClass, uint32_t Buffer, uint32_t BufferLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x75\",\"syscall_name\" : \"NtEnumerateSystemEnvironmentValuesEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"InformationClass\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, InformationClass, Buffer, BufferLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BufferLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BufferLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BufferLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BufferLength\" : ");fprintf(outFile, "\"Unable to read BufferLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtEnumerateSystemEnvironmentValuesEx_return(CPUState *cpu, target_ulong pc, uint32_t InformationClass, uint32_t Buffer, uint32_t BufferLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x75\",\"syscall_name\" : \"NtEnumerateSystemEnvironmentValuesEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"InformationClass\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, InformationClass, Buffer, BufferLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BufferLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BufferLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BufferLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BufferLength\" : ");fprintf(outFile, "\"Unable to read BufferLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*118 NTSTATUS NtEnumerateTransactionObject (HANDLE RootObjectHandle, KTMOBJECT_TYPE QueryType, PKTMOBJECT_CURSOR ObjectCursor, ULONG ObjectCursorLength, PULONG ReturnLength);*/
void on_cb_NtEnumerateTransactionObject_enter(CPUState *cpu, target_ulong pc, uint32_t RootObjectHandle, uint32_t QueryType, uint32_t ObjectCursor, uint32_t ObjectCursorLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x76\",\"syscall_name\" : \"NtEnumerateTransactionObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"RootObjectHandle\":\"0x%x\", \"QueryType\":\"0x%x\", \"ObjectCursor\":\"0x%x\", \"ObjectCursorLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, RootObjectHandle, QueryType, ObjectCursor, ObjectCursorLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtEnumerateTransactionObject_return(CPUState *cpu, target_ulong pc, uint32_t RootObjectHandle, uint32_t QueryType, uint32_t ObjectCursor, uint32_t ObjectCursorLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x76\",\"syscall_name\" : \"NtEnumerateTransactionObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"RootObjectHandle\":\"0x%x\", \"QueryType\":\"0x%x\", \"ObjectCursor\":\"0x%x\", \"ObjectCursorLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, RootObjectHandle, QueryType, ObjectCursor, ObjectCursorLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*119 NTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);*/
void on_cb_NtEnumerateValueKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t Index, uint32_t KeyValueInformationClass, uint32_t KeyValueInformation, uint32_t Length, uint32_t ResultLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x77\",\"syscall_name\" : \"NtEnumerateValueKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"Index\":\"0x%x\", \"KeyValueInformationClass\":\"0x%x\", \"KeyValueInformation\":\"0x%x\", \"Length\":\"0x%x\", \"ResultLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, Index, KeyValueInformationClass, KeyValueInformation, Length, ResultLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ResultLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ResultLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ResultLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ResultLength\" : ");fprintf(outFile, "\"Unable to read ResultLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtEnumerateValueKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t Index, uint32_t KeyValueInformationClass, uint32_t KeyValueInformation, uint32_t Length, uint32_t ResultLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x77\",\"syscall_name\" : \"NtEnumerateValueKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"Index\":\"0x%x\", \"KeyValueInformationClass\":\"0x%x\", \"KeyValueInformation\":\"0x%x\", \"Length\":\"0x%x\", \"ResultLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, Index, KeyValueInformationClass, KeyValueInformation, Length, ResultLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ResultLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ResultLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ResultLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ResultLength\" : ");fprintf(outFile, "\"Unable to read ResultLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*120 NTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);*/
void on_cb_NtExtendSection_enter(CPUState *cpu, target_ulong pc, uint32_t SectionHandle, uint32_t NewSectionSize) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x78\",\"syscall_name\" : \"NtExtendSection\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SectionHandle\":\"0x%x\", \"NewSectionSize\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SectionHandle, NewSectionSize, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NewSectionSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NewSectionSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NewSectionSize\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NewSectionSize\" : ");fprintf(outFile, "\"Unable to read NewSectionSize\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtExtendSection_return(CPUState *cpu, target_ulong pc, uint32_t SectionHandle, uint32_t NewSectionSize) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x78\",\"syscall_name\" : \"NtExtendSection\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SectionHandle\":\"0x%x\", \"NewSectionSize\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SectionHandle, NewSectionSize, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NewSectionSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NewSectionSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NewSectionSize\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NewSectionSize\" : ");fprintf(outFile, "\"Unable to read NewSectionSize\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*121 NTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);*/
void on_cb_NtFilterToken_enter(CPUState *cpu, target_ulong pc, uint32_t ExistingTokenHandle, uint32_t Flags, uint32_t SidsToDisable, uint32_t PrivilegesToDelete, uint32_t RestrictedSids, uint32_t NewTokenHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x79\",\"syscall_name\" : \"NtFilterToken\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ExistingTokenHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"SidsToDisable\":\"0x%x\", \"PrivilegesToDelete\":\"0x%x\", \"RestrictedSids\":\"0x%x\", \"NewTokenHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ExistingTokenHandle, Flags, SidsToDisable, PrivilegesToDelete, RestrictedSids, NewTokenHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NewTokenHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NewTokenHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NewTokenHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NewTokenHandle\" : ");fprintf(outFile, "\"Unable to read NewTokenHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtFilterToken_return(CPUState *cpu, target_ulong pc, uint32_t ExistingTokenHandle, uint32_t Flags, uint32_t SidsToDisable, uint32_t PrivilegesToDelete, uint32_t RestrictedSids, uint32_t NewTokenHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x79\",\"syscall_name\" : \"NtFilterToken\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ExistingTokenHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"SidsToDisable\":\"0x%x\", \"PrivilegesToDelete\":\"0x%x\", \"RestrictedSids\":\"0x%x\", \"NewTokenHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ExistingTokenHandle, Flags, SidsToDisable, PrivilegesToDelete, RestrictedSids, NewTokenHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NewTokenHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NewTokenHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NewTokenHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NewTokenHandle\" : ");fprintf(outFile, "\"Unable to read NewTokenHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*122 NTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);*/
void on_cb_NtFindAtom_enter(CPUState *cpu, target_ulong pc, uint32_t AtomName, uint32_t Length, uint32_t Atom) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x7a\",\"syscall_name\" : \"NtFindAtom\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"AtomName\":\"0x%x\", \"Length\":\"0x%x\", \"Atom\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, AtomName, Length, Atom, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtFindAtom_return(CPUState *cpu, target_ulong pc, uint32_t AtomName, uint32_t Length, uint32_t Atom) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x7a\",\"syscall_name\" : \"NtFindAtom\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"AtomName\":\"0x%x\", \"Length\":\"0x%x\", \"Atom\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, AtomName, Length, Atom, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*123 NTSTATUS NtFlushBuffersFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);*/
void on_cb_NtFlushBuffersFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x7b\",\"syscall_name\" : \"NtFlushBuffersFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtFlushBuffersFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x7b\",\"syscall_name\" : \"NtFlushBuffersFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*124 NTSTATUS NtFlushInstallUILanguage (LANGID InstallUILanguage, ULONG SetComittedFlag);*/
void on_cb_NtFlushInstallUILanguage_enter(CPUState *cpu, target_ulong pc, uint32_t InstallUILanguage, uint32_t SetComittedFlag) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x7c\",\"syscall_name\" : \"NtFlushInstallUILanguage\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"InstallUILanguage\":\"0x%x\", \"SetComittedFlag\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, InstallUILanguage, SetComittedFlag, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtFlushInstallUILanguage_return(CPUState *cpu, target_ulong pc, uint32_t InstallUILanguage, uint32_t SetComittedFlag) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x7c\",\"syscall_name\" : \"NtFlushInstallUILanguage\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"InstallUILanguage\":\"0x%x\", \"SetComittedFlag\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, InstallUILanguage, SetComittedFlag, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*125 NTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);*/
void on_cb_NtFlushInstructionCache_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t Length) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x7d\",\"syscall_name\" : \"NtFlushInstructionCache\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"Length\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, Length, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtFlushInstructionCache_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t Length) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x7d\",\"syscall_name\" : \"NtFlushInstructionCache\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"Length\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, Length, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*126 NTSTATUS NtFlushKey (HANDLE KeyHandle);*/
void on_cb_NtFlushKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x7e\",\"syscall_name\" : \"NtFlushKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtFlushKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x7e\",\"syscall_name\" : \"NtFlushKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*127 VOID NtFlushProcessWriteBuffers ();*/
void on_cb_NtFlushProcessWriteBuffers_enter(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x7f\",\"syscall_name\" : \"NtFlushProcessWriteBuffers\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtFlushProcessWriteBuffers_return(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x7f\",\"syscall_name\" : \"NtFlushProcessWriteBuffers\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*128 NTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);*/
void on_cb_NtFlushVirtualMemory_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t RegionSize, uint32_t IoStatus) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x80\",\"syscall_name\" : \"NtFlushVirtualMemory\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"RegionSize\":\"0x%x\", \"IoStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, RegionSize, IoStatus, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtFlushVirtualMemory_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t RegionSize, uint32_t IoStatus) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x80\",\"syscall_name\" : \"NtFlushVirtualMemory\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"RegionSize\":\"0x%x\", \"IoStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, RegionSize, IoStatus, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*129 NTSTATUS NtFlushWriteBuffer ();*/
void on_cb_NtFlushWriteBuffer_enter(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x81\",\"syscall_name\" : \"NtFlushWriteBuffer\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtFlushWriteBuffer_return(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x81\",\"syscall_name\" : \"NtFlushWriteBuffer\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*130 NTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);*/
void on_cb_NtFreeUserPhysicalPages_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t NumberOfPages, uint32_t UserPfnArray) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x82\",\"syscall_name\" : \"NtFreeUserPhysicalPages\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"NumberOfPages\":\"0x%x\", \"UserPfnArray\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, NumberOfPages, UserPfnArray, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtFreeUserPhysicalPages_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t NumberOfPages, uint32_t UserPfnArray) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x82\",\"syscall_name\" : \"NtFreeUserPhysicalPages\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"NumberOfPages\":\"0x%x\", \"UserPfnArray\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, NumberOfPages, UserPfnArray, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*131 NTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);*/
void on_cb_NtFreeVirtualMemory_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t RegionSize, uint32_t FreeType) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x83\",\"syscall_name\" : \"NtFreeVirtualMemory\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"RegionSize\":\"0x%x\", \"FreeType\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, RegionSize, FreeType, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtFreeVirtualMemory_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t RegionSize, uint32_t FreeType) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x83\",\"syscall_name\" : \"NtFreeVirtualMemory\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"RegionSize\":\"0x%x\", \"FreeType\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, RegionSize, FreeType, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*132 NTSTATUS NtFreezeRegistry (ULONG TimeOutInSeconds);*/
void on_cb_NtFreezeRegistry_enter(CPUState *cpu, target_ulong pc, uint32_t TimeOutInSeconds) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x84\",\"syscall_name\" : \"NtFreezeRegistry\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TimeOutInSeconds\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TimeOutInSeconds, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtFreezeRegistry_return(CPUState *cpu, target_ulong pc, uint32_t TimeOutInSeconds) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x84\",\"syscall_name\" : \"NtFreezeRegistry\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TimeOutInSeconds\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TimeOutInSeconds, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*133 NTSTATUS NtFreezeTransactions (PLARGE_INTEGER FreezeTimeout, PLARGE_INTEGER ThawTimeout);*/
void on_cb_NtFreezeTransactions_enter(CPUState *cpu, target_ulong pc, uint32_t FreezeTimeout, uint32_t ThawTimeout) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x85\",\"syscall_name\" : \"NtFreezeTransactions\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FreezeTimeout\":\"0x%x\", \"ThawTimeout\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FreezeTimeout, ThawTimeout, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = FreezeTimeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = FreezeTimeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"FreezeTimeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"FreezeTimeout\" : ");fprintf(outFile, "\"Unable to read FreezeTimeout\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ThawTimeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ThawTimeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ThawTimeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ThawTimeout\" : ");fprintf(outFile, "\"Unable to read ThawTimeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtFreezeTransactions_return(CPUState *cpu, target_ulong pc, uint32_t FreezeTimeout, uint32_t ThawTimeout) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x85\",\"syscall_name\" : \"NtFreezeTransactions\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FreezeTimeout\":\"0x%x\", \"ThawTimeout\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FreezeTimeout, ThawTimeout, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = FreezeTimeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = FreezeTimeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"FreezeTimeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"FreezeTimeout\" : ");fprintf(outFile, "\"Unable to read FreezeTimeout\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ThawTimeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ThawTimeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ThawTimeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ThawTimeout\" : ");fprintf(outFile, "\"Unable to read ThawTimeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*134 NTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);*/
void on_cb_NtFsControlFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t IoControlCode, uint32_t InputBuffer, uint32_t InputBufferLength, uint32_t OutputBuffer, uint32_t OutputBufferLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x86\",\"syscall_name\" : \"NtFsControlFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"IoControlCode\":\"0x%x\", \"InputBuffer\":\"0x%x\", \"InputBufferLength\":\"0x%x\", \"OutputBuffer\":\"0x%x\", \"OutputBufferLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, IoControlCode, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtFsControlFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t IoControlCode, uint32_t InputBuffer, uint32_t InputBufferLength, uint32_t OutputBuffer, uint32_t OutputBufferLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x86\",\"syscall_name\" : \"NtFsControlFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"IoControlCode\":\"0x%x\", \"InputBuffer\":\"0x%x\", \"InputBufferLength\":\"0x%x\", \"OutputBuffer\":\"0x%x\", \"OutputBufferLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, IoControlCode, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*135 NTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);*/
void on_cb_NtGetContextThread_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t ThreadContext) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x87\",\"syscall_name\" : \"NtGetContextThread\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"ThreadContext\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, ThreadContext, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtGetContextThread_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t ThreadContext) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x87\",\"syscall_name\" : \"NtGetContextThread\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"ThreadContext\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, ThreadContext, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*136 ULONG NtGetCurrentProcessorNumber ();*/
void on_cb_NtGetCurrentProcessorNumber_enter(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x88\",\"syscall_name\" : \"NtGetCurrentProcessorNumber\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtGetCurrentProcessorNumber_return(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x88\",\"syscall_name\" : \"NtGetCurrentProcessorNumber\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*137 NTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);*/
void on_cb_NtGetDevicePowerState_enter(CPUState *cpu, target_ulong pc, uint32_t Device, uint32_t State) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x89\",\"syscall_name\" : \"NtGetDevicePowerState\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Device\":\"0x%x\", \"State\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Device, State, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = State;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = State;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            DEVICE_POWER_STATE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"State\" : ");dump_DEVICE_POWER_STATE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"State\" : ");fprintf(outFile, "\"Unable to read State\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtGetDevicePowerState_return(CPUState *cpu, target_ulong pc, uint32_t Device, uint32_t State) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x89\",\"syscall_name\" : \"NtGetDevicePowerState\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Device\":\"0x%x\", \"State\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Device, State, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = State;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = State;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            DEVICE_POWER_STATE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"State\" : ");dump_DEVICE_POWER_STATE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"State\" : ");fprintf(outFile, "\"Unable to read State\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*138 NTSTATUS NtGetMUIRegistryInfo (ULONG Flags, PULONG DataSize, PVOID Data);*/
void on_cb_NtGetMUIRegistryInfo_enter(CPUState *cpu, target_ulong pc, uint32_t Flags, uint32_t DataSize, uint32_t Data) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x8a\",\"syscall_name\" : \"NtGetMUIRegistryInfo\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Flags\":\"0x%x\", \"DataSize\":\"0x%x\", \"Data\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Flags, DataSize, Data, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DataSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DataSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DataSize\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DataSize\" : ");fprintf(outFile, "\"Unable to read DataSize\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtGetMUIRegistryInfo_return(CPUState *cpu, target_ulong pc, uint32_t Flags, uint32_t DataSize, uint32_t Data) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x8a\",\"syscall_name\" : \"NtGetMUIRegistryInfo\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Flags\":\"0x%x\", \"DataSize\":\"0x%x\", \"Data\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Flags, DataSize, Data, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DataSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DataSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DataSize\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DataSize\" : ");fprintf(outFile, "\"Unable to read DataSize\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*139 NTSTATUS NtGetNextProcess (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewProcessHandle);*/
void on_cb_NtGetNextProcess_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t DesiredAccess, uint32_t HandleAttributes, uint32_t Flags, uint32_t NewProcessHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x8b\",\"syscall_name\" : \"NtGetNextProcess\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"HandleAttributes\":\"0x%x\", \"Flags\":\"0x%x\", \"NewProcessHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, DesiredAccess, HandleAttributes, Flags, NewProcessHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NewProcessHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NewProcessHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NewProcessHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NewProcessHandle\" : ");fprintf(outFile, "\"Unable to read NewProcessHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtGetNextProcess_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t DesiredAccess, uint32_t HandleAttributes, uint32_t Flags, uint32_t NewProcessHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x8b\",\"syscall_name\" : \"NtGetNextProcess\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"HandleAttributes\":\"0x%x\", \"Flags\":\"0x%x\", \"NewProcessHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, DesiredAccess, HandleAttributes, Flags, NewProcessHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NewProcessHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NewProcessHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NewProcessHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NewProcessHandle\" : ");fprintf(outFile, "\"Unable to read NewProcessHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*140 NTSTATUS NtGetNextThread (HANDLE ProcessHandle, HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewThreadHandle);*/
void on_cb_NtGetNextThread_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t ThreadHandle, uint32_t DesiredAccess, uint32_t HandleAttributes, uint32_t Flags, uint32_t NewThreadHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x8c\",\"syscall_name\" : \"NtGetNextThread\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"ThreadHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"HandleAttributes\":\"0x%x\", \"Flags\":\"0x%x\", \"NewThreadHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, ThreadHandle, DesiredAccess, HandleAttributes, Flags, NewThreadHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NewThreadHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NewThreadHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NewThreadHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NewThreadHandle\" : ");fprintf(outFile, "\"Unable to read NewThreadHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtGetNextThread_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t ThreadHandle, uint32_t DesiredAccess, uint32_t HandleAttributes, uint32_t Flags, uint32_t NewThreadHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x8c\",\"syscall_name\" : \"NtGetNextThread\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"ThreadHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"HandleAttributes\":\"0x%x\", \"Flags\":\"0x%x\", \"NewThreadHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, ThreadHandle, DesiredAccess, HandleAttributes, Flags, NewThreadHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NewThreadHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NewThreadHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NewThreadHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NewThreadHandle\" : ");fprintf(outFile, "\"Unable to read NewThreadHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*141 NTSTATUS NtGetNlsSectionPtr (ULONG SectionType, ULONG SectionData, PVOID ContextData, PVOID *SectionPointer, PULONG SectionSize);*/
void on_cb_NtGetNlsSectionPtr_enter(CPUState *cpu, target_ulong pc, uint32_t SectionType, uint32_t SectionData, uint32_t ContextData, uint32_t SectionPointer, uint32_t SectionSize) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x8d\",\"syscall_name\" : \"NtGetNlsSectionPtr\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SectionType\":\"0x%x\", \"SectionData\":\"0x%x\", \"ContextData\":\"0x%x\", \"SectionPointer\":\"0x%x\", \"SectionSize\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SectionType, SectionData, ContextData, SectionPointer, SectionSize, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SectionPointer;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SectionPointer;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SectionPointer\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SectionPointer\" : ");fprintf(outFile, "\"Unable to read SectionPointer\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = SectionSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SectionSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SectionSize\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SectionSize\" : ");fprintf(outFile, "\"Unable to read SectionSize\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtGetNlsSectionPtr_return(CPUState *cpu, target_ulong pc, uint32_t SectionType, uint32_t SectionData, uint32_t ContextData, uint32_t SectionPointer, uint32_t SectionSize) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x8d\",\"syscall_name\" : \"NtGetNlsSectionPtr\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SectionType\":\"0x%x\", \"SectionData\":\"0x%x\", \"ContextData\":\"0x%x\", \"SectionPointer\":\"0x%x\", \"SectionSize\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SectionType, SectionData, ContextData, SectionPointer, SectionSize, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SectionPointer;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SectionPointer;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SectionPointer\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SectionPointer\" : ");fprintf(outFile, "\"Unable to read SectionPointer\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = SectionSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SectionSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SectionSize\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SectionSize\" : ");fprintf(outFile, "\"Unable to read SectionSize\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*142 NTSTATUS NtGetNotificationResourceManager (HANDLE ResourceManagerHandle, PTRANSACTION_NOTIFICATION TransactionNotification, ULONG NotificationLength, PLARGE_INTEGER Timeout, PULONG ReturnLength, ULONG Asynchronous, ULONG_PTR AsynchronousContext);*/
void on_cb_NtGetNotificationResourceManager_enter(CPUState *cpu, target_ulong pc, uint32_t ResourceManagerHandle, uint32_t TransactionNotification, uint32_t NotificationLength, uint32_t Timeout, uint32_t ReturnLength, uint32_t Asynchronous, uint32_t AsynchronousContext) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x8e\",\"syscall_name\" : \"NtGetNotificationResourceManager\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManagerHandle\":\"0x%x\", \"TransactionNotification\":\"0x%x\", \"NotificationLength\":\"0x%x\", \"Timeout\":\"0x%x\", \"ReturnLength\":\"0x%x\", \"Asynchronous\":\"0x%x\", \"AsynchronousContext\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ResourceManagerHandle, TransactionNotification, NotificationLength, Timeout, ReturnLength, Asynchronous, AsynchronousContext, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtGetNotificationResourceManager_return(CPUState *cpu, target_ulong pc, uint32_t ResourceManagerHandle, uint32_t TransactionNotification, uint32_t NotificationLength, uint32_t Timeout, uint32_t ReturnLength, uint32_t Asynchronous, uint32_t AsynchronousContext) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x8e\",\"syscall_name\" : \"NtGetNotificationResourceManager\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManagerHandle\":\"0x%x\", \"TransactionNotification\":\"0x%x\", \"NotificationLength\":\"0x%x\", \"Timeout\":\"0x%x\", \"ReturnLength\":\"0x%x\", \"Asynchronous\":\"0x%x\", \"AsynchronousContext\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ResourceManagerHandle, TransactionNotification, NotificationLength, Timeout, ReturnLength, Asynchronous, AsynchronousContext, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*143 NTSTATUS NtGetPlugPlayEvent (HANDLE EventHandle, PVOID Context, PPLUGPLAY_EVENT_BLOCK EventBlock, ULONG EventBufferSize);*/
void on_cb_NtGetPlugPlayEvent_enter(CPUState *cpu, target_ulong pc, uint32_t EventHandle, uint32_t Context, uint32_t EventBlock, uint32_t EventBufferSize) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x8f\",\"syscall_name\" : \"NtGetPlugPlayEvent\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\", \"Context\":\"0x%x\", \"EventBlock\":\"0x%x\", \"EventBufferSize\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventHandle, Context, EventBlock, EventBufferSize, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtGetPlugPlayEvent_return(CPUState *cpu, target_ulong pc, uint32_t EventHandle, uint32_t Context, uint32_t EventBlock, uint32_t EventBufferSize) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x8f\",\"syscall_name\" : \"NtGetPlugPlayEvent\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\", \"Context\":\"0x%x\", \"EventBlock\":\"0x%x\", \"EventBufferSize\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventHandle, Context, EventBlock, EventBufferSize, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*144 NTSTATUS NtGetWriteWatch (HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID *UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity);*/
void on_cb_NtGetWriteWatch_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t Flags, uint32_t BaseAddress, uint32_t RegionSize, uint32_t UserAddressArray, uint32_t EntriesInUserAddressArray, uint32_t Granularity) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x90\",\"syscall_name\" : \"NtGetWriteWatch\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"RegionSize\":\"0x%x\", \"UserAddressArray\":\"0x%x\", \"EntriesInUserAddressArray\":\"0x%x\", \"Granularity\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, Flags, BaseAddress, RegionSize, UserAddressArray, EntriesInUserAddressArray, Granularity, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = UserAddressArray;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = UserAddressArray;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"UserAddressArray\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"UserAddressArray\" : ");fprintf(outFile, "\"Unable to read UserAddressArray\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Granularity;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Granularity;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Granularity\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Granularity\" : ");fprintf(outFile, "\"Unable to read Granularity\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtGetWriteWatch_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t Flags, uint32_t BaseAddress, uint32_t RegionSize, uint32_t UserAddressArray, uint32_t EntriesInUserAddressArray, uint32_t Granularity) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x90\",\"syscall_name\" : \"NtGetWriteWatch\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"RegionSize\":\"0x%x\", \"UserAddressArray\":\"0x%x\", \"EntriesInUserAddressArray\":\"0x%x\", \"Granularity\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, Flags, BaseAddress, RegionSize, UserAddressArray, EntriesInUserAddressArray, Granularity, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = UserAddressArray;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = UserAddressArray;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"UserAddressArray\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"UserAddressArray\" : ");fprintf(outFile, "\"Unable to read UserAddressArray\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Granularity;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Granularity;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Granularity\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Granularity\" : ");fprintf(outFile, "\"Unable to read Granularity\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*145 NTSTATUS NtImpersonateAnonymousToken (HANDLE ThreadHandle);*/
void on_cb_NtImpersonateAnonymousToken_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x91\",\"syscall_name\" : \"NtImpersonateAnonymousToken\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtImpersonateAnonymousToken_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x91\",\"syscall_name\" : \"NtImpersonateAnonymousToken\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*146 NTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);*/
void on_cb_NtImpersonateClientOfPort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Message) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x92\",\"syscall_name\" : \"NtImpersonateClientOfPort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Message\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Message, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtImpersonateClientOfPort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Message) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x92\",\"syscall_name\" : \"NtImpersonateClientOfPort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Message\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Message, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*147 NTSTATUS NtImpersonateThread (HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos);*/
void on_cb_NtImpersonateThread_enter(CPUState *cpu, target_ulong pc, uint32_t ServerThreadHandle, uint32_t ClientThreadHandle, uint32_t SecurityQos) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x93\",\"syscall_name\" : \"NtImpersonateThread\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ServerThreadHandle\":\"0x%x\", \"ClientThreadHandle\":\"0x%x\", \"SecurityQos\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ServerThreadHandle, ClientThreadHandle, SecurityQos, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtImpersonateThread_return(CPUState *cpu, target_ulong pc, uint32_t ServerThreadHandle, uint32_t ClientThreadHandle, uint32_t SecurityQos) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x93\",\"syscall_name\" : \"NtImpersonateThread\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ServerThreadHandle\":\"0x%x\", \"ClientThreadHandle\":\"0x%x\", \"SecurityQos\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ServerThreadHandle, ClientThreadHandle, SecurityQos, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*148 NTSTATUS NtInitializeNlsFiles (PVOID *BaseAddress, PLCID DefaultLocaleId, PLARGE_INTEGER DefaultCasingTableSize);*/
void on_cb_NtInitializeNlsFiles_enter(CPUState *cpu, target_ulong pc, uint32_t BaseAddress, uint32_t DefaultLocaleId, uint32_t DefaultCasingTableSize) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x94\",\"syscall_name\" : \"NtInitializeNlsFiles\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"BaseAddress\":\"0x%x\", \"DefaultLocaleId\":\"0x%x\", \"DefaultCasingTableSize\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, BaseAddress, DefaultLocaleId, DefaultCasingTableSize, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = DefaultCasingTableSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DefaultCasingTableSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DefaultCasingTableSize\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DefaultCasingTableSize\" : ");fprintf(outFile, "\"Unable to read DefaultCasingTableSize\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtInitializeNlsFiles_return(CPUState *cpu, target_ulong pc, uint32_t BaseAddress, uint32_t DefaultLocaleId, uint32_t DefaultCasingTableSize) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x94\",\"syscall_name\" : \"NtInitializeNlsFiles\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"BaseAddress\":\"0x%x\", \"DefaultLocaleId\":\"0x%x\", \"DefaultCasingTableSize\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, BaseAddress, DefaultLocaleId, DefaultCasingTableSize, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = DefaultCasingTableSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DefaultCasingTableSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DefaultCasingTableSize\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DefaultCasingTableSize\" : ");fprintf(outFile, "\"Unable to read DefaultCasingTableSize\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*149 NTSTATUS NtInitializeRegistry (ULONG BootCondition);*/
void on_cb_NtInitializeRegistry_enter(CPUState *cpu, target_ulong pc, uint32_t BootCondition) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x95\",\"syscall_name\" : \"NtInitializeRegistry\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"BootCondition\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, BootCondition, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtInitializeRegistry_return(CPUState *cpu, target_ulong pc, uint32_t BootCondition) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x95\",\"syscall_name\" : \"NtInitializeRegistry\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"BootCondition\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, BootCondition, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*150 NTSTATUS NtInitiatePowerAction (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);*/
void on_cb_NtInitiatePowerAction_enter(CPUState *cpu, target_ulong pc, uint32_t SystemAction, uint32_t MinSystemState, uint32_t Flags, uint32_t Asynchronous) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x96\",\"syscall_name\" : \"NtInitiatePowerAction\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SystemAction\":\"0x%x\", \"MinSystemState\":\"0x%x\", \"Flags\":\"0x%x\", \"Asynchronous\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SystemAction, MinSystemState, Flags, Asynchronous, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtInitiatePowerAction_return(CPUState *cpu, target_ulong pc, uint32_t SystemAction, uint32_t MinSystemState, uint32_t Flags, uint32_t Asynchronous) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x96\",\"syscall_name\" : \"NtInitiatePowerAction\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SystemAction\":\"0x%x\", \"MinSystemState\":\"0x%x\", \"Flags\":\"0x%x\", \"Asynchronous\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SystemAction, MinSystemState, Flags, Asynchronous, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*151 NTSTATUS NtIsProcessInJob (HANDLE ProcessHandle, HANDLE JobHandle);*/
void on_cb_NtIsProcessInJob_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t JobHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x97\",\"syscall_name\" : \"NtIsProcessInJob\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"JobHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, JobHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtIsProcessInJob_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t JobHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x97\",\"syscall_name\" : \"NtIsProcessInJob\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"JobHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, JobHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*152 BOOLEAN NtIsSystemResumeAutomatic ();*/
void on_cb_NtIsSystemResumeAutomatic_enter(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x98\",\"syscall_name\" : \"NtIsSystemResumeAutomatic\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtIsSystemResumeAutomatic_return(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x98\",\"syscall_name\" : \"NtIsSystemResumeAutomatic\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*153 NTSTATUS NtIsUILanguageComitted ();*/
void on_cb_NtIsUILanguageComitted_enter(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x99\",\"syscall_name\" : \"NtIsUILanguageComitted\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtIsUILanguageComitted_return(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x99\",\"syscall_name\" : \"NtIsUILanguageComitted\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*154 NTSTATUS NtListenPort (HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest);*/
void on_cb_NtListenPort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t ConnectionRequest) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x9a\",\"syscall_name\" : \"NtListenPort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"ConnectionRequest\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, ConnectionRequest, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtListenPort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t ConnectionRequest) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x9a\",\"syscall_name\" : \"NtListenPort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"ConnectionRequest\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, ConnectionRequest, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*155 NTSTATUS NtLoadDriver (PUNICODE_STRING DriverServiceName);*/
void on_cb_NtLoadDriver_enter(CPUState *cpu, target_ulong pc, uint32_t DriverServiceName) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x9b\",\"syscall_name\" : \"NtLoadDriver\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DriverServiceName\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, DriverServiceName, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DriverServiceName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DriverServiceName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DriverServiceName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DriverServiceName\" : ");fprintf(outFile, "\"Unable to read DriverServiceName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtLoadDriver_return(CPUState *cpu, target_ulong pc, uint32_t DriverServiceName) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x9b\",\"syscall_name\" : \"NtLoadDriver\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DriverServiceName\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, DriverServiceName, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DriverServiceName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DriverServiceName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DriverServiceName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DriverServiceName\" : ");fprintf(outFile, "\"Unable to read DriverServiceName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*156 NTSTATUS NtLoadKey (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);*/
void on_cb_NtLoadKey_enter(CPUState *cpu, target_ulong pc, uint32_t TargetKey, uint32_t SourceFile) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x9c\",\"syscall_name\" : \"NtLoadKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetKey\":\"0x%x\", \"SourceFile\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TargetKey, SourceFile, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetKey;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetKey;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetKey\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetKey\" : ");fprintf(outFile, "\"Unable to read TargetKey\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = SourceFile;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SourceFile;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SourceFile\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SourceFile\" : ");fprintf(outFile, "\"Unable to read SourceFile\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtLoadKey_return(CPUState *cpu, target_ulong pc, uint32_t TargetKey, uint32_t SourceFile) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x9c\",\"syscall_name\" : \"NtLoadKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetKey\":\"0x%x\", \"SourceFile\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TargetKey, SourceFile, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetKey;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetKey;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetKey\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetKey\" : ");fprintf(outFile, "\"Unable to read TargetKey\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = SourceFile;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SourceFile;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SourceFile\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SourceFile\" : ");fprintf(outFile, "\"Unable to read SourceFile\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*157 NTSTATUS NtLoadKey2 (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags);*/
void on_cb_NtLoadKey2_enter(CPUState *cpu, target_ulong pc, uint32_t TargetKey, uint32_t SourceFile, uint32_t Flags) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x9d\",\"syscall_name\" : \"NtLoadKey2\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetKey\":\"0x%x\", \"SourceFile\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TargetKey, SourceFile, Flags, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetKey;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetKey;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetKey\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetKey\" : ");fprintf(outFile, "\"Unable to read TargetKey\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = SourceFile;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SourceFile;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SourceFile\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SourceFile\" : ");fprintf(outFile, "\"Unable to read SourceFile\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtLoadKey2_return(CPUState *cpu, target_ulong pc, uint32_t TargetKey, uint32_t SourceFile, uint32_t Flags) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x9d\",\"syscall_name\" : \"NtLoadKey2\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetKey\":\"0x%x\", \"SourceFile\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TargetKey, SourceFile, Flags, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetKey;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetKey;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetKey\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetKey\" : ");fprintf(outFile, "\"Unable to read TargetKey\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = SourceFile;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SourceFile;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SourceFile\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SourceFile\" : ");fprintf(outFile, "\"Unable to read SourceFile\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*158 NTSTATUS NtLoadKeyEx (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags, HANDLE TrustClassKey );*/
void on_cb_NtLoadKeyEx_enter(CPUState *cpu, target_ulong pc, uint32_t TargetKey, uint32_t SourceFile, uint32_t Flags, uint32_t TrustClassKey) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x9e\",\"syscall_name\" : \"NtLoadKeyEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetKey\":\"0x%x\", \"SourceFile\":\"0x%x\", \"Flags\":\"0x%x\", \"TrustClassKey\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TargetKey, SourceFile, Flags, TrustClassKey, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetKey;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetKey;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetKey\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetKey\" : ");fprintf(outFile, "\"Unable to read TargetKey\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = SourceFile;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SourceFile;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SourceFile\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SourceFile\" : ");fprintf(outFile, "\"Unable to read SourceFile\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtLoadKeyEx_return(CPUState *cpu, target_ulong pc, uint32_t TargetKey, uint32_t SourceFile, uint32_t Flags, uint32_t TrustClassKey) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x9e\",\"syscall_name\" : \"NtLoadKeyEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetKey\":\"0x%x\", \"SourceFile\":\"0x%x\", \"Flags\":\"0x%x\", \"TrustClassKey\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TargetKey, SourceFile, Flags, TrustClassKey, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetKey;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetKey;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetKey\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetKey\" : ");fprintf(outFile, "\"Unable to read TargetKey\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = SourceFile;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SourceFile;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SourceFile\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SourceFile\" : ");fprintf(outFile, "\"Unable to read SourceFile\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*159 NTSTATUS NtLockFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);*/
void on_cb_NtLockFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t ByteOffset, uint32_t Length, uint32_t Key, uint32_t FailImmediately, uint32_t ExclusiveLock) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x9f\",\"syscall_name\" : \"NtLockFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"ByteOffset\":\"0x%x\", \"Length\":\"0x%x\", \"Key\":\"0x%x\", \"FailImmediately\":\"0x%x\", \"ExclusiveLock\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, ByteOffset, Length, Key, FailImmediately, ExclusiveLock, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ByteOffset;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ByteOffset;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ByteOffset\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ByteOffset\" : ");fprintf(outFile, "\"Unable to read ByteOffset\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Length;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Length;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Length\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Length\" : ");fprintf(outFile, "\"Unable to read Length\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtLockFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t ByteOffset, uint32_t Length, uint32_t Key, uint32_t FailImmediately, uint32_t ExclusiveLock) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x9f\",\"syscall_name\" : \"NtLockFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"ByteOffset\":\"0x%x\", \"Length\":\"0x%x\", \"Key\":\"0x%x\", \"FailImmediately\":\"0x%x\", \"ExclusiveLock\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, ByteOffset, Length, Key, FailImmediately, ExclusiveLock, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ByteOffset;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ByteOffset;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ByteOffset\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ByteOffset\" : ");fprintf(outFile, "\"Unable to read ByteOffset\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Length;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Length;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Length\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Length\" : ");fprintf(outFile, "\"Unable to read Length\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*160 NTSTATUS NtLockProductActivationKeys (ULONG *pPrivateVer, ULONG *pSafeMode);*/
void on_cb_NtLockProductActivationKeys_enter(CPUState *cpu, target_ulong pc, uint32_t pPrivateVer, uint32_t pSafeMode) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xa0\",\"syscall_name\" : \"NtLockProductActivationKeys\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"pPrivateVer\":\"0x%x\", \"pSafeMode\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, pPrivateVer, pSafeMode, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = pPrivateVer;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = pPrivateVer;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"pPrivateVer\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"pPrivateVer\" : ");fprintf(outFile, "\"Unable to read pPrivateVer\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = pSafeMode;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = pSafeMode;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"pSafeMode\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"pSafeMode\" : ");fprintf(outFile, "\"Unable to read pSafeMode\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtLockProductActivationKeys_return(CPUState *cpu, target_ulong pc, uint32_t pPrivateVer, uint32_t pSafeMode) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xa0\",\"syscall_name\" : \"NtLockProductActivationKeys\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"pPrivateVer\":\"0x%x\", \"pSafeMode\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, pPrivateVer, pSafeMode, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = pPrivateVer;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = pPrivateVer;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"pPrivateVer\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"pPrivateVer\" : ");fprintf(outFile, "\"Unable to read pPrivateVer\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = pSafeMode;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = pSafeMode;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"pSafeMode\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"pSafeMode\" : ");fprintf(outFile, "\"Unable to read pSafeMode\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*161 NTSTATUS NtLockRegistryKey (HANDLE KeyHandle);*/
void on_cb_NtLockRegistryKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xa1\",\"syscall_name\" : \"NtLockRegistryKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtLockRegistryKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xa1\",\"syscall_name\" : \"NtLockRegistryKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*162 NTSTATUS NtLockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);*/
void on_cb_NtLockVirtualMemory_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t RegionSize, uint32_t MapType) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xa2\",\"syscall_name\" : \"NtLockVirtualMemory\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"RegionSize\":\"0x%x\", \"MapType\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, RegionSize, MapType, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtLockVirtualMemory_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t RegionSize, uint32_t MapType) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xa2\",\"syscall_name\" : \"NtLockVirtualMemory\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"RegionSize\":\"0x%x\", \"MapType\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, RegionSize, MapType, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*163 NTSTATUS NtMakePermanentObject (HANDLE Handle);*/
void on_cb_NtMakePermanentObject_enter(CPUState *cpu, target_ulong pc, uint32_t Handle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xa3\",\"syscall_name\" : \"NtMakePermanentObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Handle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Handle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtMakePermanentObject_return(CPUState *cpu, target_ulong pc, uint32_t Handle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xa3\",\"syscall_name\" : \"NtMakePermanentObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Handle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Handle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*164 NTSTATUS NtMakeTemporaryObject (HANDLE Handle);*/
void on_cb_NtMakeTemporaryObject_enter(CPUState *cpu, target_ulong pc, uint32_t Handle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xa4\",\"syscall_name\" : \"NtMakeTemporaryObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Handle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Handle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtMakeTemporaryObject_return(CPUState *cpu, target_ulong pc, uint32_t Handle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xa4\",\"syscall_name\" : \"NtMakeTemporaryObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Handle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Handle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*165 NTSTATUS NtMapCMFModule (ULONG What, ULONG Index, PULONG CacheIndexOut, PULONG CacheFlagsOut, PULONG ViewSizeOut, PVOID *BaseAddress);*/
void on_cb_NtMapCMFModule_enter(CPUState *cpu, target_ulong pc, uint32_t What, uint32_t Index, uint32_t CacheIndexOut, uint32_t CacheFlagsOut, uint32_t ViewSizeOut, uint32_t BaseAddress) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xa5\",\"syscall_name\" : \"NtMapCMFModule\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"What\":\"0x%x\", \"Index\":\"0x%x\", \"CacheIndexOut\":\"0x%x\", \"CacheFlagsOut\":\"0x%x\", \"ViewSizeOut\":\"0x%x\", \"BaseAddress\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, What, Index, CacheIndexOut, CacheFlagsOut, ViewSizeOut, BaseAddress, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = CacheIndexOut;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = CacheIndexOut;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"CacheIndexOut\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"CacheIndexOut\" : ");fprintf(outFile, "\"Unable to read CacheIndexOut\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = CacheFlagsOut;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = CacheFlagsOut;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"CacheFlagsOut\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"CacheFlagsOut\" : ");fprintf(outFile, "\"Unable to read CacheFlagsOut\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ViewSizeOut;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ViewSizeOut;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ViewSizeOut\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ViewSizeOut\" : ");fprintf(outFile, "\"Unable to read ViewSizeOut\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtMapCMFModule_return(CPUState *cpu, target_ulong pc, uint32_t What, uint32_t Index, uint32_t CacheIndexOut, uint32_t CacheFlagsOut, uint32_t ViewSizeOut, uint32_t BaseAddress) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xa5\",\"syscall_name\" : \"NtMapCMFModule\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"What\":\"0x%x\", \"Index\":\"0x%x\", \"CacheIndexOut\":\"0x%x\", \"CacheFlagsOut\":\"0x%x\", \"ViewSizeOut\":\"0x%x\", \"BaseAddress\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, What, Index, CacheIndexOut, CacheFlagsOut, ViewSizeOut, BaseAddress, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = CacheIndexOut;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = CacheIndexOut;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"CacheIndexOut\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"CacheIndexOut\" : ");fprintf(outFile, "\"Unable to read CacheIndexOut\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = CacheFlagsOut;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = CacheFlagsOut;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"CacheFlagsOut\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"CacheFlagsOut\" : ");fprintf(outFile, "\"Unable to read CacheFlagsOut\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ViewSizeOut;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ViewSizeOut;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ViewSizeOut\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ViewSizeOut\" : ");fprintf(outFile, "\"Unable to read ViewSizeOut\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*166 NTSTATUS NtMapUserPhysicalPages (PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);*/
void on_cb_NtMapUserPhysicalPages_enter(CPUState *cpu, target_ulong pc, uint32_t VirtualAddress, uint32_t NumberOfPages, uint32_t UserPfnArray) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xa6\",\"syscall_name\" : \"NtMapUserPhysicalPages\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"VirtualAddress\":\"0x%x\", \"NumberOfPages\":\"0x%x\", \"UserPfnArray\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, VirtualAddress, NumberOfPages, UserPfnArray, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtMapUserPhysicalPages_return(CPUState *cpu, target_ulong pc, uint32_t VirtualAddress, uint32_t NumberOfPages, uint32_t UserPfnArray) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xa6\",\"syscall_name\" : \"NtMapUserPhysicalPages\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"VirtualAddress\":\"0x%x\", \"NumberOfPages\":\"0x%x\", \"UserPfnArray\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, VirtualAddress, NumberOfPages, UserPfnArray, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*167 NTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);*/
void on_cb_NtMapUserPhysicalPagesScatter_enter(CPUState *cpu, target_ulong pc, uint32_t VirtualAddresses, uint32_t NumberOfPages, uint32_t UserPfnArray) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xa7\",\"syscall_name\" : \"NtMapUserPhysicalPagesScatter\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"VirtualAddresses\":\"0x%x\", \"NumberOfPages\":\"0x%x\", \"UserPfnArray\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, VirtualAddresses, NumberOfPages, UserPfnArray, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = VirtualAddresses;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = VirtualAddresses;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"VirtualAddresses\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"VirtualAddresses\" : ");fprintf(outFile, "\"Unable to read VirtualAddresses\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtMapUserPhysicalPagesScatter_return(CPUState *cpu, target_ulong pc, uint32_t VirtualAddresses, uint32_t NumberOfPages, uint32_t UserPfnArray) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xa7\",\"syscall_name\" : \"NtMapUserPhysicalPagesScatter\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"VirtualAddresses\":\"0x%x\", \"NumberOfPages\":\"0x%x\", \"UserPfnArray\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, VirtualAddresses, NumberOfPages, UserPfnArray, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = VirtualAddresses;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = VirtualAddresses;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"VirtualAddresses\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"VirtualAddresses\" : ");fprintf(outFile, "\"Unable to read VirtualAddresses\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*168 NTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);*/
void on_cb_NtMapViewOfSection_enter(CPUState *cpu, target_ulong pc, uint32_t SectionHandle, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t ZeroBits, uint32_t CommitSize, uint32_t SectionOffset, uint32_t ViewSize, uint32_t InheritDisposition, uint32_t AllocationType, uint32_t Win32Protect) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xa8\",\"syscall_name\" : \"NtMapViewOfSection\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SectionHandle\":\"0x%x\", \"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"ZeroBits\":\"0x%x\", \"CommitSize\":\"0x%x\", \"SectionOffset\":\"0x%x\", \"ViewSize\":\"0x%x\", \"InheritDisposition\":\"0x%x\", \"AllocationType\":\"0x%x\", \"Win32Protect\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SectionHandle, ProcessHandle, BaseAddress, ZeroBits, CommitSize, SectionOffset, ViewSize, InheritDisposition, AllocationType, Win32Protect, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = SectionOffset;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SectionOffset;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SectionOffset\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SectionOffset\" : ");fprintf(outFile, "\"Unable to read SectionOffset\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtMapViewOfSection_return(CPUState *cpu, target_ulong pc, uint32_t SectionHandle, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t ZeroBits, uint32_t CommitSize, uint32_t SectionOffset, uint32_t ViewSize, uint32_t InheritDisposition, uint32_t AllocationType, uint32_t Win32Protect) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xa8\",\"syscall_name\" : \"NtMapViewOfSection\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SectionHandle\":\"0x%x\", \"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"ZeroBits\":\"0x%x\", \"CommitSize\":\"0x%x\", \"SectionOffset\":\"0x%x\", \"ViewSize\":\"0x%x\", \"InheritDisposition\":\"0x%x\", \"AllocationType\":\"0x%x\", \"Win32Protect\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SectionHandle, ProcessHandle, BaseAddress, ZeroBits, CommitSize, SectionOffset, ViewSize, InheritDisposition, AllocationType, Win32Protect, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = SectionOffset;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SectionOffset;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SectionOffset\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SectionOffset\" : ");fprintf(outFile, "\"Unable to read SectionOffset\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*169 NTSTATUS NtModifyBootEntry (PBOOT_ENTRY BootEntry);*/
void on_cb_NtModifyBootEntry_enter(CPUState *cpu, target_ulong pc, uint32_t BootEntry) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xa9\",\"syscall_name\" : \"NtModifyBootEntry\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"BootEntry\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, BootEntry, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtModifyBootEntry_return(CPUState *cpu, target_ulong pc, uint32_t BootEntry) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xa9\",\"syscall_name\" : \"NtModifyBootEntry\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"BootEntry\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, BootEntry, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*170 NTSTATUS NtModifyDriverEntry (PEFI_DRIVER_ENTRY DriverEntry);*/
void on_cb_NtModifyDriverEntry_enter(CPUState *cpu, target_ulong pc, uint32_t DriverEntry) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xaa\",\"syscall_name\" : \"NtModifyDriverEntry\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DriverEntry\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, DriverEntry, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtModifyDriverEntry_return(CPUState *cpu, target_ulong pc, uint32_t DriverEntry) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xaa\",\"syscall_name\" : \"NtModifyDriverEntry\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DriverEntry\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, DriverEntry, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*171 NTSTATUS NtNotifyChangeDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree);*/
void on_cb_NtNotifyChangeDirectoryFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t Buffer, uint32_t Length, uint32_t CompletionFilter, uint32_t WatchTree) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xab\",\"syscall_name\" : \"NtNotifyChangeDirectoryFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\", \"CompletionFilter\":\"0x%x\", \"WatchTree\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, CompletionFilter, WatchTree, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtNotifyChangeDirectoryFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t Buffer, uint32_t Length, uint32_t CompletionFilter, uint32_t WatchTree) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xab\",\"syscall_name\" : \"NtNotifyChangeDirectoryFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\", \"CompletionFilter\":\"0x%x\", \"WatchTree\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, CompletionFilter, WatchTree, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*172 NTSTATUS NtNotifyChangeKey (HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);*/
void on_cb_NtNotifyChangeKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t CompletionFilter, uint32_t WatchTree, uint32_t Buffer, uint32_t BufferSize, uint32_t Asynchronous) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xac\",\"syscall_name\" : \"NtNotifyChangeKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"CompletionFilter\":\"0x%x\", \"WatchTree\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\", \"Asynchronous\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, CompletionFilter, WatchTree, Buffer, BufferSize, Asynchronous, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtNotifyChangeKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t CompletionFilter, uint32_t WatchTree, uint32_t Buffer, uint32_t BufferSize, uint32_t Asynchronous) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xac\",\"syscall_name\" : \"NtNotifyChangeKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"CompletionFilter\":\"0x%x\", \"WatchTree\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\", \"Asynchronous\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, CompletionFilter, WatchTree, Buffer, BufferSize, Asynchronous, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*173 NTSTATUS NtNotifyChangeMultipleKeys (HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES SlaveObjects[], HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);*/
void on_cb_NtNotifyChangeMultipleKeys_enter(CPUState *cpu, target_ulong pc, uint32_t MasterKeyHandle, uint32_t Count, uint32_t SlaveObjects, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t CompletionFilter, uint32_t WatchTree, uint32_t Buffer, uint32_t BufferSize, uint32_t Asynchronous) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xad\",\"syscall_name\" : \"NtNotifyChangeMultipleKeys\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"MasterKeyHandle\":\"0x%x\", \"Count\":\"0x%x\", \"SlaveObjects\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"CompletionFilter\":\"0x%x\", \"WatchTree\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\", \"Asynchronous\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, MasterKeyHandle, Count, SlaveObjects, Event, ApcRoutine, ApcContext, IoStatusBlock, CompletionFilter, WatchTree, Buffer, BufferSize, Asynchronous, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtNotifyChangeMultipleKeys_return(CPUState *cpu, target_ulong pc, uint32_t MasterKeyHandle, uint32_t Count, uint32_t SlaveObjects, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t CompletionFilter, uint32_t WatchTree, uint32_t Buffer, uint32_t BufferSize, uint32_t Asynchronous) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xad\",\"syscall_name\" : \"NtNotifyChangeMultipleKeys\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"MasterKeyHandle\":\"0x%x\", \"Count\":\"0x%x\", \"SlaveObjects\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"CompletionFilter\":\"0x%x\", \"WatchTree\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\", \"Asynchronous\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, MasterKeyHandle, Count, SlaveObjects, Event, ApcRoutine, ApcContext, IoStatusBlock, CompletionFilter, WatchTree, Buffer, BufferSize, Asynchronous, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*174 NTSTATUS NtNotifyChangeSession (HANDLE Session, ULONG IoStateSequence, PVOID Reserved, ULONG Action, IO_SESSION_STATE IoState, IO_SESSION_STATE IoState2, PVOID Buffer, ULONG BufferSize);*/
void on_cb_NtNotifyChangeSession_enter(CPUState *cpu, target_ulong pc, uint32_t Session, uint32_t IoStateSequence, uint32_t Reserved, uint32_t Action, uint32_t IoState, uint32_t IoState2, uint32_t Buffer, uint32_t BufferSize) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xae\",\"syscall_name\" : \"NtNotifyChangeSession\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Session\":\"0x%x\", \"IoStateSequence\":\"0x%x\", \"Reserved\":\"0x%x\", \"Action\":\"0x%x\", \"IoState\":\"0x%x\", \"IoState2\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Session, IoStateSequence, Reserved, Action, IoState, IoState2, Buffer, BufferSize, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtNotifyChangeSession_return(CPUState *cpu, target_ulong pc, uint32_t Session, uint32_t IoStateSequence, uint32_t Reserved, uint32_t Action, uint32_t IoState, uint32_t IoState2, uint32_t Buffer, uint32_t BufferSize) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xae\",\"syscall_name\" : \"NtNotifyChangeSession\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Session\":\"0x%x\", \"IoStateSequence\":\"0x%x\", \"Reserved\":\"0x%x\", \"Action\":\"0x%x\", \"IoState\":\"0x%x\", \"IoState2\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Session, IoStateSequence, Reserved, Action, IoState, IoState2, Buffer, BufferSize, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*175 NTSTATUS NtOpenDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtOpenDirectoryObject_enter(CPUState *cpu, target_ulong pc, uint32_t DirectoryHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xaf\",\"syscall_name\" : \"NtOpenDirectoryObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DirectoryHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, DirectoryHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DirectoryHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DirectoryHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DirectoryHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DirectoryHandle\" : ");fprintf(outFile, "\"Unable to read DirectoryHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenDirectoryObject_return(CPUState *cpu, target_ulong pc, uint32_t DirectoryHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xaf\",\"syscall_name\" : \"NtOpenDirectoryObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DirectoryHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, DirectoryHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DirectoryHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DirectoryHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DirectoryHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DirectoryHandle\" : ");fprintf(outFile, "\"Unable to read DirectoryHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*176 NTSTATUS NtOpenEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, LPGUID EnlistmentGuid, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtOpenEnlistment_enter(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t DesiredAccess, uint32_t ResourceManagerHandle, uint32_t EnlistmentGuid, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xb0\",\"syscall_name\" : \"NtOpenEnlistment\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ResourceManagerHandle\":\"0x%x\", \"EnlistmentGuid\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, DesiredAccess, ResourceManagerHandle, EnlistmentGuid, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = EnlistmentHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = EnlistmentHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"EnlistmentHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"EnlistmentHandle\" : ");fprintf(outFile, "\"Unable to read EnlistmentHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenEnlistment_return(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t DesiredAccess, uint32_t ResourceManagerHandle, uint32_t EnlistmentGuid, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xb0\",\"syscall_name\" : \"NtOpenEnlistment\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ResourceManagerHandle\":\"0x%x\", \"EnlistmentGuid\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, DesiredAccess, ResourceManagerHandle, EnlistmentGuid, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = EnlistmentHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = EnlistmentHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"EnlistmentHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"EnlistmentHandle\" : ");fprintf(outFile, "\"Unable to read EnlistmentHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*177 NTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtOpenEvent_enter(CPUState *cpu, target_ulong pc, uint32_t EventHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xb1\",\"syscall_name\" : \"NtOpenEvent\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = EventHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = EventHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"EventHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"EventHandle\" : ");fprintf(outFile, "\"Unable to read EventHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenEvent_return(CPUState *cpu, target_ulong pc, uint32_t EventHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xb1\",\"syscall_name\" : \"NtOpenEvent\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = EventHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = EventHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"EventHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"EventHandle\" : ");fprintf(outFile, "\"Unable to read EventHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*178 NTSTATUS NtOpenEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtOpenEventPair_enter(CPUState *cpu, target_ulong pc, uint32_t EventPairHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xb2\",\"syscall_name\" : \"NtOpenEventPair\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventPairHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventPairHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = EventPairHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = EventPairHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"EventPairHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"EventPairHandle\" : ");fprintf(outFile, "\"Unable to read EventPairHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenEventPair_return(CPUState *cpu, target_ulong pc, uint32_t EventPairHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xb2\",\"syscall_name\" : \"NtOpenEventPair\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventPairHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventPairHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = EventPairHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = EventPairHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"EventPairHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"EventPairHandle\" : ");fprintf(outFile, "\"Unable to read EventPairHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*179 NTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);*/
void on_cb_NtOpenFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t IoStatusBlock, uint32_t ShareAccess, uint32_t OpenOptions) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xb3\",\"syscall_name\" : \"NtOpenFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"ShareAccess\":\"0x%x\", \"OpenOptions\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, ShareAccess, OpenOptions, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = FileHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = FileHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"FileHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"FileHandle\" : ");fprintf(outFile, "\"Unable to read FileHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t IoStatusBlock, uint32_t ShareAccess, uint32_t OpenOptions) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xb3\",\"syscall_name\" : \"NtOpenFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"ShareAccess\":\"0x%x\", \"OpenOptions\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, ShareAccess, OpenOptions, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = FileHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = FileHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"FileHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"FileHandle\" : ");fprintf(outFile, "\"Unable to read FileHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*180 NTSTATUS NtOpenIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtOpenIoCompletion_enter(CPUState *cpu, target_ulong pc, uint32_t IoCompletionHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xb4\",\"syscall_name\" : \"NtOpenIoCompletion\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"IoCompletionHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, IoCompletionHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = IoCompletionHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = IoCompletionHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"IoCompletionHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"IoCompletionHandle\" : ");fprintf(outFile, "\"Unable to read IoCompletionHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenIoCompletion_return(CPUState *cpu, target_ulong pc, uint32_t IoCompletionHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xb4\",\"syscall_name\" : \"NtOpenIoCompletion\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"IoCompletionHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, IoCompletionHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = IoCompletionHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = IoCompletionHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"IoCompletionHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"IoCompletionHandle\" : ");fprintf(outFile, "\"Unable to read IoCompletionHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*181 NTSTATUS NtOpenJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtOpenJobObject_enter(CPUState *cpu, target_ulong pc, uint32_t JobHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xb5\",\"syscall_name\" : \"NtOpenJobObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"JobHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, JobHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = JobHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = JobHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"JobHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"JobHandle\" : ");fprintf(outFile, "\"Unable to read JobHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenJobObject_return(CPUState *cpu, target_ulong pc, uint32_t JobHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xb5\",\"syscall_name\" : \"NtOpenJobObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"JobHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, JobHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = JobHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = JobHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"JobHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"JobHandle\" : ");fprintf(outFile, "\"Unable to read JobHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*182 NTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtOpenKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xb6\",\"syscall_name\" : \"NtOpenKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyHandle\" : ");fprintf(outFile, "\"Unable to read KeyHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xb6\",\"syscall_name\" : \"NtOpenKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyHandle\" : ");fprintf(outFile, "\"Unable to read KeyHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*183 NTSTATUS NtOpenKeyEx (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions);*/
void on_cb_NtOpenKeyEx_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t OpenOptions) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xb7\",\"syscall_name\" : \"NtOpenKeyEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"OpenOptions\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, DesiredAccess, ObjectAttributes, OpenOptions, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyHandle\" : ");fprintf(outFile, "\"Unable to read KeyHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenKeyEx_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t OpenOptions) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xb7\",\"syscall_name\" : \"NtOpenKeyEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"OpenOptions\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, DesiredAccess, ObjectAttributes, OpenOptions, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyHandle\" : ");fprintf(outFile, "\"Unable to read KeyHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*184 NTSTATUS NtOpenKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtOpenKeyedEvent_enter(CPUState *cpu, target_ulong pc, uint32_t KeyedEventHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xb8\",\"syscall_name\" : \"NtOpenKeyedEvent\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyedEventHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyedEventHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyedEventHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyedEventHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyedEventHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyedEventHandle\" : ");fprintf(outFile, "\"Unable to read KeyedEventHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenKeyedEvent_return(CPUState *cpu, target_ulong pc, uint32_t KeyedEventHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xb8\",\"syscall_name\" : \"NtOpenKeyedEvent\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyedEventHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyedEventHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyedEventHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyedEventHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyedEventHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyedEventHandle\" : ");fprintf(outFile, "\"Unable to read KeyedEventHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*185 NTSTATUS NtOpenKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE TransactionHandle);*/
void on_cb_NtOpenKeyTransacted_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t TransactionHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xb9\",\"syscall_name\" : \"NtOpenKeyTransacted\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"TransactionHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, DesiredAccess, ObjectAttributes, TransactionHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyHandle\" : ");fprintf(outFile, "\"Unable to read KeyHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenKeyTransacted_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t TransactionHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xb9\",\"syscall_name\" : \"NtOpenKeyTransacted\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"TransactionHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, DesiredAccess, ObjectAttributes, TransactionHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyHandle\" : ");fprintf(outFile, "\"Unable to read KeyHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*186 NTSTATUS NtOpenKeyTransactedEx (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions, HANDLE TransactionHandle);*/
void on_cb_NtOpenKeyTransactedEx_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t OpenOptions, uint32_t TransactionHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xba\",\"syscall_name\" : \"NtOpenKeyTransactedEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"OpenOptions\":\"0x%x\", \"TransactionHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, DesiredAccess, ObjectAttributes, OpenOptions, TransactionHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyHandle\" : ");fprintf(outFile, "\"Unable to read KeyHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenKeyTransactedEx_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t OpenOptions, uint32_t TransactionHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xba\",\"syscall_name\" : \"NtOpenKeyTransactedEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"OpenOptions\":\"0x%x\", \"TransactionHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, DesiredAccess, ObjectAttributes, OpenOptions, TransactionHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyHandle\" : ");fprintf(outFile, "\"Unable to read KeyHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*187 NTSTATUS NtOpenMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtOpenMutant_enter(CPUState *cpu, target_ulong pc, uint32_t MutantHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xbb\",\"syscall_name\" : \"NtOpenMutant\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"MutantHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, MutantHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = MutantHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MutantHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MutantHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MutantHandle\" : ");fprintf(outFile, "\"Unable to read MutantHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenMutant_return(CPUState *cpu, target_ulong pc, uint32_t MutantHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xbb\",\"syscall_name\" : \"NtOpenMutant\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"MutantHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, MutantHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = MutantHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MutantHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MutantHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MutantHandle\" : ");fprintf(outFile, "\"Unable to read MutantHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*188 NTSTATUS NtOpenObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose);*/
void on_cb_NtOpenObjectAuditAlarm_enter(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t HandleId, uint32_t ObjectTypeName, uint32_t ObjectName, uint32_t SecurityDescriptor, uint32_t ClientToken, uint32_t DesiredAccess, uint32_t GrantedAccess, uint32_t Privileges, uint32_t ObjectCreation, uint32_t AccessGranted, uint32_t GenerateOnClose) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xbc\",\"syscall_name\" : \"NtOpenObjectAuditAlarm\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"HandleId\":\"0x%x\", \"ObjectTypeName\":\"0x%x\", \"ObjectName\":\"0x%x\", \"SecurityDescriptor\":\"0x%x\", \"ClientToken\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"GrantedAccess\":\"0x%x\", \"Privileges\":\"0x%x\", \"ObjectCreation\":\"0x%x\", \"AccessGranted\":\"0x%x\", \"GenerateOnClose\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, ClientToken, DesiredAccess, GrantedAccess, Privileges, ObjectCreation, AccessGranted, GenerateOnClose, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectTypeName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectTypeName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectTypeName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectTypeName\" : ");fprintf(outFile, "\"Unable to read ObjectTypeName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectName\" : ");fprintf(outFile, "\"Unable to read ObjectName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenObjectAuditAlarm_return(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t HandleId, uint32_t ObjectTypeName, uint32_t ObjectName, uint32_t SecurityDescriptor, uint32_t ClientToken, uint32_t DesiredAccess, uint32_t GrantedAccess, uint32_t Privileges, uint32_t ObjectCreation, uint32_t AccessGranted, uint32_t GenerateOnClose) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xbc\",\"syscall_name\" : \"NtOpenObjectAuditAlarm\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"HandleId\":\"0x%x\", \"ObjectTypeName\":\"0x%x\", \"ObjectName\":\"0x%x\", \"SecurityDescriptor\":\"0x%x\", \"ClientToken\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"GrantedAccess\":\"0x%x\", \"Privileges\":\"0x%x\", \"ObjectCreation\":\"0x%x\", \"AccessGranted\":\"0x%x\", \"GenerateOnClose\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, ClientToken, DesiredAccess, GrantedAccess, Privileges, ObjectCreation, AccessGranted, GenerateOnClose, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectTypeName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectTypeName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectTypeName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectTypeName\" : ");fprintf(outFile, "\"Unable to read ObjectTypeName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectName\" : ");fprintf(outFile, "\"Unable to read ObjectName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*189 NTSTATUS NtOpenPrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);*/
void on_cb_NtOpenPrivateNamespace_enter(CPUState *cpu, target_ulong pc, uint32_t NamespaceHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t BoundaryDescriptor) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xbd\",\"syscall_name\" : \"NtOpenPrivateNamespace\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"NamespaceHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"BoundaryDescriptor\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, NamespaceHandle, DesiredAccess, ObjectAttributes, BoundaryDescriptor, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NamespaceHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NamespaceHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NamespaceHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NamespaceHandle\" : ");fprintf(outFile, "\"Unable to read NamespaceHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenPrivateNamespace_return(CPUState *cpu, target_ulong pc, uint32_t NamespaceHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t BoundaryDescriptor) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xbd\",\"syscall_name\" : \"NtOpenPrivateNamespace\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"NamespaceHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"BoundaryDescriptor\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, NamespaceHandle, DesiredAccess, ObjectAttributes, BoundaryDescriptor, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NamespaceHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NamespaceHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NamespaceHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NamespaceHandle\" : ");fprintf(outFile, "\"Unable to read NamespaceHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*190 NTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);*/
void on_cb_NtOpenProcess_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t ClientId) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xbe\",\"syscall_name\" : \"NtOpenProcess\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"ClientId\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, DesiredAccess, ObjectAttributes, ClientId, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ProcessHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProcessHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProcessHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProcessHandle\" : ");fprintf(outFile, "\"Unable to read ProcessHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenProcess_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t ClientId) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xbe\",\"syscall_name\" : \"NtOpenProcess\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"ClientId\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, DesiredAccess, ObjectAttributes, ClientId, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ProcessHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ProcessHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ProcessHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ProcessHandle\" : ");fprintf(outFile, "\"Unable to read ProcessHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*191 NTSTATUS NtOpenProcessToken (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);*/
void on_cb_NtOpenProcessToken_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t DesiredAccess, uint32_t TokenHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xbf\",\"syscall_name\" : \"NtOpenProcessToken\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"TokenHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, DesiredAccess, TokenHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TokenHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TokenHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TokenHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TokenHandle\" : ");fprintf(outFile, "\"Unable to read TokenHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenProcessToken_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t DesiredAccess, uint32_t TokenHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xbf\",\"syscall_name\" : \"NtOpenProcessToken\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"TokenHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, DesiredAccess, TokenHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TokenHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TokenHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TokenHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TokenHandle\" : ");fprintf(outFile, "\"Unable to read TokenHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*192 NTSTATUS NtOpenProcessTokenEx (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);*/
void on_cb_NtOpenProcessTokenEx_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t DesiredAccess, uint32_t HandleAttributes, uint32_t TokenHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xc0\",\"syscall_name\" : \"NtOpenProcessTokenEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"HandleAttributes\":\"0x%x\", \"TokenHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, DesiredAccess, HandleAttributes, TokenHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TokenHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TokenHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TokenHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TokenHandle\" : ");fprintf(outFile, "\"Unable to read TokenHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenProcessTokenEx_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t DesiredAccess, uint32_t HandleAttributes, uint32_t TokenHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xc0\",\"syscall_name\" : \"NtOpenProcessTokenEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"HandleAttributes\":\"0x%x\", \"TokenHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, DesiredAccess, HandleAttributes, TokenHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TokenHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TokenHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TokenHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TokenHandle\" : ");fprintf(outFile, "\"Unable to read TokenHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*193 NTSTATUS NtOpenResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID ResourceManagerGuid, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtOpenResourceManager_enter(CPUState *cpu, target_ulong pc, uint32_t ResourceManagerHandle, uint32_t DesiredAccess, uint32_t TmHandle, uint32_t ResourceManagerGuid, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xc1\",\"syscall_name\" : \"NtOpenResourceManager\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManagerHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"TmHandle\":\"0x%x\", \"ResourceManagerGuid\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ResourceManagerHandle, DesiredAccess, TmHandle, ResourceManagerGuid, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ResourceManagerHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ResourceManagerHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ResourceManagerHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ResourceManagerHandle\" : ");fprintf(outFile, "\"Unable to read ResourceManagerHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenResourceManager_return(CPUState *cpu, target_ulong pc, uint32_t ResourceManagerHandle, uint32_t DesiredAccess, uint32_t TmHandle, uint32_t ResourceManagerGuid, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xc1\",\"syscall_name\" : \"NtOpenResourceManager\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManagerHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"TmHandle\":\"0x%x\", \"ResourceManagerGuid\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ResourceManagerHandle, DesiredAccess, TmHandle, ResourceManagerGuid, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ResourceManagerHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ResourceManagerHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ResourceManagerHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ResourceManagerHandle\" : ");fprintf(outFile, "\"Unable to read ResourceManagerHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*194 NTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtOpenSection_enter(CPUState *cpu, target_ulong pc, uint32_t SectionHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xc2\",\"syscall_name\" : \"NtOpenSection\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SectionHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SectionHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SectionHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SectionHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SectionHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SectionHandle\" : ");fprintf(outFile, "\"Unable to read SectionHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenSection_return(CPUState *cpu, target_ulong pc, uint32_t SectionHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xc2\",\"syscall_name\" : \"NtOpenSection\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SectionHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SectionHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SectionHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SectionHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SectionHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SectionHandle\" : ");fprintf(outFile, "\"Unable to read SectionHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*195 NTSTATUS NtOpenSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtOpenSemaphore_enter(CPUState *cpu, target_ulong pc, uint32_t SemaphoreHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xc3\",\"syscall_name\" : \"NtOpenSemaphore\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SemaphoreHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SemaphoreHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SemaphoreHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SemaphoreHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SemaphoreHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SemaphoreHandle\" : ");fprintf(outFile, "\"Unable to read SemaphoreHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenSemaphore_return(CPUState *cpu, target_ulong pc, uint32_t SemaphoreHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xc3\",\"syscall_name\" : \"NtOpenSemaphore\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SemaphoreHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SemaphoreHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SemaphoreHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SemaphoreHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SemaphoreHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SemaphoreHandle\" : ");fprintf(outFile, "\"Unable to read SemaphoreHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*196 NTSTATUS NtOpenSession (PHANDLE SessionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtOpenSession_enter(CPUState *cpu, target_ulong pc, uint32_t SessionHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xc4\",\"syscall_name\" : \"NtOpenSession\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SessionHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SessionHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SessionHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SessionHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SessionHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SessionHandle\" : ");fprintf(outFile, "\"Unable to read SessionHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenSession_return(CPUState *cpu, target_ulong pc, uint32_t SessionHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xc4\",\"syscall_name\" : \"NtOpenSession\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SessionHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SessionHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SessionHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SessionHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SessionHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SessionHandle\" : ");fprintf(outFile, "\"Unable to read SessionHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*197 NTSTATUS NtOpenSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtOpenSymbolicLinkObject_enter(CPUState *cpu, target_ulong pc, uint32_t LinkHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xc5\",\"syscall_name\" : \"NtOpenSymbolicLinkObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"LinkHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, LinkHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = LinkHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = LinkHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"LinkHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"LinkHandle\" : ");fprintf(outFile, "\"Unable to read LinkHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenSymbolicLinkObject_return(CPUState *cpu, target_ulong pc, uint32_t LinkHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xc5\",\"syscall_name\" : \"NtOpenSymbolicLinkObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"LinkHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, LinkHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = LinkHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = LinkHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"LinkHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"LinkHandle\" : ");fprintf(outFile, "\"Unable to read LinkHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*198 NTSTATUS NtOpenThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);*/
void on_cb_NtOpenThread_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t ClientId) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xc6\",\"syscall_name\" : \"NtOpenThread\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"ClientId\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, DesiredAccess, ObjectAttributes, ClientId, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ThreadHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ThreadHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ThreadHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ThreadHandle\" : ");fprintf(outFile, "\"Unable to read ThreadHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenThread_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t ClientId) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xc6\",\"syscall_name\" : \"NtOpenThread\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"ClientId\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, DesiredAccess, ObjectAttributes, ClientId, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ThreadHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ThreadHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ThreadHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ThreadHandle\" : ");fprintf(outFile, "\"Unable to read ThreadHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*199 NTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);*/
void on_cb_NtOpenThreadToken_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t DesiredAccess, uint32_t OpenAsSelf, uint32_t TokenHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xc7\",\"syscall_name\" : \"NtOpenThreadToken\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"OpenAsSelf\":\"0x%x\", \"TokenHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, DesiredAccess, OpenAsSelf, TokenHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TokenHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TokenHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TokenHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TokenHandle\" : ");fprintf(outFile, "\"Unable to read TokenHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenThreadToken_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t DesiredAccess, uint32_t OpenAsSelf, uint32_t TokenHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xc7\",\"syscall_name\" : \"NtOpenThreadToken\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"OpenAsSelf\":\"0x%x\", \"TokenHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, DesiredAccess, OpenAsSelf, TokenHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TokenHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TokenHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TokenHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TokenHandle\" : ");fprintf(outFile, "\"Unable to read TokenHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*200 NTSTATUS NtOpenThreadTokenEx (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);*/
void on_cb_NtOpenThreadTokenEx_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t DesiredAccess, uint32_t OpenAsSelf, uint32_t HandleAttributes, uint32_t TokenHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xc8\",\"syscall_name\" : \"NtOpenThreadTokenEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"OpenAsSelf\":\"0x%x\", \"HandleAttributes\":\"0x%x\", \"TokenHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, DesiredAccess, OpenAsSelf, HandleAttributes, TokenHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TokenHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TokenHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TokenHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TokenHandle\" : ");fprintf(outFile, "\"Unable to read TokenHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenThreadTokenEx_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t DesiredAccess, uint32_t OpenAsSelf, uint32_t HandleAttributes, uint32_t TokenHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xc8\",\"syscall_name\" : \"NtOpenThreadTokenEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"OpenAsSelf\":\"0x%x\", \"HandleAttributes\":\"0x%x\", \"TokenHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, DesiredAccess, OpenAsSelf, HandleAttributes, TokenHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TokenHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TokenHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TokenHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TokenHandle\" : ");fprintf(outFile, "\"Unable to read TokenHandle\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*201 NTSTATUS NtOpenTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);*/
void on_cb_NtOpenTimer_enter(CPUState *cpu, target_ulong pc, uint32_t TimerHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xc9\",\"syscall_name\" : \"NtOpenTimer\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TimerHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TimerHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TimerHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TimerHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TimerHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TimerHandle\" : ");fprintf(outFile, "\"Unable to read TimerHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenTimer_return(CPUState *cpu, target_ulong pc, uint32_t TimerHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xc9\",\"syscall_name\" : \"NtOpenTimer\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TimerHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TimerHandle, DesiredAccess, ObjectAttributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TimerHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TimerHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TimerHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TimerHandle\" : ");fprintf(outFile, "\"Unable to read TimerHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*202 NTSTATUS NtOpenTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle);*/
void on_cb_NtOpenTransaction_enter(CPUState *cpu, target_ulong pc, uint32_t TransactionHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t Uow, uint32_t TmHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xca\",\"syscall_name\" : \"NtOpenTransaction\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"Uow\":\"0x%x\", \"TmHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TransactionHandle, DesiredAccess, ObjectAttributes, Uow, TmHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TransactionHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TransactionHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TransactionHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TransactionHandle\" : ");fprintf(outFile, "\"Unable to read TransactionHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenTransaction_return(CPUState *cpu, target_ulong pc, uint32_t TransactionHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t Uow, uint32_t TmHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xca\",\"syscall_name\" : \"NtOpenTransaction\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"Uow\":\"0x%x\", \"TmHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TransactionHandle, DesiredAccess, ObjectAttributes, Uow, TmHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TransactionHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TransactionHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TransactionHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TransactionHandle\" : ");fprintf(outFile, "\"Unable to read TransactionHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*203 NTSTATUS NtOpenTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, LPGUID TmIdentity, ULONG OpenOptions);*/
void on_cb_NtOpenTransactionManager_enter(CPUState *cpu, target_ulong pc, uint32_t TmHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t LogFileName, uint32_t TmIdentity, uint32_t OpenOptions) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xcb\",\"syscall_name\" : \"NtOpenTransactionManager\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TmHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"LogFileName\":\"0x%x\", \"TmIdentity\":\"0x%x\", \"OpenOptions\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TmHandle, DesiredAccess, ObjectAttributes, LogFileName, TmIdentity, OpenOptions, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmHandle\" : ");fprintf(outFile, "\"Unable to read TmHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = LogFileName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = LogFileName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"LogFileName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"LogFileName\" : ");fprintf(outFile, "\"Unable to read LogFileName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtOpenTransactionManager_return(CPUState *cpu, target_ulong pc, uint32_t TmHandle, uint32_t DesiredAccess, uint32_t ObjectAttributes, uint32_t LogFileName, uint32_t TmIdentity, uint32_t OpenOptions) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xcb\",\"syscall_name\" : \"NtOpenTransactionManager\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TmHandle\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"ObjectAttributes\":\"0x%x\", \"LogFileName\":\"0x%x\", \"TmIdentity\":\"0x%x\", \"OpenOptions\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TmHandle, DesiredAccess, ObjectAttributes, LogFileName, TmIdentity, OpenOptions, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmHandle\" : ");fprintf(outFile, "\"Unable to read TmHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = LogFileName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = LogFileName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"LogFileName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"LogFileName\" : ");fprintf(outFile, "\"Unable to read LogFileName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*204 NTSTATUS NtPlugPlayControl (PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength);*/
void on_cb_NtPlugPlayControl_enter(CPUState *cpu, target_ulong pc, uint32_t PnPControlClass, uint32_t PnPControlData, uint32_t PnPControlDataLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xcc\",\"syscall_name\" : \"NtPlugPlayControl\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PnPControlClass\":\"0x%x\", \"PnPControlData\":\"0x%x\", \"PnPControlDataLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PnPControlClass, PnPControlData, PnPControlDataLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtPlugPlayControl_return(CPUState *cpu, target_ulong pc, uint32_t PnPControlClass, uint32_t PnPControlData, uint32_t PnPControlDataLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xcc\",\"syscall_name\" : \"NtPlugPlayControl\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PnPControlClass\":\"0x%x\", \"PnPControlData\":\"0x%x\", \"PnPControlDataLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PnPControlClass, PnPControlData, PnPControlDataLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*205 NTSTATUS NtPowerInformation (POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);*/
void on_cb_NtPowerInformation_enter(CPUState *cpu, target_ulong pc, uint32_t InformationLevel, uint32_t InputBuffer, uint32_t InputBufferLength, uint32_t OutputBuffer, uint32_t OutputBufferLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xcd\",\"syscall_name\" : \"NtPowerInformation\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"InformationLevel\":\"0x%x\", \"InputBuffer\":\"0x%x\", \"InputBufferLength\":\"0x%x\", \"OutputBuffer\":\"0x%x\", \"OutputBufferLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, InformationLevel, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtPowerInformation_return(CPUState *cpu, target_ulong pc, uint32_t InformationLevel, uint32_t InputBuffer, uint32_t InputBufferLength, uint32_t OutputBuffer, uint32_t OutputBufferLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xcd\",\"syscall_name\" : \"NtPowerInformation\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"InformationLevel\":\"0x%x\", \"InputBuffer\":\"0x%x\", \"InputBufferLength\":\"0x%x\", \"OutputBuffer\":\"0x%x\", \"OutputBufferLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, InformationLevel, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*206 NTSTATUS NtPrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);*/
void on_cb_NtPrepareComplete_enter(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xce\",\"syscall_name\" : \"NtPrepareComplete\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtPrepareComplete_return(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xce\",\"syscall_name\" : \"NtPrepareComplete\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*207 NTSTATUS NtPrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);*/
void on_cb_NtPrepareEnlistment_enter(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xcf\",\"syscall_name\" : \"NtPrepareEnlistment\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtPrepareEnlistment_return(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xcf\",\"syscall_name\" : \"NtPrepareEnlistment\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*208 NTSTATUS NtPrePrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);*/
void on_cb_NtPrePrepareComplete_enter(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xd0\",\"syscall_name\" : \"NtPrePrepareComplete\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtPrePrepareComplete_return(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xd0\",\"syscall_name\" : \"NtPrePrepareComplete\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*209 NTSTATUS NtPrePrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);*/
void on_cb_NtPrePrepareEnlistment_enter(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xd1\",\"syscall_name\" : \"NtPrePrepareEnlistment\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtPrePrepareEnlistment_return(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xd1\",\"syscall_name\" : \"NtPrePrepareEnlistment\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*210 NTSTATUS NtPrivilegeCheck (HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result);*/
void on_cb_NtPrivilegeCheck_enter(CPUState *cpu, target_ulong pc, uint32_t ClientToken, uint32_t RequiredPrivileges, uint32_t Result) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xd2\",\"syscall_name\" : \"NtPrivilegeCheck\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ClientToken\":\"0x%x\", \"RequiredPrivileges\":\"0x%x\", \"Result\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ClientToken, RequiredPrivileges, Result, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtPrivilegeCheck_return(CPUState *cpu, target_ulong pc, uint32_t ClientToken, uint32_t RequiredPrivileges, uint32_t Result) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xd2\",\"syscall_name\" : \"NtPrivilegeCheck\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ClientToken\":\"0x%x\", \"RequiredPrivileges\":\"0x%x\", \"Result\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ClientToken, RequiredPrivileges, Result, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*211 NTSTATUS NtPrivilegedServiceAuditAlarm (PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);*/
void on_cb_NtPrivilegedServiceAuditAlarm_enter(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t ServiceName, uint32_t ClientToken, uint32_t Privileges, uint32_t AccessGranted) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xd3\",\"syscall_name\" : \"NtPrivilegedServiceAuditAlarm\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"ServiceName\":\"0x%x\", \"ClientToken\":\"0x%x\", \"Privileges\":\"0x%x\", \"AccessGranted\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, ServiceName, ClientToken, Privileges, AccessGranted, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ServiceName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ServiceName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ServiceName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ServiceName\" : ");fprintf(outFile, "\"Unable to read ServiceName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtPrivilegedServiceAuditAlarm_return(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t ServiceName, uint32_t ClientToken, uint32_t Privileges, uint32_t AccessGranted) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xd3\",\"syscall_name\" : \"NtPrivilegedServiceAuditAlarm\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"ServiceName\":\"0x%x\", \"ClientToken\":\"0x%x\", \"Privileges\":\"0x%x\", \"AccessGranted\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, ServiceName, ClientToken, Privileges, AccessGranted, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ServiceName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ServiceName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ServiceName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ServiceName\" : ");fprintf(outFile, "\"Unable to read ServiceName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*212 NTSTATUS NtPrivilegeObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);*/
void on_cb_NtPrivilegeObjectAuditAlarm_enter(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t HandleId, uint32_t ClientToken, uint32_t DesiredAccess, uint32_t Privileges, uint32_t AccessGranted) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xd4\",\"syscall_name\" : \"NtPrivilegeObjectAuditAlarm\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"HandleId\":\"0x%x\", \"ClientToken\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"Privileges\":\"0x%x\", \"AccessGranted\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, HandleId, ClientToken, DesiredAccess, Privileges, AccessGranted, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtPrivilegeObjectAuditAlarm_return(CPUState *cpu, target_ulong pc, uint32_t SubsystemName, uint32_t HandleId, uint32_t ClientToken, uint32_t DesiredAccess, uint32_t Privileges, uint32_t AccessGranted) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xd4\",\"syscall_name\" : \"NtPrivilegeObjectAuditAlarm\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SubsystemName\":\"0x%x\", \"HandleId\":\"0x%x\", \"ClientToken\":\"0x%x\", \"DesiredAccess\":\"0x%x\", \"Privileges\":\"0x%x\", \"AccessGranted\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SubsystemName, HandleId, ClientToken, DesiredAccess, Privileges, AccessGranted, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SubsystemName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SubsystemName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SubsystemName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SubsystemName\" : ");fprintf(outFile, "\"Unable to read SubsystemName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*213 NTSTATUS NtPropagationComplete (HANDLE ResourceManagerHandle, ULONG RequestCookie, ULONG BufferLength, PVOID Buffer);*/
void on_cb_NtPropagationComplete_enter(CPUState *cpu, target_ulong pc, uint32_t ResourceManagerHandle, uint32_t RequestCookie, uint32_t BufferLength, uint32_t Buffer) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xd5\",\"syscall_name\" : \"NtPropagationComplete\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManagerHandle\":\"0x%x\", \"RequestCookie\":\"0x%x\", \"BufferLength\":\"0x%x\", \"Buffer\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ResourceManagerHandle, RequestCookie, BufferLength, Buffer, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtPropagationComplete_return(CPUState *cpu, target_ulong pc, uint32_t ResourceManagerHandle, uint32_t RequestCookie, uint32_t BufferLength, uint32_t Buffer) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xd5\",\"syscall_name\" : \"NtPropagationComplete\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManagerHandle\":\"0x%x\", \"RequestCookie\":\"0x%x\", \"BufferLength\":\"0x%x\", \"Buffer\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ResourceManagerHandle, RequestCookie, BufferLength, Buffer, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*214 NTSTATUS NtPropagationFailed (HANDLE ResourceManagerHandle, ULONG RequestCookie, NTSTATUS PropStatus);*/
void on_cb_NtPropagationFailed_enter(CPUState *cpu, target_ulong pc, uint32_t ResourceManagerHandle, uint32_t RequestCookie, uint32_t PropStatus) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xd6\",\"syscall_name\" : \"NtPropagationFailed\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManagerHandle\":\"0x%x\", \"RequestCookie\":\"0x%x\", \"PropStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ResourceManagerHandle, RequestCookie, PropStatus, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtPropagationFailed_return(CPUState *cpu, target_ulong pc, uint32_t ResourceManagerHandle, uint32_t RequestCookie, uint32_t PropStatus) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xd6\",\"syscall_name\" : \"NtPropagationFailed\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManagerHandle\":\"0x%x\", \"RequestCookie\":\"0x%x\", \"PropStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ResourceManagerHandle, RequestCookie, PropStatus, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*215 NTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, WIN32_PROTECTION_MASK NewProtectWin32, PULONG OldProtect);*/
void on_cb_NtProtectVirtualMemory_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t RegionSize, uint32_t NewProtectWin32, uint32_t OldProtect) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xd7\",\"syscall_name\" : \"NtProtectVirtualMemory\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"RegionSize\":\"0x%x\", \"NewProtectWin32\":\"0x%x\", \"OldProtect\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, RegionSize, NewProtectWin32, OldProtect, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = OldProtect;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = OldProtect;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"OldProtect\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"OldProtect\" : ");fprintf(outFile, "\"Unable to read OldProtect\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtProtectVirtualMemory_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t RegionSize, uint32_t NewProtectWin32, uint32_t OldProtect) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xd7\",\"syscall_name\" : \"NtProtectVirtualMemory\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"RegionSize\":\"0x%x\", \"NewProtectWin32\":\"0x%x\", \"OldProtect\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, RegionSize, NewProtectWin32, OldProtect, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = OldProtect;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = OldProtect;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"OldProtect\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"OldProtect\" : ");fprintf(outFile, "\"Unable to read OldProtect\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*216 NTSTATUS NtPulseEvent (HANDLE EventHandle, PLONG PreviousState);*/
void on_cb_NtPulseEvent_enter(CPUState *cpu, target_ulong pc, uint32_t EventHandle, uint32_t PreviousState) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xd8\",\"syscall_name\" : \"NtPulseEvent\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\", \"PreviousState\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventHandle, PreviousState, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PreviousState;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousState;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousState\" : ");dump_LONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousState\" : ");fprintf(outFile, "\"Unable to read PreviousState\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtPulseEvent_return(CPUState *cpu, target_ulong pc, uint32_t EventHandle, uint32_t PreviousState) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xd8\",\"syscall_name\" : \"NtPulseEvent\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\", \"PreviousState\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventHandle, PreviousState, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PreviousState;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousState;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousState\" : ");dump_LONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousState\" : ");fprintf(outFile, "\"Unable to read PreviousState\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*217 NTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);*/
void on_cb_NtQueryAttributesFile_enter(CPUState *cpu, target_ulong pc, uint32_t ObjectAttributes, uint32_t FileInformation) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xd9\",\"syscall_name\" : \"NtQueryAttributesFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ObjectAttributes\":\"0x%x\", \"FileInformation\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ObjectAttributes, FileInformation, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryAttributesFile_return(CPUState *cpu, target_ulong pc, uint32_t ObjectAttributes, uint32_t FileInformation) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xd9\",\"syscall_name\" : \"NtQueryAttributesFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ObjectAttributes\":\"0x%x\", \"FileInformation\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ObjectAttributes, FileInformation, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*218 NTSTATUS NtQueryBootEntryOrder (PULONG Ids, PULONG Count);*/
void on_cb_NtQueryBootEntryOrder_enter(CPUState *cpu, target_ulong pc, uint32_t Ids, uint32_t Count) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xda\",\"syscall_name\" : \"NtQueryBootEntryOrder\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Ids\":\"0x%x\", \"Count\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Ids, Count, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Ids;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Ids;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Ids\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Ids\" : ");fprintf(outFile, "\"Unable to read Ids\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Count;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Count;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Count\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Count\" : ");fprintf(outFile, "\"Unable to read Count\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryBootEntryOrder_return(CPUState *cpu, target_ulong pc, uint32_t Ids, uint32_t Count) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xda\",\"syscall_name\" : \"NtQueryBootEntryOrder\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Ids\":\"0x%x\", \"Count\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Ids, Count, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Ids;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Ids;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Ids\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Ids\" : ");fprintf(outFile, "\"Unable to read Ids\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Count;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Count;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Count\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Count\" : ");fprintf(outFile, "\"Unable to read Count\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*219 NTSTATUS NtQueryBootOptions (PBOOT_OPTIONS BootOptions, PULONG BootOptionsLength);*/
void on_cb_NtQueryBootOptions_enter(CPUState *cpu, target_ulong pc, uint32_t BootOptions, uint32_t BootOptionsLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xdb\",\"syscall_name\" : \"NtQueryBootOptions\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"BootOptions\":\"0x%x\", \"BootOptionsLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, BootOptions, BootOptionsLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BootOptionsLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BootOptionsLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BootOptionsLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BootOptionsLength\" : ");fprintf(outFile, "\"Unable to read BootOptionsLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryBootOptions_return(CPUState *cpu, target_ulong pc, uint32_t BootOptions, uint32_t BootOptionsLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xdb\",\"syscall_name\" : \"NtQueryBootOptions\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"BootOptions\":\"0x%x\", \"BootOptionsLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, BootOptions, BootOptionsLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BootOptionsLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BootOptionsLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BootOptionsLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BootOptionsLength\" : ");fprintf(outFile, "\"Unable to read BootOptionsLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*220 NTSTATUS NtQueryDebugFilterState (ULONG ComponentId, ULONG Level);*/
void on_cb_NtQueryDebugFilterState_enter(CPUState *cpu, target_ulong pc, uint32_t ComponentId, uint32_t Level) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xdc\",\"syscall_name\" : \"NtQueryDebugFilterState\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ComponentId\":\"0x%x\", \"Level\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ComponentId, Level, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryDebugFilterState_return(CPUState *cpu, target_ulong pc, uint32_t ComponentId, uint32_t Level) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xdc\",\"syscall_name\" : \"NtQueryDebugFilterState\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ComponentId\":\"0x%x\", \"Level\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ComponentId, Level, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*221 NTSTATUS NtQueryDefaultLocale (BOOLEAN UserProfile, PLCID DefaultLocaleId);*/
void on_cb_NtQueryDefaultLocale_enter(CPUState *cpu, target_ulong pc, uint32_t UserProfile, uint32_t DefaultLocaleId) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xdd\",\"syscall_name\" : \"NtQueryDefaultLocale\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"UserProfile\":\"0x%x\", \"DefaultLocaleId\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, UserProfile, DefaultLocaleId, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryDefaultLocale_return(CPUState *cpu, target_ulong pc, uint32_t UserProfile, uint32_t DefaultLocaleId) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xdd\",\"syscall_name\" : \"NtQueryDefaultLocale\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"UserProfile\":\"0x%x\", \"DefaultLocaleId\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, UserProfile, DefaultLocaleId, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*222 NTSTATUS NtQueryDefaultUILanguage (LANGID *DefaultUILanguageId);*/
void on_cb_NtQueryDefaultUILanguage_enter(CPUState *cpu, target_ulong pc, uint32_t DefaultUILanguageId) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xde\",\"syscall_name\" : \"NtQueryDefaultUILanguage\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DefaultUILanguageId\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, DefaultUILanguageId, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DefaultUILanguageId;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DefaultUILanguageId;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LANGID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DefaultUILanguageId\" : ");dump_LANGID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DefaultUILanguageId\" : ");fprintf(outFile, "\"Unable to read DefaultUILanguageId\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryDefaultUILanguage_return(CPUState *cpu, target_ulong pc, uint32_t DefaultUILanguageId) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xde\",\"syscall_name\" : \"NtQueryDefaultUILanguage\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DefaultUILanguageId\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, DefaultUILanguageId, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DefaultUILanguageId;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DefaultUILanguageId;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LANGID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DefaultUILanguageId\" : ");dump_LANGID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DefaultUILanguageId\" : ");fprintf(outFile, "\"Unable to read DefaultUILanguageId\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*223 NTSTATUS NtQueryDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);*/
void on_cb_NtQueryDirectoryFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t FileInformation, uint32_t Length, uint32_t FileInformationClass, uint32_t ReturnSingleEntry, uint32_t FileName, uint32_t RestartScan) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xdf\",\"syscall_name\" : \"NtQueryDirectoryFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"FileInformation\":\"0x%x\", \"Length\":\"0x%x\", \"FileInformationClass\":\"0x%x\", \"ReturnSingleEntry\":\"0x%x\", \"FileName\":\"0x%x\", \"RestartScan\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, FileInformation, Length, FileInformationClass, ReturnSingleEntry, FileName, RestartScan, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = FileName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = FileName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"FileName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"FileName\" : ");fprintf(outFile, "\"Unable to read FileName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryDirectoryFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t FileInformation, uint32_t Length, uint32_t FileInformationClass, uint32_t ReturnSingleEntry, uint32_t FileName, uint32_t RestartScan) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xdf\",\"syscall_name\" : \"NtQueryDirectoryFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"FileInformation\":\"0x%x\", \"Length\":\"0x%x\", \"FileInformationClass\":\"0x%x\", \"ReturnSingleEntry\":\"0x%x\", \"FileName\":\"0x%x\", \"RestartScan\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, FileInformation, Length, FileInformationClass, ReturnSingleEntry, FileName, RestartScan, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = FileName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = FileName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"FileName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"FileName\" : ");fprintf(outFile, "\"Unable to read FileName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*224 NTSTATUS NtQueryDirectoryObject (HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength);*/
void on_cb_NtQueryDirectoryObject_enter(CPUState *cpu, target_ulong pc, uint32_t DirectoryHandle, uint32_t Buffer, uint32_t Length, uint32_t ReturnSingleEntry, uint32_t RestartScan, uint32_t Context, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xe0\",\"syscall_name\" : \"NtQueryDirectoryObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DirectoryHandle\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\", \"ReturnSingleEntry\":\"0x%x\", \"RestartScan\":\"0x%x\", \"Context\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, DirectoryHandle, Buffer, Length, ReturnSingleEntry, RestartScan, Context, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Context;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Context;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Context\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Context\" : ");fprintf(outFile, "\"Unable to read Context\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryDirectoryObject_return(CPUState *cpu, target_ulong pc, uint32_t DirectoryHandle, uint32_t Buffer, uint32_t Length, uint32_t ReturnSingleEntry, uint32_t RestartScan, uint32_t Context, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xe0\",\"syscall_name\" : \"NtQueryDirectoryObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DirectoryHandle\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\", \"ReturnSingleEntry\":\"0x%x\", \"RestartScan\":\"0x%x\", \"Context\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, DirectoryHandle, Buffer, Length, ReturnSingleEntry, RestartScan, Context, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Context;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Context;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Context\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Context\" : ");fprintf(outFile, "\"Unable to read Context\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*225 NTSTATUS NtQueryDriverEntryOrder (PULONG Ids, PULONG Count);*/
void on_cb_NtQueryDriverEntryOrder_enter(CPUState *cpu, target_ulong pc, uint32_t Ids, uint32_t Count) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xe1\",\"syscall_name\" : \"NtQueryDriverEntryOrder\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Ids\":\"0x%x\", \"Count\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Ids, Count, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Ids;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Ids;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Ids\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Ids\" : ");fprintf(outFile, "\"Unable to read Ids\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Count;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Count;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Count\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Count\" : ");fprintf(outFile, "\"Unable to read Count\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryDriverEntryOrder_return(CPUState *cpu, target_ulong pc, uint32_t Ids, uint32_t Count) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xe1\",\"syscall_name\" : \"NtQueryDriverEntryOrder\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Ids\":\"0x%x\", \"Count\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Ids, Count, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Ids;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Ids;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Ids\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Ids\" : ");fprintf(outFile, "\"Unable to read Ids\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Count;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Count;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Count\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Count\" : ");fprintf(outFile, "\"Unable to read Count\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*226 NTSTATUS NtQueryEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);*/
void on_cb_NtQueryEaFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t Buffer, uint32_t Length, uint32_t ReturnSingleEntry, uint32_t EaList, uint32_t EaListLength, uint32_t EaIndex, uint32_t RestartScan) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xe2\",\"syscall_name\" : \"NtQueryEaFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\", \"ReturnSingleEntry\":\"0x%x\", \"EaList\":\"0x%x\", \"EaListLength\":\"0x%x\", \"EaIndex\":\"0x%x\", \"RestartScan\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, Buffer, Length, ReturnSingleEntry, EaList, EaListLength, EaIndex, RestartScan, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = EaIndex;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = EaIndex;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"EaIndex\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"EaIndex\" : ");fprintf(outFile, "\"Unable to read EaIndex\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryEaFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t Buffer, uint32_t Length, uint32_t ReturnSingleEntry, uint32_t EaList, uint32_t EaListLength, uint32_t EaIndex, uint32_t RestartScan) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xe2\",\"syscall_name\" : \"NtQueryEaFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\", \"ReturnSingleEntry\":\"0x%x\", \"EaList\":\"0x%x\", \"EaListLength\":\"0x%x\", \"EaIndex\":\"0x%x\", \"RestartScan\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, Buffer, Length, ReturnSingleEntry, EaList, EaListLength, EaIndex, RestartScan, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = EaIndex;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = EaIndex;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"EaIndex\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"EaIndex\" : ");fprintf(outFile, "\"Unable to read EaIndex\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*227 NTSTATUS NtQueryEvent (HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength);*/
void on_cb_NtQueryEvent_enter(CPUState *cpu, target_ulong pc, uint32_t EventHandle, uint32_t EventInformationClass, uint32_t EventInformation, uint32_t EventInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xe3\",\"syscall_name\" : \"NtQueryEvent\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\", \"EventInformationClass\":\"0x%x\", \"EventInformation\":\"0x%x\", \"EventInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventHandle, EventInformationClass, EventInformation, EventInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryEvent_return(CPUState *cpu, target_ulong pc, uint32_t EventHandle, uint32_t EventInformationClass, uint32_t EventInformation, uint32_t EventInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xe3\",\"syscall_name\" : \"NtQueryEvent\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\", \"EventInformationClass\":\"0x%x\", \"EventInformation\":\"0x%x\", \"EventInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventHandle, EventInformationClass, EventInformation, EventInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*228 NTSTATUS NtQueryFullAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);*/
void on_cb_NtQueryFullAttributesFile_enter(CPUState *cpu, target_ulong pc, uint32_t ObjectAttributes, uint32_t FileInformation) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xe4\",\"syscall_name\" : \"NtQueryFullAttributesFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ObjectAttributes\":\"0x%x\", \"FileInformation\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ObjectAttributes, FileInformation, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryFullAttributesFile_return(CPUState *cpu, target_ulong pc, uint32_t ObjectAttributes, uint32_t FileInformation) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xe4\",\"syscall_name\" : \"NtQueryFullAttributesFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ObjectAttributes\":\"0x%x\", \"FileInformation\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ObjectAttributes, FileInformation, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ObjectAttributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ObjectAttributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ObjectAttributes\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ObjectAttributes\" : ");fprintf(outFile, "\"Unable to read ObjectAttributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*229 NTSTATUS NtQueryInformationAtom (RTL_ATOM Atom, ATOM_INFORMATION_CLASS InformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength);*/
void on_cb_NtQueryInformationAtom_enter(CPUState *cpu, target_ulong pc, uint32_t Atom, uint32_t InformationClass, uint32_t AtomInformation, uint32_t AtomInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xe5\",\"syscall_name\" : \"NtQueryInformationAtom\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Atom\":\"0x%x\", \"InformationClass\":\"0x%x\", \"AtomInformation\":\"0x%x\", \"AtomInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Atom, InformationClass, AtomInformation, AtomInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryInformationAtom_return(CPUState *cpu, target_ulong pc, uint32_t Atom, uint32_t InformationClass, uint32_t AtomInformation, uint32_t AtomInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xe5\",\"syscall_name\" : \"NtQueryInformationAtom\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Atom\":\"0x%x\", \"InformationClass\":\"0x%x\", \"AtomInformation\":\"0x%x\", \"AtomInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Atom, InformationClass, AtomInformation, AtomInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*230 NTSTATUS NtQueryInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength, PULONG ReturnLength);*/
void on_cb_NtQueryInformationEnlistment_enter(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t EnlistmentInformationClass, uint32_t EnlistmentInformation, uint32_t EnlistmentInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xe6\",\"syscall_name\" : \"NtQueryInformationEnlistment\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"EnlistmentInformationClass\":\"0x%x\", \"EnlistmentInformation\":\"0x%x\", \"EnlistmentInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, EnlistmentInformationClass, EnlistmentInformation, EnlistmentInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryInformationEnlistment_return(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t EnlistmentInformationClass, uint32_t EnlistmentInformation, uint32_t EnlistmentInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xe6\",\"syscall_name\" : \"NtQueryInformationEnlistment\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"EnlistmentInformationClass\":\"0x%x\", \"EnlistmentInformation\":\"0x%x\", \"EnlistmentInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, EnlistmentInformationClass, EnlistmentInformation, EnlistmentInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*231 NTSTATUS NtQueryInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);*/
void on_cb_NtQueryInformationFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t FileInformation, uint32_t Length, uint32_t FileInformationClass) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xe7\",\"syscall_name\" : \"NtQueryInformationFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"FileInformation\":\"0x%x\", \"Length\":\"0x%x\", \"FileInformationClass\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, FileInformation, Length, FileInformationClass, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryInformationFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t FileInformation, uint32_t Length, uint32_t FileInformationClass) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xe7\",\"syscall_name\" : \"NtQueryInformationFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"FileInformation\":\"0x%x\", \"Length\":\"0x%x\", \"FileInformationClass\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, FileInformation, Length, FileInformationClass, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*232 NTSTATUS NtQueryInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength, PULONG ReturnLength);*/
void on_cb_NtQueryInformationJobObject_enter(CPUState *cpu, target_ulong pc, uint32_t JobHandle, uint32_t JobObjectInformationClass, uint32_t JobObjectInformation, uint32_t JobObjectInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xe8\",\"syscall_name\" : \"NtQueryInformationJobObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"JobHandle\":\"0x%x\", \"JobObjectInformationClass\":\"0x%x\", \"JobObjectInformation\":\"0x%x\", \"JobObjectInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, JobHandle, JobObjectInformationClass, JobObjectInformation, JobObjectInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryInformationJobObject_return(CPUState *cpu, target_ulong pc, uint32_t JobHandle, uint32_t JobObjectInformationClass, uint32_t JobObjectInformation, uint32_t JobObjectInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xe8\",\"syscall_name\" : \"NtQueryInformationJobObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"JobHandle\":\"0x%x\", \"JobObjectInformationClass\":\"0x%x\", \"JobObjectInformation\":\"0x%x\", \"JobObjectInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, JobHandle, JobObjectInformationClass, JobObjectInformation, JobObjectInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*233 NTSTATUS NtQueryInformationPort (HANDLE PortHandle, PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);*/
void on_cb_NtQueryInformationPort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortInformationClass, uint32_t PortInformation, uint32_t Length, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xe9\",\"syscall_name\" : \"NtQueryInformationPort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortInformationClass\":\"0x%x\", \"PortInformation\":\"0x%x\", \"Length\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortInformationClass, PortInformation, Length, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryInformationPort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortInformationClass, uint32_t PortInformation, uint32_t Length, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xe9\",\"syscall_name\" : \"NtQueryInformationPort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortInformationClass\":\"0x%x\", \"PortInformation\":\"0x%x\", \"Length\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortInformationClass, PortInformation, Length, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*234 NTSTATUS NtQueryInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);*/
void on_cb_NtQueryInformationProcess_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t ProcessInformationClass, uint32_t ProcessInformation, uint32_t ProcessInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xea\",\"syscall_name\" : \"NtQueryInformationProcess\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"ProcessInformationClass\":\"0x%x\", \"ProcessInformation\":\"0x%x\", \"ProcessInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryInformationProcess_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t ProcessInformationClass, uint32_t ProcessInformation, uint32_t ProcessInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xea\",\"syscall_name\" : \"NtQueryInformationProcess\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"ProcessInformationClass\":\"0x%x\", \"ProcessInformation\":\"0x%x\", \"ProcessInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*235 NTSTATUS NtQueryInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength, PULONG ReturnLength);*/
void on_cb_NtQueryInformationResourceManager_enter(CPUState *cpu, target_ulong pc, uint32_t ResourceManagerHandle, uint32_t ResourceManagerInformationClass, uint32_t ResourceManagerInformation, uint32_t ResourceManagerInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xeb\",\"syscall_name\" : \"NtQueryInformationResourceManager\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManagerHandle\":\"0x%x\", \"ResourceManagerInformationClass\":\"0x%x\", \"ResourceManagerInformation\":\"0x%x\", \"ResourceManagerInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ResourceManagerHandle, ResourceManagerInformationClass, ResourceManagerInformation, ResourceManagerInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryInformationResourceManager_return(CPUState *cpu, target_ulong pc, uint32_t ResourceManagerHandle, uint32_t ResourceManagerInformationClass, uint32_t ResourceManagerInformation, uint32_t ResourceManagerInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xeb\",\"syscall_name\" : \"NtQueryInformationResourceManager\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManagerHandle\":\"0x%x\", \"ResourceManagerInformationClass\":\"0x%x\", \"ResourceManagerInformation\":\"0x%x\", \"ResourceManagerInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ResourceManagerHandle, ResourceManagerInformationClass, ResourceManagerInformation, ResourceManagerInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*236 NTSTATUS NtQueryInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);*/
void on_cb_NtQueryInformationThread_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t ThreadInformationClass, uint32_t ThreadInformation, uint32_t ThreadInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xec\",\"syscall_name\" : \"NtQueryInformationThread\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"ThreadInformationClass\":\"0x%x\", \"ThreadInformation\":\"0x%x\", \"ThreadInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryInformationThread_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t ThreadInformationClass, uint32_t ThreadInformation, uint32_t ThreadInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xec\",\"syscall_name\" : \"NtQueryInformationThread\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"ThreadInformationClass\":\"0x%x\", \"ThreadInformation\":\"0x%x\", \"ThreadInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*237 NTSTATUS NtQueryInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);*/
void on_cb_NtQueryInformationToken_enter(CPUState *cpu, target_ulong pc, uint32_t TokenHandle, uint32_t TokenInformationClass, uint32_t TokenInformation, uint32_t TokenInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xed\",\"syscall_name\" : \"NtQueryInformationToken\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TokenHandle\":\"0x%x\", \"TokenInformationClass\":\"0x%x\", \"TokenInformation\":\"0x%x\", \"TokenInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryInformationToken_return(CPUState *cpu, target_ulong pc, uint32_t TokenHandle, uint32_t TokenInformationClass, uint32_t TokenInformation, uint32_t TokenInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xed\",\"syscall_name\" : \"NtQueryInformationToken\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TokenHandle\":\"0x%x\", \"TokenInformationClass\":\"0x%x\", \"TokenInformation\":\"0x%x\", \"TokenInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*238 NTSTATUS NtQueryInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength, PULONG ReturnLength);*/
void on_cb_NtQueryInformationTransaction_enter(CPUState *cpu, target_ulong pc, uint32_t TransactionHandle, uint32_t TransactionInformationClass, uint32_t TransactionInformation, uint32_t TransactionInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xee\",\"syscall_name\" : \"NtQueryInformationTransaction\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionHandle\":\"0x%x\", \"TransactionInformationClass\":\"0x%x\", \"TransactionInformation\":\"0x%x\", \"TransactionInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TransactionHandle, TransactionInformationClass, TransactionInformation, TransactionInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryInformationTransaction_return(CPUState *cpu, target_ulong pc, uint32_t TransactionHandle, uint32_t TransactionInformationClass, uint32_t TransactionInformation, uint32_t TransactionInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xee\",\"syscall_name\" : \"NtQueryInformationTransaction\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionHandle\":\"0x%x\", \"TransactionInformationClass\":\"0x%x\", \"TransactionInformation\":\"0x%x\", \"TransactionInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TransactionHandle, TransactionInformationClass, TransactionInformation, TransactionInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*239 NTSTATUS NtQueryInformationTransactionManager (HANDLE TransactionManagerHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength, PULONG ReturnLength);*/
void on_cb_NtQueryInformationTransactionManager_enter(CPUState *cpu, target_ulong pc, uint32_t TransactionManagerHandle, uint32_t TransactionManagerInformationClass, uint32_t TransactionManagerInformation, uint32_t TransactionManagerInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xef\",\"syscall_name\" : \"NtQueryInformationTransactionManager\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionManagerHandle\":\"0x%x\", \"TransactionManagerInformationClass\":\"0x%x\", \"TransactionManagerInformation\":\"0x%x\", \"TransactionManagerInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TransactionManagerHandle, TransactionManagerInformationClass, TransactionManagerInformation, TransactionManagerInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryInformationTransactionManager_return(CPUState *cpu, target_ulong pc, uint32_t TransactionManagerHandle, uint32_t TransactionManagerInformationClass, uint32_t TransactionManagerInformation, uint32_t TransactionManagerInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xef\",\"syscall_name\" : \"NtQueryInformationTransactionManager\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionManagerHandle\":\"0x%x\", \"TransactionManagerInformationClass\":\"0x%x\", \"TransactionManagerInformation\":\"0x%x\", \"TransactionManagerInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TransactionManagerHandle, TransactionManagerInformationClass, TransactionManagerInformation, TransactionManagerInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*240 NTSTATUS NtQueryInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength, PULONG ReturnLength);*/
void on_cb_NtQueryInformationWorkerFactory_enter(CPUState *cpu, target_ulong pc, uint32_t WorkerFactoryHandle, uint32_t WorkerFactoryInformationClass, uint32_t WorkerFactoryInformation, uint32_t WorkerFactoryInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xf0\",\"syscall_name\" : \"NtQueryInformationWorkerFactory\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"WorkerFactoryHandle\":\"0x%x\", \"WorkerFactoryInformationClass\":\"0x%x\", \"WorkerFactoryInformation\":\"0x%x\", \"WorkerFactoryInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, WorkerFactoryHandle, WorkerFactoryInformationClass, WorkerFactoryInformation, WorkerFactoryInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryInformationWorkerFactory_return(CPUState *cpu, target_ulong pc, uint32_t WorkerFactoryHandle, uint32_t WorkerFactoryInformationClass, uint32_t WorkerFactoryInformation, uint32_t WorkerFactoryInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xf0\",\"syscall_name\" : \"NtQueryInformationWorkerFactory\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"WorkerFactoryHandle\":\"0x%x\", \"WorkerFactoryInformationClass\":\"0x%x\", \"WorkerFactoryInformation\":\"0x%x\", \"WorkerFactoryInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, WorkerFactoryHandle, WorkerFactoryInformationClass, WorkerFactoryInformation, WorkerFactoryInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*241 NTSTATUS NtQueryInstallUILanguage (LANGID *InstallUILanguageId);*/
void on_cb_NtQueryInstallUILanguage_enter(CPUState *cpu, target_ulong pc, uint32_t InstallUILanguageId) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xf1\",\"syscall_name\" : \"NtQueryInstallUILanguage\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"InstallUILanguageId\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, InstallUILanguageId, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = InstallUILanguageId;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = InstallUILanguageId;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LANGID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"InstallUILanguageId\" : ");dump_LANGID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"InstallUILanguageId\" : ");fprintf(outFile, "\"Unable to read InstallUILanguageId\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryInstallUILanguage_return(CPUState *cpu, target_ulong pc, uint32_t InstallUILanguageId) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xf1\",\"syscall_name\" : \"NtQueryInstallUILanguage\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"InstallUILanguageId\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, InstallUILanguageId, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = InstallUILanguageId;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = InstallUILanguageId;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LANGID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"InstallUILanguageId\" : ");dump_LANGID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"InstallUILanguageId\" : ");fprintf(outFile, "\"Unable to read InstallUILanguageId\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*242 NTSTATUS NtQueryIntervalProfile (KPROFILE_SOURCE ProfileSource, PULONG Interval);*/
void on_cb_NtQueryIntervalProfile_enter(CPUState *cpu, target_ulong pc, uint32_t ProfileSource, uint32_t Interval) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xf2\",\"syscall_name\" : \"NtQueryIntervalProfile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProfileSource\":\"0x%x\", \"Interval\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProfileSource, Interval, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Interval;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Interval;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Interval\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Interval\" : ");fprintf(outFile, "\"Unable to read Interval\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryIntervalProfile_return(CPUState *cpu, target_ulong pc, uint32_t ProfileSource, uint32_t Interval) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xf2\",\"syscall_name\" : \"NtQueryIntervalProfile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProfileSource\":\"0x%x\", \"Interval\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProfileSource, Interval, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Interval;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Interval;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Interval\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Interval\" : ");fprintf(outFile, "\"Unable to read Interval\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*243 NTSTATUS NtQueryIoCompletion (HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength);*/
void on_cb_NtQueryIoCompletion_enter(CPUState *cpu, target_ulong pc, uint32_t IoCompletionHandle, uint32_t IoCompletionInformationClass, uint32_t IoCompletionInformation, uint32_t IoCompletionInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xf3\",\"syscall_name\" : \"NtQueryIoCompletion\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"IoCompletionHandle\":\"0x%x\", \"IoCompletionInformationClass\":\"0x%x\", \"IoCompletionInformation\":\"0x%x\", \"IoCompletionInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, IoCompletionHandle, IoCompletionInformationClass, IoCompletionInformation, IoCompletionInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryIoCompletion_return(CPUState *cpu, target_ulong pc, uint32_t IoCompletionHandle, uint32_t IoCompletionInformationClass, uint32_t IoCompletionInformation, uint32_t IoCompletionInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xf3\",\"syscall_name\" : \"NtQueryIoCompletion\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"IoCompletionHandle\":\"0x%x\", \"IoCompletionInformationClass\":\"0x%x\", \"IoCompletionInformation\":\"0x%x\", \"IoCompletionInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, IoCompletionHandle, IoCompletionInformationClass, IoCompletionInformation, IoCompletionInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*244 NTSTATUS NtQueryKey (HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);*/
void on_cb_NtQueryKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t KeyInformationClass, uint32_t KeyInformation, uint32_t Length, uint32_t ResultLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xf4\",\"syscall_name\" : \"NtQueryKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"KeyInformationClass\":\"0x%x\", \"KeyInformation\":\"0x%x\", \"Length\":\"0x%x\", \"ResultLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, KeyInformationClass, KeyInformation, Length, ResultLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ResultLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ResultLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ResultLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ResultLength\" : ");fprintf(outFile, "\"Unable to read ResultLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t KeyInformationClass, uint32_t KeyInformation, uint32_t Length, uint32_t ResultLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xf4\",\"syscall_name\" : \"NtQueryKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"KeyInformationClass\":\"0x%x\", \"KeyInformation\":\"0x%x\", \"Length\":\"0x%x\", \"ResultLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, KeyInformationClass, KeyInformation, Length, ResultLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ResultLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ResultLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ResultLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ResultLength\" : ");fprintf(outFile, "\"Unable to read ResultLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*245 NTSTATUS NtQueryLicenseValue (PUNICODE_STRING Name, PULONG Type, PVOID Buffer, ULONG Length, PULONG ReturnedLength);*/
void on_cb_NtQueryLicenseValue_enter(CPUState *cpu, target_ulong pc, uint32_t Name, uint32_t Type, uint32_t Buffer, uint32_t Length, uint32_t ReturnedLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xf5\",\"syscall_name\" : \"NtQueryLicenseValue\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Name\":\"0x%x\", \"Type\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\", \"ReturnedLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Name, Type, Buffer, Length, ReturnedLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Name;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Name;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Name\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Name\" : ");fprintf(outFile, "\"Unable to read Name\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Type;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Type;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Type\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Type\" : ");fprintf(outFile, "\"Unable to read Type\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ReturnedLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnedLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnedLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnedLength\" : ");fprintf(outFile, "\"Unable to read ReturnedLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryLicenseValue_return(CPUState *cpu, target_ulong pc, uint32_t Name, uint32_t Type, uint32_t Buffer, uint32_t Length, uint32_t ReturnedLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xf5\",\"syscall_name\" : \"NtQueryLicenseValue\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Name\":\"0x%x\", \"Type\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\", \"ReturnedLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Name, Type, Buffer, Length, ReturnedLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Name;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Name;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Name\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Name\" : ");fprintf(outFile, "\"Unable to read Name\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Type;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Type;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Type\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Type\" : ");fprintf(outFile, "\"Unable to read Type\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ReturnedLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnedLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnedLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnedLength\" : ");fprintf(outFile, "\"Unable to read ReturnedLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*246 NTSTATUS NtQueryMultipleValueKey (HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength);*/
void on_cb_NtQueryMultipleValueKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t ValueEntries, uint32_t EntryCount, uint32_t ValueBuffer, uint32_t BufferLength, uint32_t RequiredBufferLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xf6\",\"syscall_name\" : \"NtQueryMultipleValueKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"ValueEntries\":\"0x%x\", \"EntryCount\":\"0x%x\", \"ValueBuffer\":\"0x%x\", \"BufferLength\":\"0x%x\", \"RequiredBufferLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, ValueEntries, EntryCount, ValueBuffer, BufferLength, RequiredBufferLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BufferLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BufferLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BufferLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BufferLength\" : ");fprintf(outFile, "\"Unable to read BufferLength\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = RequiredBufferLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = RequiredBufferLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"RequiredBufferLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"RequiredBufferLength\" : ");fprintf(outFile, "\"Unable to read RequiredBufferLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryMultipleValueKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t ValueEntries, uint32_t EntryCount, uint32_t ValueBuffer, uint32_t BufferLength, uint32_t RequiredBufferLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xf6\",\"syscall_name\" : \"NtQueryMultipleValueKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"ValueEntries\":\"0x%x\", \"EntryCount\":\"0x%x\", \"ValueBuffer\":\"0x%x\", \"BufferLength\":\"0x%x\", \"RequiredBufferLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, ValueEntries, EntryCount, ValueBuffer, BufferLength, RequiredBufferLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BufferLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BufferLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BufferLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BufferLength\" : ");fprintf(outFile, "\"Unable to read BufferLength\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = RequiredBufferLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = RequiredBufferLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"RequiredBufferLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"RequiredBufferLength\" : ");fprintf(outFile, "\"Unable to read RequiredBufferLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*247 NTSTATUS NtQueryMutant (HANDLE MutantHandle, MUTANT_INFORMATION_CLASS MutantInformationClass, PVOID MutantInformation, ULONG MutantInformationLength, PULONG ReturnLength);*/
void on_cb_NtQueryMutant_enter(CPUState *cpu, target_ulong pc, uint32_t MutantHandle, uint32_t MutantInformationClass, uint32_t MutantInformation, uint32_t MutantInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xf7\",\"syscall_name\" : \"NtQueryMutant\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"MutantHandle\":\"0x%x\", \"MutantInformationClass\":\"0x%x\", \"MutantInformation\":\"0x%x\", \"MutantInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, MutantHandle, MutantInformationClass, MutantInformation, MutantInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryMutant_return(CPUState *cpu, target_ulong pc, uint32_t MutantHandle, uint32_t MutantInformationClass, uint32_t MutantInformation, uint32_t MutantInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xf7\",\"syscall_name\" : \"NtQueryMutant\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"MutantHandle\":\"0x%x\", \"MutantInformationClass\":\"0x%x\", \"MutantInformation\":\"0x%x\", \"MutantInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, MutantHandle, MutantInformationClass, MutantInformation, MutantInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*248 NTSTATUS NtQueryObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);*/
void on_cb_NtQueryObject_enter(CPUState *cpu, target_ulong pc, uint32_t Handle, uint32_t ObjectInformationClass, uint32_t ObjectInformation, uint32_t ObjectInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xf8\",\"syscall_name\" : \"NtQueryObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Handle\":\"0x%x\", \"ObjectInformationClass\":\"0x%x\", \"ObjectInformation\":\"0x%x\", \"ObjectInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Handle, ObjectInformationClass, ObjectInformation, ObjectInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryObject_return(CPUState *cpu, target_ulong pc, uint32_t Handle, uint32_t ObjectInformationClass, uint32_t ObjectInformation, uint32_t ObjectInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xf8\",\"syscall_name\" : \"NtQueryObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Handle\":\"0x%x\", \"ObjectInformationClass\":\"0x%x\", \"ObjectInformation\":\"0x%x\", \"ObjectInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Handle, ObjectInformationClass, ObjectInformation, ObjectInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*249 NTSTATUS NtQueryOpenSubKeys (POBJECT_ATTRIBUTES TargetKey, PULONG HandleCount);*/
void on_cb_NtQueryOpenSubKeys_enter(CPUState *cpu, target_ulong pc, uint32_t TargetKey, uint32_t HandleCount) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xf9\",\"syscall_name\" : \"NtQueryOpenSubKeys\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetKey\":\"0x%x\", \"HandleCount\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TargetKey, HandleCount, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetKey;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetKey;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetKey\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetKey\" : ");fprintf(outFile, "\"Unable to read TargetKey\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = HandleCount;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = HandleCount;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"HandleCount\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"HandleCount\" : ");fprintf(outFile, "\"Unable to read HandleCount\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryOpenSubKeys_return(CPUState *cpu, target_ulong pc, uint32_t TargetKey, uint32_t HandleCount) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xf9\",\"syscall_name\" : \"NtQueryOpenSubKeys\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetKey\":\"0x%x\", \"HandleCount\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TargetKey, HandleCount, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetKey;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetKey;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetKey\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetKey\" : ");fprintf(outFile, "\"Unable to read TargetKey\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = HandleCount;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = HandleCount;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"HandleCount\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"HandleCount\" : ");fprintf(outFile, "\"Unable to read HandleCount\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*250 NTSTATUS NtQueryOpenSubKeysEx (POBJECT_ATTRIBUTES TargetKey, ULONG BufferLength, PVOID Buffer, PULONG RequiredSize);*/
void on_cb_NtQueryOpenSubKeysEx_enter(CPUState *cpu, target_ulong pc, uint32_t TargetKey, uint32_t BufferLength, uint32_t Buffer, uint32_t RequiredSize) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xfa\",\"syscall_name\" : \"NtQueryOpenSubKeysEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetKey\":\"0x%x\", \"BufferLength\":\"0x%x\", \"Buffer\":\"0x%x\", \"RequiredSize\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TargetKey, BufferLength, Buffer, RequiredSize, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetKey;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetKey;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetKey\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetKey\" : ");fprintf(outFile, "\"Unable to read TargetKey\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = RequiredSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = RequiredSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"RequiredSize\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"RequiredSize\" : ");fprintf(outFile, "\"Unable to read RequiredSize\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryOpenSubKeysEx_return(CPUState *cpu, target_ulong pc, uint32_t TargetKey, uint32_t BufferLength, uint32_t Buffer, uint32_t RequiredSize) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xfa\",\"syscall_name\" : \"NtQueryOpenSubKeysEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetKey\":\"0x%x\", \"BufferLength\":\"0x%x\", \"Buffer\":\"0x%x\", \"RequiredSize\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TargetKey, BufferLength, Buffer, RequiredSize, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetKey;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetKey;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetKey\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetKey\" : ");fprintf(outFile, "\"Unable to read TargetKey\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = RequiredSize;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = RequiredSize;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"RequiredSize\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"RequiredSize\" : ");fprintf(outFile, "\"Unable to read RequiredSize\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*251 NTSTATUS NtQueryPerformanceCounter (PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);*/
void on_cb_NtQueryPerformanceCounter_enter(CPUState *cpu, target_ulong pc, uint32_t PerformanceCounter, uint32_t PerformanceFrequency) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xfb\",\"syscall_name\" : \"NtQueryPerformanceCounter\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PerformanceCounter\":\"0x%x\", \"PerformanceFrequency\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PerformanceCounter, PerformanceFrequency, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PerformanceCounter;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PerformanceCounter;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PerformanceCounter\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PerformanceCounter\" : ");fprintf(outFile, "\"Unable to read PerformanceCounter\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = PerformanceFrequency;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PerformanceFrequency;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PerformanceFrequency\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PerformanceFrequency\" : ");fprintf(outFile, "\"Unable to read PerformanceFrequency\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryPerformanceCounter_return(CPUState *cpu, target_ulong pc, uint32_t PerformanceCounter, uint32_t PerformanceFrequency) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xfb\",\"syscall_name\" : \"NtQueryPerformanceCounter\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PerformanceCounter\":\"0x%x\", \"PerformanceFrequency\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PerformanceCounter, PerformanceFrequency, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PerformanceCounter;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PerformanceCounter;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PerformanceCounter\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PerformanceCounter\" : ");fprintf(outFile, "\"Unable to read PerformanceCounter\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = PerformanceFrequency;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PerformanceFrequency;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PerformanceFrequency\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PerformanceFrequency\" : ");fprintf(outFile, "\"Unable to read PerformanceFrequency\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*252 NTSTATUS NtQueryPortInformationProcess ();*/
void on_cb_NtQueryPortInformationProcess_enter(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xfc\",\"syscall_name\" : \"NtQueryPortInformationProcess\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryPortInformationProcess_return(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xfc\",\"syscall_name\" : \"NtQueryPortInformationProcess\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*253 NTSTATUS NtQueryQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID SidList, ULONG SidListLength, PULONG StartSid, BOOLEAN RestartScan);*/
void on_cb_NtQueryQuotaInformationFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t Buffer, uint32_t Length, uint32_t ReturnSingleEntry, uint32_t SidList, uint32_t SidListLength, uint32_t StartSid, uint32_t RestartScan) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xfd\",\"syscall_name\" : \"NtQueryQuotaInformationFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\", \"ReturnSingleEntry\":\"0x%x\", \"SidList\":\"0x%x\", \"SidListLength\":\"0x%x\", \"StartSid\":\"0x%x\", \"RestartScan\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, Buffer, Length, ReturnSingleEntry, SidList, SidListLength, StartSid, RestartScan, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = StartSid;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = StartSid;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"StartSid\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"StartSid\" : ");fprintf(outFile, "\"Unable to read StartSid\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryQuotaInformationFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t Buffer, uint32_t Length, uint32_t ReturnSingleEntry, uint32_t SidList, uint32_t SidListLength, uint32_t StartSid, uint32_t RestartScan) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xfd\",\"syscall_name\" : \"NtQueryQuotaInformationFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\", \"ReturnSingleEntry\":\"0x%x\", \"SidList\":\"0x%x\", \"SidListLength\":\"0x%x\", \"StartSid\":\"0x%x\", \"RestartScan\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, Buffer, Length, ReturnSingleEntry, SidList, SidListLength, StartSid, RestartScan, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = StartSid;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = StartSid;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"StartSid\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"StartSid\" : ");fprintf(outFile, "\"Unable to read StartSid\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*254 NTSTATUS NtQuerySection (HANDLE SectionHandle, SECTION_INFORMATION_CLASS SectionInformationClass, PVOID SectionInformation, SIZE_T SectionInformationLength, PSIZE_T ReturnLength);*/
void on_cb_NtQuerySection_enter(CPUState *cpu, target_ulong pc, uint32_t SectionHandle, uint32_t SectionInformationClass, uint32_t SectionInformation, uint32_t SectionInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xfe\",\"syscall_name\" : \"NtQuerySection\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SectionHandle\":\"0x%x\", \"SectionInformationClass\":\"0x%x\", \"SectionInformation\":\"0x%x\", \"SectionInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SectionHandle, SectionInformationClass, SectionInformation, SectionInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQuerySection_return(CPUState *cpu, target_ulong pc, uint32_t SectionHandle, uint32_t SectionInformationClass, uint32_t SectionInformation, uint32_t SectionInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xfe\",\"syscall_name\" : \"NtQuerySection\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SectionHandle\":\"0x%x\", \"SectionInformationClass\":\"0x%x\", \"SectionInformation\":\"0x%x\", \"SectionInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SectionHandle, SectionInformationClass, SectionInformation, SectionInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*255 NTSTATUS NtQuerySecurityAttributesToken (HANDLE TokenHandle, PUNICODE_STRING Attributes, ULONG NumberOfAttributes, PVOID Buffer, ULONG Length, PULONG ReturnLength);*/
void on_cb_NtQuerySecurityAttributesToken_enter(CPUState *cpu, target_ulong pc, uint32_t TokenHandle, uint32_t Attributes, uint32_t NumberOfAttributes, uint32_t Buffer, uint32_t Length, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0xff\",\"syscall_name\" : \"NtQuerySecurityAttributesToken\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TokenHandle\":\"0x%x\", \"Attributes\":\"0x%x\", \"NumberOfAttributes\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TokenHandle, Attributes, NumberOfAttributes, Buffer, Length, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Attributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Attributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Attributes\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Attributes\" : ");fprintf(outFile, "\"Unable to read Attributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQuerySecurityAttributesToken_return(CPUState *cpu, target_ulong pc, uint32_t TokenHandle, uint32_t Attributes, uint32_t NumberOfAttributes, uint32_t Buffer, uint32_t Length, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0xff\",\"syscall_name\" : \"NtQuerySecurityAttributesToken\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TokenHandle\":\"0x%x\", \"Attributes\":\"0x%x\", \"NumberOfAttributes\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TokenHandle, Attributes, NumberOfAttributes, Buffer, Length, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Attributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Attributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Attributes\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Attributes\" : ");fprintf(outFile, "\"Unable to read Attributes\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*256 NTSTATUS NtQuerySecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Length, PULONG LengthNeeded);*/
void on_cb_NtQuerySecurityObject_enter(CPUState *cpu, target_ulong pc, uint32_t Handle, uint32_t SecurityInformation, uint32_t SecurityDescriptor, uint32_t Length, uint32_t LengthNeeded) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x100\",\"syscall_name\" : \"NtQuerySecurityObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Handle\":\"0x%x\", \"SecurityInformation\":\"0x%x\", \"SecurityDescriptor\":\"0x%x\", \"Length\":\"0x%x\", \"LengthNeeded\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Handle, SecurityInformation, SecurityDescriptor, Length, LengthNeeded, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = LengthNeeded;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = LengthNeeded;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"LengthNeeded\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"LengthNeeded\" : ");fprintf(outFile, "\"Unable to read LengthNeeded\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQuerySecurityObject_return(CPUState *cpu, target_ulong pc, uint32_t Handle, uint32_t SecurityInformation, uint32_t SecurityDescriptor, uint32_t Length, uint32_t LengthNeeded) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x100\",\"syscall_name\" : \"NtQuerySecurityObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Handle\":\"0x%x\", \"SecurityInformation\":\"0x%x\", \"SecurityDescriptor\":\"0x%x\", \"Length\":\"0x%x\", \"LengthNeeded\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Handle, SecurityInformation, SecurityDescriptor, Length, LengthNeeded, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = LengthNeeded;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = LengthNeeded;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"LengthNeeded\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"LengthNeeded\" : ");fprintf(outFile, "\"Unable to read LengthNeeded\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*257 NTSTATUS NtQuerySemaphore (HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG SemaphoreInformationLength, PULONG ReturnLength);*/
void on_cb_NtQuerySemaphore_enter(CPUState *cpu, target_ulong pc, uint32_t SemaphoreHandle, uint32_t SemaphoreInformationClass, uint32_t SemaphoreInformation, uint32_t SemaphoreInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x101\",\"syscall_name\" : \"NtQuerySemaphore\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SemaphoreHandle\":\"0x%x\", \"SemaphoreInformationClass\":\"0x%x\", \"SemaphoreInformation\":\"0x%x\", \"SemaphoreInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SemaphoreHandle, SemaphoreInformationClass, SemaphoreInformation, SemaphoreInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQuerySemaphore_return(CPUState *cpu, target_ulong pc, uint32_t SemaphoreHandle, uint32_t SemaphoreInformationClass, uint32_t SemaphoreInformation, uint32_t SemaphoreInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x101\",\"syscall_name\" : \"NtQuerySemaphore\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SemaphoreHandle\":\"0x%x\", \"SemaphoreInformationClass\":\"0x%x\", \"SemaphoreInformation\":\"0x%x\", \"SemaphoreInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SemaphoreHandle, SemaphoreInformationClass, SemaphoreInformation, SemaphoreInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*258 NTSTATUS NtQuerySymbolicLinkObject (HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength);*/
void on_cb_NtQuerySymbolicLinkObject_enter(CPUState *cpu, target_ulong pc, uint32_t LinkHandle, uint32_t LinkTarget, uint32_t ReturnedLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x102\",\"syscall_name\" : \"NtQuerySymbolicLinkObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"LinkHandle\":\"0x%x\", \"LinkTarget\":\"0x%x\", \"ReturnedLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, LinkHandle, LinkTarget, ReturnedLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = LinkTarget;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = LinkTarget;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"LinkTarget\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"LinkTarget\" : ");fprintf(outFile, "\"Unable to read LinkTarget\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ReturnedLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnedLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnedLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnedLength\" : ");fprintf(outFile, "\"Unable to read ReturnedLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQuerySymbolicLinkObject_return(CPUState *cpu, target_ulong pc, uint32_t LinkHandle, uint32_t LinkTarget, uint32_t ReturnedLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x102\",\"syscall_name\" : \"NtQuerySymbolicLinkObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"LinkHandle\":\"0x%x\", \"LinkTarget\":\"0x%x\", \"ReturnedLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, LinkHandle, LinkTarget, ReturnedLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = LinkTarget;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = LinkTarget;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"LinkTarget\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"LinkTarget\" : ");fprintf(outFile, "\"Unable to read LinkTarget\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ReturnedLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnedLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnedLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnedLength\" : ");fprintf(outFile, "\"Unable to read ReturnedLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*259 NTSTATUS NtQuerySystemEnvironmentValue (PUNICODE_STRING VariableName, PWSTR VariableValue, ULONG ValueLength, PUSHORT ReturnLength);*/
void on_cb_NtQuerySystemEnvironmentValue_enter(CPUState *cpu, target_ulong pc, uint32_t VariableName, uint32_t VariableValue, uint32_t ValueLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x103\",\"syscall_name\" : \"NtQuerySystemEnvironmentValue\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"VariableName\":\"0x%x\", \"VariableValue\":\"0x%x\", \"ValueLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, VariableName, VariableValue, ValueLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = VariableName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = VariableName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"VariableName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"VariableName\" : ");fprintf(outFile, "\"Unable to read VariableName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQuerySystemEnvironmentValue_return(CPUState *cpu, target_ulong pc, uint32_t VariableName, uint32_t VariableValue, uint32_t ValueLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x103\",\"syscall_name\" : \"NtQuerySystemEnvironmentValue\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"VariableName\":\"0x%x\", \"VariableValue\":\"0x%x\", \"ValueLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, VariableName, VariableValue, ValueLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = VariableName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = VariableName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"VariableName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"VariableName\" : ");fprintf(outFile, "\"Unable to read VariableName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*260 NTSTATUS NtQuerySystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes);*/
void on_cb_NtQuerySystemEnvironmentValueEx_enter(CPUState *cpu, target_ulong pc, uint32_t VariableName, uint32_t VendorGuid, uint32_t Value, uint32_t ValueLength, uint32_t Attributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x104\",\"syscall_name\" : \"NtQuerySystemEnvironmentValueEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"VariableName\":\"0x%x\", \"VendorGuid\":\"0x%x\", \"Value\":\"0x%x\", \"ValueLength\":\"0x%x\", \"Attributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, VariableName, VendorGuid, Value, ValueLength, Attributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = VariableName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = VariableName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"VariableName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"VariableName\" : ");fprintf(outFile, "\"Unable to read VariableName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ValueLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ValueLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ValueLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ValueLength\" : ");fprintf(outFile, "\"Unable to read ValueLength\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Attributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Attributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Attributes\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Attributes\" : ");fprintf(outFile, "\"Unable to read Attributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQuerySystemEnvironmentValueEx_return(CPUState *cpu, target_ulong pc, uint32_t VariableName, uint32_t VendorGuid, uint32_t Value, uint32_t ValueLength, uint32_t Attributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x104\",\"syscall_name\" : \"NtQuerySystemEnvironmentValueEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"VariableName\":\"0x%x\", \"VendorGuid\":\"0x%x\", \"Value\":\"0x%x\", \"ValueLength\":\"0x%x\", \"Attributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, VariableName, VendorGuid, Value, ValueLength, Attributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = VariableName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = VariableName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"VariableName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"VariableName\" : ");fprintf(outFile, "\"Unable to read VariableName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ValueLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ValueLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ValueLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ValueLength\" : ");fprintf(outFile, "\"Unable to read ValueLength\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Attributes;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Attributes;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Attributes\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Attributes\" : ");fprintf(outFile, "\"Unable to read Attributes\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*261 NTSTATUS NtQuerySystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);*/
void on_cb_NtQuerySystemInformation_enter(CPUState *cpu, target_ulong pc, uint32_t SystemInformationClass, uint32_t SystemInformation, uint32_t SystemInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x105\",\"syscall_name\" : \"NtQuerySystemInformation\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SystemInformationClass\":\"0x%x\", \"SystemInformation\":\"0x%x\", \"SystemInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQuerySystemInformation_return(CPUState *cpu, target_ulong pc, uint32_t SystemInformationClass, uint32_t SystemInformation, uint32_t SystemInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x105\",\"syscall_name\" : \"NtQuerySystemInformation\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SystemInformationClass\":\"0x%x\", \"SystemInformation\":\"0x%x\", \"SystemInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*262 NTSTATUS NtQuerySystemInformationEx (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID QueryInformation, ULONG QueryInformationLength, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);*/
void on_cb_NtQuerySystemInformationEx_enter(CPUState *cpu, target_ulong pc, uint32_t SystemInformationClass, uint32_t QueryInformation, uint32_t QueryInformationLength, uint32_t SystemInformation, uint32_t SystemInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x106\",\"syscall_name\" : \"NtQuerySystemInformationEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SystemInformationClass\":\"0x%x\", \"QueryInformation\":\"0x%x\", \"QueryInformationLength\":\"0x%x\", \"SystemInformation\":\"0x%x\", \"SystemInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SystemInformationClass, QueryInformation, QueryInformationLength, SystemInformation, SystemInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQuerySystemInformationEx_return(CPUState *cpu, target_ulong pc, uint32_t SystemInformationClass, uint32_t QueryInformation, uint32_t QueryInformationLength, uint32_t SystemInformation, uint32_t SystemInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x106\",\"syscall_name\" : \"NtQuerySystemInformationEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SystemInformationClass\":\"0x%x\", \"QueryInformation\":\"0x%x\", \"QueryInformationLength\":\"0x%x\", \"SystemInformation\":\"0x%x\", \"SystemInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SystemInformationClass, QueryInformation, QueryInformationLength, SystemInformation, SystemInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*263 NTSTATUS NtQuerySystemTime (PLARGE_INTEGER SystemTime);*/
void on_cb_NtQuerySystemTime_enter(CPUState *cpu, target_ulong pc, uint32_t SystemTime) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x107\",\"syscall_name\" : \"NtQuerySystemTime\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SystemTime\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SystemTime, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SystemTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SystemTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SystemTime\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SystemTime\" : ");fprintf(outFile, "\"Unable to read SystemTime\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQuerySystemTime_return(CPUState *cpu, target_ulong pc, uint32_t SystemTime) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x107\",\"syscall_name\" : \"NtQuerySystemTime\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SystemTime\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SystemTime, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SystemTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SystemTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SystemTime\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SystemTime\" : ");fprintf(outFile, "\"Unable to read SystemTime\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*264 NTSTATUS NtQueryTimer (HANDLE TimerHandle, TIMER_INFORMATION_CLASS TimerInformationClass, PVOID TimerInformation, ULONG TimerInformationLength, PULONG ReturnLength);*/
void on_cb_NtQueryTimer_enter(CPUState *cpu, target_ulong pc, uint32_t TimerHandle, uint32_t TimerInformationClass, uint32_t TimerInformation, uint32_t TimerInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x108\",\"syscall_name\" : \"NtQueryTimer\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TimerHandle\":\"0x%x\", \"TimerInformationClass\":\"0x%x\", \"TimerInformation\":\"0x%x\", \"TimerInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TimerHandle, TimerInformationClass, TimerInformation, TimerInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryTimer_return(CPUState *cpu, target_ulong pc, uint32_t TimerHandle, uint32_t TimerInformationClass, uint32_t TimerInformation, uint32_t TimerInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x108\",\"syscall_name\" : \"NtQueryTimer\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TimerHandle\":\"0x%x\", \"TimerInformationClass\":\"0x%x\", \"TimerInformation\":\"0x%x\", \"TimerInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TimerHandle, TimerInformationClass, TimerInformation, TimerInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*265 NTSTATUS NtQueryTimerResolution (PULONG MaximumTime, PULONG MinimumTime, PULONG CurrentTime);*/
void on_cb_NtQueryTimerResolution_enter(CPUState *cpu, target_ulong pc, uint32_t MaximumTime, uint32_t MinimumTime, uint32_t CurrentTime) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x109\",\"syscall_name\" : \"NtQueryTimerResolution\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"MaximumTime\":\"0x%x\", \"MinimumTime\":\"0x%x\", \"CurrentTime\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, MaximumTime, MinimumTime, CurrentTime, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = MaximumTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MaximumTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MaximumTime\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MaximumTime\" : ");fprintf(outFile, "\"Unable to read MaximumTime\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = MinimumTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MinimumTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MinimumTime\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MinimumTime\" : ");fprintf(outFile, "\"Unable to read MinimumTime\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = CurrentTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = CurrentTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"CurrentTime\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"CurrentTime\" : ");fprintf(outFile, "\"Unable to read CurrentTime\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryTimerResolution_return(CPUState *cpu, target_ulong pc, uint32_t MaximumTime, uint32_t MinimumTime, uint32_t CurrentTime) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x109\",\"syscall_name\" : \"NtQueryTimerResolution\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"MaximumTime\":\"0x%x\", \"MinimumTime\":\"0x%x\", \"CurrentTime\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, MaximumTime, MinimumTime, CurrentTime, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = MaximumTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MaximumTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MaximumTime\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MaximumTime\" : ");fprintf(outFile, "\"Unable to read MaximumTime\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = MinimumTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MinimumTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MinimumTime\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MinimumTime\" : ");fprintf(outFile, "\"Unable to read MinimumTime\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = CurrentTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = CurrentTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"CurrentTime\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"CurrentTime\" : ");fprintf(outFile, "\"Unable to read CurrentTime\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*266 NTSTATUS NtQueryValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);*/
void on_cb_NtQueryValueKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t ValueName, uint32_t KeyValueInformationClass, uint32_t KeyValueInformation, uint32_t Length, uint32_t ResultLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x10a\",\"syscall_name\" : \"NtQueryValueKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"ValueName\":\"0x%x\", \"KeyValueInformationClass\":\"0x%x\", \"KeyValueInformation\":\"0x%x\", \"Length\":\"0x%x\", \"ResultLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, ValueName, KeyValueInformationClass, KeyValueInformation, Length, ResultLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ValueName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ValueName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ValueName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ValueName\" : ");fprintf(outFile, "\"Unable to read ValueName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ResultLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ResultLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ResultLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ResultLength\" : ");fprintf(outFile, "\"Unable to read ResultLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryValueKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t ValueName, uint32_t KeyValueInformationClass, uint32_t KeyValueInformation, uint32_t Length, uint32_t ResultLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x10a\",\"syscall_name\" : \"NtQueryValueKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"ValueName\":\"0x%x\", \"KeyValueInformationClass\":\"0x%x\", \"KeyValueInformation\":\"0x%x\", \"Length\":\"0x%x\", \"ResultLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, ValueName, KeyValueInformationClass, KeyValueInformation, Length, ResultLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ValueName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ValueName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ValueName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ValueName\" : ");fprintf(outFile, "\"Unable to read ValueName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ResultLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ResultLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ResultLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ResultLength\" : ");fprintf(outFile, "\"Unable to read ResultLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*267 NTSTATUS NtQueryVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);*/
void on_cb_NtQueryVirtualMemory_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t MemoryInformationClass, uint32_t MemoryInformation, uint32_t MemoryInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x10b\",\"syscall_name\" : \"NtQueryVirtualMemory\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"MemoryInformationClass\":\"0x%x\", \"MemoryInformation\":\"0x%x\", \"MemoryInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, MemoryInformationClass, MemoryInformation, MemoryInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryVirtualMemory_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t MemoryInformationClass, uint32_t MemoryInformation, uint32_t MemoryInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x10b\",\"syscall_name\" : \"NtQueryVirtualMemory\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"MemoryInformationClass\":\"0x%x\", \"MemoryInformation\":\"0x%x\", \"MemoryInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, MemoryInformationClass, MemoryInformation, MemoryInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*268 NTSTATUS NtQueryVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);*/
void on_cb_NtQueryVolumeInformationFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t FsInformation, uint32_t Length, uint32_t FsInformationClass) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x10c\",\"syscall_name\" : \"NtQueryVolumeInformationFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"FsInformation\":\"0x%x\", \"Length\":\"0x%x\", \"FsInformationClass\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, FsInformation, Length, FsInformationClass, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueryVolumeInformationFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t FsInformation, uint32_t Length, uint32_t FsInformationClass) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x10c\",\"syscall_name\" : \"NtQueryVolumeInformationFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"FsInformation\":\"0x%x\", \"Length\":\"0x%x\", \"FsInformationClass\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, FsInformation, Length, FsInformationClass, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*269 NTSTATUS NtQueueApcThread (HANDLE ThreadHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);*/
void on_cb_NtQueueApcThread_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t ApcRoutine, uint32_t ApcArgument1, uint32_t ApcArgument2, uint32_t ApcArgument3) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x10d\",\"syscall_name\" : \"NtQueueApcThread\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcArgument1\":\"0x%x\", \"ApcArgument2\":\"0x%x\", \"ApcArgument3\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, ApcRoutine, ApcArgument1, ApcArgument2, ApcArgument3, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueueApcThread_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t ApcRoutine, uint32_t ApcArgument1, uint32_t ApcArgument2, uint32_t ApcArgument3) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x10d\",\"syscall_name\" : \"NtQueueApcThread\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcArgument1\":\"0x%x\", \"ApcArgument2\":\"0x%x\", \"ApcArgument3\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, ApcRoutine, ApcArgument1, ApcArgument2, ApcArgument3, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*270 NTSTATUS NtQueueApcThreadEx (HANDLE ThreadHandle, HANDLE UserApcReserveHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);*/
void on_cb_NtQueueApcThreadEx_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t UserApcReserveHandle, uint32_t ApcRoutine, uint32_t ApcArgument1, uint32_t ApcArgument2, uint32_t ApcArgument3) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x10e\",\"syscall_name\" : \"NtQueueApcThreadEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"UserApcReserveHandle\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcArgument1\":\"0x%x\", \"ApcArgument2\":\"0x%x\", \"ApcArgument3\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, UserApcReserveHandle, ApcRoutine, ApcArgument1, ApcArgument2, ApcArgument3, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtQueueApcThreadEx_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t UserApcReserveHandle, uint32_t ApcRoutine, uint32_t ApcArgument1, uint32_t ApcArgument2, uint32_t ApcArgument3) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x10e\",\"syscall_name\" : \"NtQueueApcThreadEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"UserApcReserveHandle\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcArgument1\":\"0x%x\", \"ApcArgument2\":\"0x%x\", \"ApcArgument3\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, UserApcReserveHandle, ApcRoutine, ApcArgument1, ApcArgument2, ApcArgument3, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*271 NTSTATUS NtRaiseException (PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ContextRecord, BOOLEAN FirstChance);*/
void on_cb_NtRaiseException_enter(CPUState *cpu, target_ulong pc, uint32_t ExceptionRecord, uint32_t ContextRecord, uint32_t FirstChance) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x10f\",\"syscall_name\" : \"NtRaiseException\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ExceptionRecord\":\"0x%x\", \"ContextRecord\":\"0x%x\", \"FirstChance\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ExceptionRecord, ContextRecord, FirstChance, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRaiseException_return(CPUState *cpu, target_ulong pc, uint32_t ExceptionRecord, uint32_t ContextRecord, uint32_t FirstChance) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x10f\",\"syscall_name\" : \"NtRaiseException\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ExceptionRecord\":\"0x%x\", \"ContextRecord\":\"0x%x\", \"FirstChance\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ExceptionRecord, ContextRecord, FirstChance, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*272 NTSTATUS NtRaiseHardError (NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response);*/
void on_cb_NtRaiseHardError_enter(CPUState *cpu, target_ulong pc, uint32_t ErrorStatus, uint32_t NumberOfParameters, uint32_t UnicodeStringParameterMask, uint32_t Parameters, uint32_t ValidResponseOptions, uint32_t Response) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x110\",\"syscall_name\" : \"NtRaiseHardError\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ErrorStatus\":\"0x%x\", \"NumberOfParameters\":\"0x%x\", \"UnicodeStringParameterMask\":\"0x%x\", \"Parameters\":\"0x%x\", \"ValidResponseOptions\":\"0x%x\", \"Response\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ErrorStatus, NumberOfParameters, UnicodeStringParameterMask, Parameters, ValidResponseOptions, Response, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Response;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Response;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Response\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Response\" : ");fprintf(outFile, "\"Unable to read Response\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRaiseHardError_return(CPUState *cpu, target_ulong pc, uint32_t ErrorStatus, uint32_t NumberOfParameters, uint32_t UnicodeStringParameterMask, uint32_t Parameters, uint32_t ValidResponseOptions, uint32_t Response) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x110\",\"syscall_name\" : \"NtRaiseHardError\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ErrorStatus\":\"0x%x\", \"NumberOfParameters\":\"0x%x\", \"UnicodeStringParameterMask\":\"0x%x\", \"Parameters\":\"0x%x\", \"ValidResponseOptions\":\"0x%x\", \"Response\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ErrorStatus, NumberOfParameters, UnicodeStringParameterMask, Parameters, ValidResponseOptions, Response, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Response;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Response;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Response\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Response\" : ");fprintf(outFile, "\"Unable to read Response\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*273 NTSTATUS NtReadFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);*/
void on_cb_NtReadFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t Buffer, uint32_t Length, uint32_t ByteOffset, uint32_t Key) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x111\",\"syscall_name\" : \"NtReadFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\", \"ByteOffset\":\"0x%x\", \"Key\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, ByteOffset, Key, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ByteOffset;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ByteOffset;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ByteOffset\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ByteOffset\" : ");fprintf(outFile, "\"Unable to read ByteOffset\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Key;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Key;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Key\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Key\" : ");fprintf(outFile, "\"Unable to read Key\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtReadFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t Buffer, uint32_t Length, uint32_t ByteOffset, uint32_t Key) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x111\",\"syscall_name\" : \"NtReadFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\", \"ByteOffset\":\"0x%x\", \"Key\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, ByteOffset, Key, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ByteOffset;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ByteOffset;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ByteOffset\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ByteOffset\" : ");fprintf(outFile, "\"Unable to read ByteOffset\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Key;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Key;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Key\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Key\" : ");fprintf(outFile, "\"Unable to read Key\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*274 NTSTATUS NtReadFileScatter (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);*/
void on_cb_NtReadFileScatter_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t SegmentArray, uint32_t Length, uint32_t ByteOffset, uint32_t Key) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x112\",\"syscall_name\" : \"NtReadFileScatter\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"SegmentArray\":\"0x%x\", \"Length\":\"0x%x\", \"ByteOffset\":\"0x%x\", \"Key\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, SegmentArray, Length, ByteOffset, Key, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ByteOffset;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ByteOffset;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ByteOffset\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ByteOffset\" : ");fprintf(outFile, "\"Unable to read ByteOffset\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Key;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Key;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Key\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Key\" : ");fprintf(outFile, "\"Unable to read Key\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtReadFileScatter_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t SegmentArray, uint32_t Length, uint32_t ByteOffset, uint32_t Key) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x112\",\"syscall_name\" : \"NtReadFileScatter\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"SegmentArray\":\"0x%x\", \"Length\":\"0x%x\", \"ByteOffset\":\"0x%x\", \"Key\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, SegmentArray, Length, ByteOffset, Key, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ByteOffset;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ByteOffset;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ByteOffset\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ByteOffset\" : ");fprintf(outFile, "\"Unable to read ByteOffset\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Key;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Key;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Key\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Key\" : ");fprintf(outFile, "\"Unable to read Key\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*275 NTSTATUS NtReadOnlyEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);*/
void on_cb_NtReadOnlyEnlistment_enter(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x113\",\"syscall_name\" : \"NtReadOnlyEnlistment\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtReadOnlyEnlistment_return(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x113\",\"syscall_name\" : \"NtReadOnlyEnlistment\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*276 NTSTATUS NtReadRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);*/
void on_cb_NtReadRequestData_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Message, uint32_t DataEntryIndex, uint32_t Buffer, uint32_t BufferSize, uint32_t NumberOfBytesRead) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x114\",\"syscall_name\" : \"NtReadRequestData\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Message\":\"0x%x\", \"DataEntryIndex\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\", \"NumberOfBytesRead\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Message, DataEntryIndex, Buffer, BufferSize, NumberOfBytesRead, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtReadRequestData_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Message, uint32_t DataEntryIndex, uint32_t Buffer, uint32_t BufferSize, uint32_t NumberOfBytesRead) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x114\",\"syscall_name\" : \"NtReadRequestData\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Message\":\"0x%x\", \"DataEntryIndex\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\", \"NumberOfBytesRead\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Message, DataEntryIndex, Buffer, BufferSize, NumberOfBytesRead, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*277 NTSTATUS NtReadVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);*/
void on_cb_NtReadVirtualMemory_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t Buffer, uint32_t BufferSize, uint32_t NumberOfBytesRead) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x115\",\"syscall_name\" : \"NtReadVirtualMemory\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\", \"NumberOfBytesRead\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, Buffer, BufferSize, NumberOfBytesRead, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtReadVirtualMemory_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t Buffer, uint32_t BufferSize, uint32_t NumberOfBytesRead) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x115\",\"syscall_name\" : \"NtReadVirtualMemory\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\", \"NumberOfBytesRead\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, Buffer, BufferSize, NumberOfBytesRead, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*278 NTSTATUS NtRecoverEnlistment (HANDLE EnlistmentHandle, PVOID EnlistmentKey);*/
void on_cb_NtRecoverEnlistment_enter(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t EnlistmentKey) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x116\",\"syscall_name\" : \"NtRecoverEnlistment\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"EnlistmentKey\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, EnlistmentKey, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRecoverEnlistment_return(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t EnlistmentKey) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x116\",\"syscall_name\" : \"NtRecoverEnlistment\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"EnlistmentKey\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, EnlistmentKey, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*279 NTSTATUS NtRecoverResourceManager (HANDLE ResourceManagerHandle);*/
void on_cb_NtRecoverResourceManager_enter(CPUState *cpu, target_ulong pc, uint32_t ResourceManagerHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x117\",\"syscall_name\" : \"NtRecoverResourceManager\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManagerHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ResourceManagerHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRecoverResourceManager_return(CPUState *cpu, target_ulong pc, uint32_t ResourceManagerHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x117\",\"syscall_name\" : \"NtRecoverResourceManager\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManagerHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ResourceManagerHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*280 NTSTATUS NtRecoverTransactionManager (HANDLE TransactionManagerHandle);*/
void on_cb_NtRecoverTransactionManager_enter(CPUState *cpu, target_ulong pc, uint32_t TransactionManagerHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x118\",\"syscall_name\" : \"NtRecoverTransactionManager\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionManagerHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TransactionManagerHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRecoverTransactionManager_return(CPUState *cpu, target_ulong pc, uint32_t TransactionManagerHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x118\",\"syscall_name\" : \"NtRecoverTransactionManager\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionManagerHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TransactionManagerHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*281 NTSTATUS NtRegisterProtocolAddressInformation (HANDLE ResourceManager, PCRM_PROTOCOL_ID ProtocolId, ULONG ProtocolInformationSize, PVOID ProtocolInformation, ULONG CreateOptions);*/
void on_cb_NtRegisterProtocolAddressInformation_enter(CPUState *cpu, target_ulong pc, uint32_t ResourceManager, uint32_t ProtocolId, uint32_t ProtocolInformationSize, uint32_t ProtocolInformation, uint32_t CreateOptions) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x119\",\"syscall_name\" : \"NtRegisterProtocolAddressInformation\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManager\":\"0x%x\", \"ProtocolId\":\"0x%x\", \"ProtocolInformationSize\":\"0x%x\", \"ProtocolInformation\":\"0x%x\", \"CreateOptions\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ResourceManager, ProtocolId, ProtocolInformationSize, ProtocolInformation, CreateOptions, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRegisterProtocolAddressInformation_return(CPUState *cpu, target_ulong pc, uint32_t ResourceManager, uint32_t ProtocolId, uint32_t ProtocolInformationSize, uint32_t ProtocolInformation, uint32_t CreateOptions) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x119\",\"syscall_name\" : \"NtRegisterProtocolAddressInformation\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManager\":\"0x%x\", \"ProtocolId\":\"0x%x\", \"ProtocolInformationSize\":\"0x%x\", \"ProtocolInformation\":\"0x%x\", \"CreateOptions\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ResourceManager, ProtocolId, ProtocolInformationSize, ProtocolInformation, CreateOptions, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*282 NTSTATUS NtRegisterThreadTerminatePort (HANDLE PortHandle);*/
void on_cb_NtRegisterThreadTerminatePort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x11a\",\"syscall_name\" : \"NtRegisterThreadTerminatePort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRegisterThreadTerminatePort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x11a\",\"syscall_name\" : \"NtRegisterThreadTerminatePort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*283 NTSTATUS NtReleaseKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);*/
void on_cb_NtReleaseKeyedEvent_enter(CPUState *cpu, target_ulong pc, uint32_t KeyedEventHandle, uint32_t KeyValue, uint32_t Alertable, uint32_t Timeout) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x11b\",\"syscall_name\" : \"NtReleaseKeyedEvent\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyedEventHandle\":\"0x%x\", \"KeyValue\":\"0x%x\", \"Alertable\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyedEventHandle, KeyValue, Alertable, Timeout, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtReleaseKeyedEvent_return(CPUState *cpu, target_ulong pc, uint32_t KeyedEventHandle, uint32_t KeyValue, uint32_t Alertable, uint32_t Timeout) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x11b\",\"syscall_name\" : \"NtReleaseKeyedEvent\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyedEventHandle\":\"0x%x\", \"KeyValue\":\"0x%x\", \"Alertable\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyedEventHandle, KeyValue, Alertable, Timeout, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*284 NTSTATUS NtReleaseMutant (HANDLE MutantHandle, PLONG PreviousCount);*/
void on_cb_NtReleaseMutant_enter(CPUState *cpu, target_ulong pc, uint32_t MutantHandle, uint32_t PreviousCount) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x11c\",\"syscall_name\" : \"NtReleaseMutant\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"MutantHandle\":\"0x%x\", \"PreviousCount\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, MutantHandle, PreviousCount, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PreviousCount;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousCount;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousCount\" : ");dump_LONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousCount\" : ");fprintf(outFile, "\"Unable to read PreviousCount\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtReleaseMutant_return(CPUState *cpu, target_ulong pc, uint32_t MutantHandle, uint32_t PreviousCount) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x11c\",\"syscall_name\" : \"NtReleaseMutant\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"MutantHandle\":\"0x%x\", \"PreviousCount\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, MutantHandle, PreviousCount, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PreviousCount;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousCount;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousCount\" : ");dump_LONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousCount\" : ");fprintf(outFile, "\"Unable to read PreviousCount\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*285 NTSTATUS NtReleaseSemaphore (HANDLE SemaphoreHandle, LONG ReleaseCount, PLONG PreviousCount);*/
void on_cb_NtReleaseSemaphore_enter(CPUState *cpu, target_ulong pc, uint32_t SemaphoreHandle, int32_t ReleaseCount, uint32_t PreviousCount) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x11d\",\"syscall_name\" : \"NtReleaseSemaphore\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SemaphoreHandle\":\"0x%x\", \"ReleaseCount\":\"0x%x\", \"PreviousCount\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SemaphoreHandle, ReleaseCount, PreviousCount, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PreviousCount;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousCount;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousCount\" : ");dump_LONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousCount\" : ");fprintf(outFile, "\"Unable to read PreviousCount\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtReleaseSemaphore_return(CPUState *cpu, target_ulong pc, uint32_t SemaphoreHandle, int32_t ReleaseCount, uint32_t PreviousCount) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x11d\",\"syscall_name\" : \"NtReleaseSemaphore\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SemaphoreHandle\":\"0x%x\", \"ReleaseCount\":\"0x%x\", \"PreviousCount\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SemaphoreHandle, ReleaseCount, PreviousCount, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PreviousCount;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousCount;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousCount\" : ");dump_LONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousCount\" : ");fprintf(outFile, "\"Unable to read PreviousCount\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*286 NTSTATUS NtReleaseWorkerFactoryWorker (HANDLE WorkerFactoryHandle);*/
void on_cb_NtReleaseWorkerFactoryWorker_enter(CPUState *cpu, target_ulong pc, uint32_t WorkerFactoryHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x11e\",\"syscall_name\" : \"NtReleaseWorkerFactoryWorker\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"WorkerFactoryHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, WorkerFactoryHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtReleaseWorkerFactoryWorker_return(CPUState *cpu, target_ulong pc, uint32_t WorkerFactoryHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x11e\",\"syscall_name\" : \"NtReleaseWorkerFactoryWorker\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"WorkerFactoryHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, WorkerFactoryHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*287 NTSTATUS NtRemoveIoCompletion (HANDLE IoCompletionHandle, PVOID *KeyContext, PVOID *ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER Timeout);*/
void on_cb_NtRemoveIoCompletion_enter(CPUState *cpu, target_ulong pc, uint32_t IoCompletionHandle, uint32_t KeyContext, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t Timeout) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x11f\",\"syscall_name\" : \"NtRemoveIoCompletion\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"IoCompletionHandle\":\"0x%x\", \"KeyContext\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, IoCompletionHandle, KeyContext, ApcContext, IoStatusBlock, Timeout, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyContext;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyContext;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyContext\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyContext\" : ");fprintf(outFile, "\"Unable to read KeyContext\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ApcContext;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ApcContext;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ApcContext\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ApcContext\" : ");fprintf(outFile, "\"Unable to read ApcContext\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRemoveIoCompletion_return(CPUState *cpu, target_ulong pc, uint32_t IoCompletionHandle, uint32_t KeyContext, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t Timeout) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x11f\",\"syscall_name\" : \"NtRemoveIoCompletion\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"IoCompletionHandle\":\"0x%x\", \"KeyContext\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, IoCompletionHandle, KeyContext, ApcContext, IoStatusBlock, Timeout, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = KeyContext;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = KeyContext;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"KeyContext\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"KeyContext\" : ");fprintf(outFile, "\"Unable to read KeyContext\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ApcContext;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ApcContext;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ApcContext\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ApcContext\" : ");fprintf(outFile, "\"Unable to read ApcContext\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*288 NTSTATUS NtRemoveIoCompletionEx (HANDLE IoCompletionHandle, PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation, ULONG Count, PULONG NumEntriesRemoved, PLARGE_INTEGER Timeout, BOOLEAN Alertable);*/
void on_cb_NtRemoveIoCompletionEx_enter(CPUState *cpu, target_ulong pc, uint32_t IoCompletionHandle, uint32_t IoCompletionInformation, uint32_t Count, uint32_t NumEntriesRemoved, uint32_t Timeout, uint32_t Alertable) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x120\",\"syscall_name\" : \"NtRemoveIoCompletionEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"IoCompletionHandle\":\"0x%x\", \"IoCompletionInformation\":\"0x%x\", \"Count\":\"0x%x\", \"NumEntriesRemoved\":\"0x%x\", \"Timeout\":\"0x%x\", \"Alertable\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, IoCompletionHandle, IoCompletionInformation, Count, NumEntriesRemoved, Timeout, Alertable, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NumEntriesRemoved;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NumEntriesRemoved;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NumEntriesRemoved\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NumEntriesRemoved\" : ");fprintf(outFile, "\"Unable to read NumEntriesRemoved\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRemoveIoCompletionEx_return(CPUState *cpu, target_ulong pc, uint32_t IoCompletionHandle, uint32_t IoCompletionInformation, uint32_t Count, uint32_t NumEntriesRemoved, uint32_t Timeout, uint32_t Alertable) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x120\",\"syscall_name\" : \"NtRemoveIoCompletionEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"IoCompletionHandle\":\"0x%x\", \"IoCompletionInformation\":\"0x%x\", \"Count\":\"0x%x\", \"NumEntriesRemoved\":\"0x%x\", \"Timeout\":\"0x%x\", \"Alertable\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, IoCompletionHandle, IoCompletionInformation, Count, NumEntriesRemoved, Timeout, Alertable, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NumEntriesRemoved;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NumEntriesRemoved;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NumEntriesRemoved\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NumEntriesRemoved\" : ");fprintf(outFile, "\"Unable to read NumEntriesRemoved\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*289 NTSTATUS NtRemoveProcessDebug (HANDLE ProcessHandle, HANDLE DebugObjectHandle);*/
void on_cb_NtRemoveProcessDebug_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t DebugObjectHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x121\",\"syscall_name\" : \"NtRemoveProcessDebug\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"DebugObjectHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, DebugObjectHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRemoveProcessDebug_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t DebugObjectHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x121\",\"syscall_name\" : \"NtRemoveProcessDebug\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"DebugObjectHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, DebugObjectHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*290 NTSTATUS NtRenameKey (HANDLE KeyHandle, PUNICODE_STRING NewName);*/
void on_cb_NtRenameKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t NewName) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x122\",\"syscall_name\" : \"NtRenameKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"NewName\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, NewName, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NewName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NewName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NewName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NewName\" : ");fprintf(outFile, "\"Unable to read NewName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRenameKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t NewName) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x122\",\"syscall_name\" : \"NtRenameKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"NewName\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, NewName, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NewName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NewName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NewName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NewName\" : ");fprintf(outFile, "\"Unable to read NewName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*291 NTSTATUS NtRenameTransactionManager (PUNICODE_STRING LogFileName, LPGUID ExistingTransactionManagerGuid);*/
void on_cb_NtRenameTransactionManager_enter(CPUState *cpu, target_ulong pc, uint32_t LogFileName, uint32_t ExistingTransactionManagerGuid) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x123\",\"syscall_name\" : \"NtRenameTransactionManager\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"LogFileName\":\"0x%x\", \"ExistingTransactionManagerGuid\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, LogFileName, ExistingTransactionManagerGuid, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = LogFileName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = LogFileName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"LogFileName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"LogFileName\" : ");fprintf(outFile, "\"Unable to read LogFileName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRenameTransactionManager_return(CPUState *cpu, target_ulong pc, uint32_t LogFileName, uint32_t ExistingTransactionManagerGuid) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x123\",\"syscall_name\" : \"NtRenameTransactionManager\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"LogFileName\":\"0x%x\", \"ExistingTransactionManagerGuid\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, LogFileName, ExistingTransactionManagerGuid, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = LogFileName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = LogFileName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"LogFileName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"LogFileName\" : ");fprintf(outFile, "\"Unable to read LogFileName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*292 NTSTATUS NtReplaceKey (POBJECT_ATTRIBUTES NewFile, HANDLE TargetHandle, POBJECT_ATTRIBUTES OldFile);*/
void on_cb_NtReplaceKey_enter(CPUState *cpu, target_ulong pc, uint32_t NewFile, uint32_t TargetHandle, uint32_t OldFile) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x124\",\"syscall_name\" : \"NtReplaceKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"NewFile\":\"0x%x\", \"TargetHandle\":\"0x%x\", \"OldFile\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, NewFile, TargetHandle, OldFile, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NewFile;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NewFile;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NewFile\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NewFile\" : ");fprintf(outFile, "\"Unable to read NewFile\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = OldFile;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = OldFile;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"OldFile\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"OldFile\" : ");fprintf(outFile, "\"Unable to read OldFile\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtReplaceKey_return(CPUState *cpu, target_ulong pc, uint32_t NewFile, uint32_t TargetHandle, uint32_t OldFile) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x124\",\"syscall_name\" : \"NtReplaceKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"NewFile\":\"0x%x\", \"TargetHandle\":\"0x%x\", \"OldFile\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, NewFile, TargetHandle, OldFile, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = NewFile;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = NewFile;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"NewFile\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"NewFile\" : ");fprintf(outFile, "\"Unable to read NewFile\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = OldFile;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = OldFile;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"OldFile\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"OldFile\" : ");fprintf(outFile, "\"Unable to read OldFile\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*293 NTSTATUS NtReplacePartitionUnit (PUNICODE_STRING TargetInstancePath, PUNICODE_STRING SpareInstancePath, ULONG Flags);*/
void on_cb_NtReplacePartitionUnit_enter(CPUState *cpu, target_ulong pc, uint32_t TargetInstancePath, uint32_t SpareInstancePath, uint32_t Flags) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x125\",\"syscall_name\" : \"NtReplacePartitionUnit\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetInstancePath\":\"0x%x\", \"SpareInstancePath\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TargetInstancePath, SpareInstancePath, Flags, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetInstancePath;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetInstancePath;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetInstancePath\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetInstancePath\" : ");fprintf(outFile, "\"Unable to read TargetInstancePath\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = SpareInstancePath;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SpareInstancePath;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SpareInstancePath\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SpareInstancePath\" : ");fprintf(outFile, "\"Unable to read SpareInstancePath\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtReplacePartitionUnit_return(CPUState *cpu, target_ulong pc, uint32_t TargetInstancePath, uint32_t SpareInstancePath, uint32_t Flags) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x125\",\"syscall_name\" : \"NtReplacePartitionUnit\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetInstancePath\":\"0x%x\", \"SpareInstancePath\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TargetInstancePath, SpareInstancePath, Flags, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetInstancePath;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetInstancePath;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetInstancePath\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetInstancePath\" : ");fprintf(outFile, "\"Unable to read TargetInstancePath\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = SpareInstancePath;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SpareInstancePath;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SpareInstancePath\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SpareInstancePath\" : ");fprintf(outFile, "\"Unable to read SpareInstancePath\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*294 NTSTATUS NtReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);*/
void on_cb_NtReplyPort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t ReplyMessage) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x126\",\"syscall_name\" : \"NtReplyPort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"ReplyMessage\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, ReplyMessage, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtReplyPort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t ReplyMessage) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x126\",\"syscall_name\" : \"NtReplyPort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"ReplyMessage\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, ReplyMessage, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*295 NTSTATUS NtReplyWaitReceivePort (HANDLE PortHandle, PVOID *PortContext , PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage);*/
void on_cb_NtReplyWaitReceivePort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortContext, uint32_t ReplyMessage, uint32_t ReceiveMessage) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x127\",\"syscall_name\" : \"NtReplyWaitReceivePort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortContext\":\"0x%x\", \"ReplyMessage\":\"0x%x\", \"ReceiveMessage\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortContext, ReplyMessage, ReceiveMessage, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortContext;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortContext;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortContext\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortContext\" : ");fprintf(outFile, "\"Unable to read PortContext\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtReplyWaitReceivePort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortContext, uint32_t ReplyMessage, uint32_t ReceiveMessage) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x127\",\"syscall_name\" : \"NtReplyWaitReceivePort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortContext\":\"0x%x\", \"ReplyMessage\":\"0x%x\", \"ReceiveMessage\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortContext, ReplyMessage, ReceiveMessage, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortContext;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortContext;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortContext\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortContext\" : ");fprintf(outFile, "\"Unable to read PortContext\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*296 NTSTATUS NtReplyWaitReceivePortEx (HANDLE PortHandle, PVOID *PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage, PLARGE_INTEGER Timeout);*/
void on_cb_NtReplyWaitReceivePortEx_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortContext, uint32_t ReplyMessage, uint32_t ReceiveMessage, uint32_t Timeout) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x128\",\"syscall_name\" : \"NtReplyWaitReceivePortEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortContext\":\"0x%x\", \"ReplyMessage\":\"0x%x\", \"ReceiveMessage\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortContext, ReplyMessage, ReceiveMessage, Timeout, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortContext;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortContext;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortContext\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortContext\" : ");fprintf(outFile, "\"Unable to read PortContext\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtReplyWaitReceivePortEx_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortContext, uint32_t ReplyMessage, uint32_t ReceiveMessage, uint32_t Timeout) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x128\",\"syscall_name\" : \"NtReplyWaitReceivePortEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortContext\":\"0x%x\", \"ReplyMessage\":\"0x%x\", \"ReceiveMessage\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortContext, ReplyMessage, ReceiveMessage, Timeout, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortContext;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortContext;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortContext\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortContext\" : ");fprintf(outFile, "\"Unable to read PortContext\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*297 NTSTATUS NtReplyWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);*/
void on_cb_NtReplyWaitReplyPort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t ReplyMessage) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x129\",\"syscall_name\" : \"NtReplyWaitReplyPort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"ReplyMessage\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, ReplyMessage, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtReplyWaitReplyPort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t ReplyMessage) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x129\",\"syscall_name\" : \"NtReplyWaitReplyPort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"ReplyMessage\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, ReplyMessage, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*298 NTSTATUS NtRequestPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage);*/
void on_cb_NtRequestPort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t RequestMessage) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x12a\",\"syscall_name\" : \"NtRequestPort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"RequestMessage\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, RequestMessage, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRequestPort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t RequestMessage) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x12a\",\"syscall_name\" : \"NtRequestPort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"RequestMessage\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, RequestMessage, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*299 NTSTATUS NtRequestWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage);*/
void on_cb_NtRequestWaitReplyPort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t RequestMessage, uint32_t ReplyMessage) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x12b\",\"syscall_name\" : \"NtRequestWaitReplyPort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"RequestMessage\":\"0x%x\", \"ReplyMessage\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, RequestMessage, ReplyMessage, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRequestWaitReplyPort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t RequestMessage, uint32_t ReplyMessage) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x12b\",\"syscall_name\" : \"NtRequestWaitReplyPort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"RequestMessage\":\"0x%x\", \"ReplyMessage\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, RequestMessage, ReplyMessage, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*300 NTSTATUS NtResetEvent (HANDLE EventHandle, PLONG PreviousState);*/
void on_cb_NtResetEvent_enter(CPUState *cpu, target_ulong pc, uint32_t EventHandle, uint32_t PreviousState) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x12c\",\"syscall_name\" : \"NtResetEvent\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\", \"PreviousState\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventHandle, PreviousState, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PreviousState;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousState;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousState\" : ");dump_LONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousState\" : ");fprintf(outFile, "\"Unable to read PreviousState\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtResetEvent_return(CPUState *cpu, target_ulong pc, uint32_t EventHandle, uint32_t PreviousState) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x12c\",\"syscall_name\" : \"NtResetEvent\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\", \"PreviousState\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventHandle, PreviousState, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PreviousState;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousState;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousState\" : ");dump_LONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousState\" : ");fprintf(outFile, "\"Unable to read PreviousState\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*301 NTSTATUS NtResetWriteWatch (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T RegionSize);*/
void on_cb_NtResetWriteWatch_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t RegionSize) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x12d\",\"syscall_name\" : \"NtResetWriteWatch\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"RegionSize\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, RegionSize, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtResetWriteWatch_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t RegionSize) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x12d\",\"syscall_name\" : \"NtResetWriteWatch\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"RegionSize\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, RegionSize, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*302 NTSTATUS NtRestoreKey (HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);*/
void on_cb_NtRestoreKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t FileHandle, uint32_t Flags) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x12e\",\"syscall_name\" : \"NtRestoreKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"FileHandle\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, FileHandle, Flags, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRestoreKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t FileHandle, uint32_t Flags) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x12e\",\"syscall_name\" : \"NtRestoreKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"FileHandle\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, FileHandle, Flags, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*303 NTSTATUS NtResumeProcess (HANDLE ProcessHandle);*/
void on_cb_NtResumeProcess_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x12f\",\"syscall_name\" : \"NtResumeProcess\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtResumeProcess_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x12f\",\"syscall_name\" : \"NtResumeProcess\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*304 NTSTATUS NtResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);*/
void on_cb_NtResumeThread_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t PreviousSuspendCount) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x130\",\"syscall_name\" : \"NtResumeThread\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"PreviousSuspendCount\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, PreviousSuspendCount, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PreviousSuspendCount;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousSuspendCount;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousSuspendCount\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousSuspendCount\" : ");fprintf(outFile, "\"Unable to read PreviousSuspendCount\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtResumeThread_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t PreviousSuspendCount) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x130\",\"syscall_name\" : \"NtResumeThread\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"PreviousSuspendCount\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, PreviousSuspendCount, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PreviousSuspendCount;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousSuspendCount;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousSuspendCount\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousSuspendCount\" : ");fprintf(outFile, "\"Unable to read PreviousSuspendCount\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*305 NTSTATUS NtRollbackComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);*/
void on_cb_NtRollbackComplete_enter(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x131\",\"syscall_name\" : \"NtRollbackComplete\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRollbackComplete_return(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x131\",\"syscall_name\" : \"NtRollbackComplete\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*306 NTSTATUS NtRollbackEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);*/
void on_cb_NtRollbackEnlistment_enter(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x132\",\"syscall_name\" : \"NtRollbackEnlistment\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRollbackEnlistment_return(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x132\",\"syscall_name\" : \"NtRollbackEnlistment\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*307 NTSTATUS NtRollbackTransaction (HANDLE TransactionHandle, BOOLEAN Wait);*/
void on_cb_NtRollbackTransaction_enter(CPUState *cpu, target_ulong pc, uint32_t TransactionHandle, uint32_t Wait) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x133\",\"syscall_name\" : \"NtRollbackTransaction\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionHandle\":\"0x%x\", \"Wait\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TransactionHandle, Wait, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRollbackTransaction_return(CPUState *cpu, target_ulong pc, uint32_t TransactionHandle, uint32_t Wait) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x133\",\"syscall_name\" : \"NtRollbackTransaction\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionHandle\":\"0x%x\", \"Wait\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TransactionHandle, Wait, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*308 NTSTATUS NtRollforwardTransactionManager (HANDLE TransactionManagerHandle, PLARGE_INTEGER TmVirtualClock);*/
void on_cb_NtRollforwardTransactionManager_enter(CPUState *cpu, target_ulong pc, uint32_t TransactionManagerHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x134\",\"syscall_name\" : \"NtRollforwardTransactionManager\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionManagerHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TransactionManagerHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtRollforwardTransactionManager_return(CPUState *cpu, target_ulong pc, uint32_t TransactionManagerHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x134\",\"syscall_name\" : \"NtRollforwardTransactionManager\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionManagerHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TransactionManagerHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*309 NTSTATUS NtSaveKey (HANDLE KeyHandle, HANDLE FileHandle);*/
void on_cb_NtSaveKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t FileHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x135\",\"syscall_name\" : \"NtSaveKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"FileHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, FileHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSaveKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t FileHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x135\",\"syscall_name\" : \"NtSaveKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"FileHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, FileHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*310 NTSTATUS NtSaveKeyEx (HANDLE KeyHandle, HANDLE FileHandle, ULONG Format);*/
void on_cb_NtSaveKeyEx_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t FileHandle, uint32_t Format) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x136\",\"syscall_name\" : \"NtSaveKeyEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"FileHandle\":\"0x%x\", \"Format\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, FileHandle, Format, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSaveKeyEx_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t FileHandle, uint32_t Format) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x136\",\"syscall_name\" : \"NtSaveKeyEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"FileHandle\":\"0x%x\", \"Format\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, FileHandle, Format, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*311 NTSTATUS NtSaveMergedKeys (HANDLE HighPrecedenceKeyHandle, HANDLE LowPrecedenceKeyHandle, HANDLE FileHandle);*/
void on_cb_NtSaveMergedKeys_enter(CPUState *cpu, target_ulong pc, uint32_t HighPrecedenceKeyHandle, uint32_t LowPrecedenceKeyHandle, uint32_t FileHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x137\",\"syscall_name\" : \"NtSaveMergedKeys\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"HighPrecedenceKeyHandle\":\"0x%x\", \"LowPrecedenceKeyHandle\":\"0x%x\", \"FileHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, HighPrecedenceKeyHandle, LowPrecedenceKeyHandle, FileHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSaveMergedKeys_return(CPUState *cpu, target_ulong pc, uint32_t HighPrecedenceKeyHandle, uint32_t LowPrecedenceKeyHandle, uint32_t FileHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x137\",\"syscall_name\" : \"NtSaveMergedKeys\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"HighPrecedenceKeyHandle\":\"0x%x\", \"LowPrecedenceKeyHandle\":\"0x%x\", \"FileHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, HighPrecedenceKeyHandle, LowPrecedenceKeyHandle, FileHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*312 NTSTATUS NtSecureConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PSID RequiredServerSid, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);*/
void on_cb_NtSecureConnectPort_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortName, uint32_t SecurityQos, uint32_t ClientView, uint32_t RequiredServerSid, uint32_t ServerView, uint32_t MaxMessageLength, uint32_t ConnectionInformation, uint32_t ConnectionInformationLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x138\",\"syscall_name\" : \"NtSecureConnectPort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortName\":\"0x%x\", \"SecurityQos\":\"0x%x\", \"ClientView\":\"0x%x\", \"RequiredServerSid\":\"0x%x\", \"ServerView\":\"0x%x\", \"MaxMessageLength\":\"0x%x\", \"ConnectionInformation\":\"0x%x\", \"ConnectionInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortName, SecurityQos, ClientView, RequiredServerSid, ServerView, MaxMessageLength, ConnectionInformation, ConnectionInformationLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortHandle\" : ");fprintf(outFile, "\"Unable to read PortHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = PortName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortName\" : ");fprintf(outFile, "\"Unable to read PortName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = MaxMessageLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MaxMessageLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MaxMessageLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MaxMessageLength\" : ");fprintf(outFile, "\"Unable to read MaxMessageLength\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ConnectionInformationLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ConnectionInformationLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ConnectionInformationLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ConnectionInformationLength\" : ");fprintf(outFile, "\"Unable to read ConnectionInformationLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSecureConnectPort_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t PortName, uint32_t SecurityQos, uint32_t ClientView, uint32_t RequiredServerSid, uint32_t ServerView, uint32_t MaxMessageLength, uint32_t ConnectionInformation, uint32_t ConnectionInformationLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x138\",\"syscall_name\" : \"NtSecureConnectPort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"PortName\":\"0x%x\", \"SecurityQos\":\"0x%x\", \"ClientView\":\"0x%x\", \"RequiredServerSid\":\"0x%x\", \"ServerView\":\"0x%x\", \"MaxMessageLength\":\"0x%x\", \"ConnectionInformation\":\"0x%x\", \"ConnectionInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, PortName, SecurityQos, ClientView, RequiredServerSid, ServerView, MaxMessageLength, ConnectionInformation, ConnectionInformationLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PortHandle;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortHandle;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            HANDLE pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortHandle\" : ");dump_HANDLE(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortHandle\" : ");fprintf(outFile, "\"Unable to read PortHandle\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = PortName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PortName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PortName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PortName\" : ");fprintf(outFile, "\"Unable to read PortName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = MaxMessageLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = MaxMessageLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"MaxMessageLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"MaxMessageLength\" : ");fprintf(outFile, "\"Unable to read MaxMessageLength\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = ConnectionInformationLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ConnectionInformationLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ConnectionInformationLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ConnectionInformationLength\" : ");fprintf(outFile, "\"Unable to read ConnectionInformationLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*313 NTSTATUS NtSerializeBoot ();*/
void on_cb_NtSerializeBoot_enter(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x139\",\"syscall_name\" : \"NtSerializeBoot\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSerializeBoot_return(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x139\",\"syscall_name\" : \"NtSerializeBoot\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*314 NTSTATUS NtSetBootEntryOrder (PULONG Ids, ULONG Count);*/
void on_cb_NtSetBootEntryOrder_enter(CPUState *cpu, target_ulong pc, uint32_t Ids, uint32_t Count) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x13a\",\"syscall_name\" : \"NtSetBootEntryOrder\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Ids\":\"0x%x\", \"Count\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Ids, Count, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Ids;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Ids;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Ids\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Ids\" : ");fprintf(outFile, "\"Unable to read Ids\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetBootEntryOrder_return(CPUState *cpu, target_ulong pc, uint32_t Ids, uint32_t Count) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x13a\",\"syscall_name\" : \"NtSetBootEntryOrder\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Ids\":\"0x%x\", \"Count\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Ids, Count, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Ids;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Ids;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Ids\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Ids\" : ");fprintf(outFile, "\"Unable to read Ids\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*315 NTSTATUS NtSetBootOptions (PBOOT_OPTIONS BootOptions, ULONG FieldsToChange);*/
void on_cb_NtSetBootOptions_enter(CPUState *cpu, target_ulong pc, uint32_t BootOptions, uint32_t FieldsToChange) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x13b\",\"syscall_name\" : \"NtSetBootOptions\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"BootOptions\":\"0x%x\", \"FieldsToChange\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, BootOptions, FieldsToChange, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetBootOptions_return(CPUState *cpu, target_ulong pc, uint32_t BootOptions, uint32_t FieldsToChange) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x13b\",\"syscall_name\" : \"NtSetBootOptions\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"BootOptions\":\"0x%x\", \"FieldsToChange\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, BootOptions, FieldsToChange, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*316 NTSTATUS NtSetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);*/
void on_cb_NtSetContextThread_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t ThreadContext) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x13c\",\"syscall_name\" : \"NtSetContextThread\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"ThreadContext\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, ThreadContext, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetContextThread_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t ThreadContext) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x13c\",\"syscall_name\" : \"NtSetContextThread\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"ThreadContext\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, ThreadContext, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*317 NTSTATUS NtSetDebugFilterState (ULONG ComponentId, ULONG Level, BOOLEAN State);*/
void on_cb_NtSetDebugFilterState_enter(CPUState *cpu, target_ulong pc, uint32_t ComponentId, uint32_t Level, uint32_t State) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x13d\",\"syscall_name\" : \"NtSetDebugFilterState\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ComponentId\":\"0x%x\", \"Level\":\"0x%x\", \"State\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ComponentId, Level, State, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetDebugFilterState_return(CPUState *cpu, target_ulong pc, uint32_t ComponentId, uint32_t Level, uint32_t State) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x13d\",\"syscall_name\" : \"NtSetDebugFilterState\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ComponentId\":\"0x%x\", \"Level\":\"0x%x\", \"State\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ComponentId, Level, State, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*318 NTSTATUS NtSetDefaultHardErrorPort (HANDLE DefaultHardErrorPort);*/
void on_cb_NtSetDefaultHardErrorPort_enter(CPUState *cpu, target_ulong pc, uint32_t DefaultHardErrorPort) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x13e\",\"syscall_name\" : \"NtSetDefaultHardErrorPort\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DefaultHardErrorPort\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, DefaultHardErrorPort, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetDefaultHardErrorPort_return(CPUState *cpu, target_ulong pc, uint32_t DefaultHardErrorPort) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x13e\",\"syscall_name\" : \"NtSetDefaultHardErrorPort\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DefaultHardErrorPort\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, DefaultHardErrorPort, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*319 NTSTATUS NtSetDefaultLocale (BOOLEAN UserProfile, LCID DefaultLocaleId);*/
void on_cb_NtSetDefaultLocale_enter(CPUState *cpu, target_ulong pc, uint32_t UserProfile, uint32_t DefaultLocaleId) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x13f\",\"syscall_name\" : \"NtSetDefaultLocale\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"UserProfile\":\"0x%x\", \"DefaultLocaleId\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, UserProfile, DefaultLocaleId, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetDefaultLocale_return(CPUState *cpu, target_ulong pc, uint32_t UserProfile, uint32_t DefaultLocaleId) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x13f\",\"syscall_name\" : \"NtSetDefaultLocale\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"UserProfile\":\"0x%x\", \"DefaultLocaleId\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, UserProfile, DefaultLocaleId, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*320 NTSTATUS NtSetDefaultUILanguage (LANGID DefaultUILanguageId);*/
void on_cb_NtSetDefaultUILanguage_enter(CPUState *cpu, target_ulong pc, uint32_t DefaultUILanguageId) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x140\",\"syscall_name\" : \"NtSetDefaultUILanguage\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DefaultUILanguageId\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, DefaultUILanguageId, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetDefaultUILanguage_return(CPUState *cpu, target_ulong pc, uint32_t DefaultUILanguageId) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x140\",\"syscall_name\" : \"NtSetDefaultUILanguage\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DefaultUILanguageId\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, DefaultUILanguageId, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*321 NTSTATUS NtSetDriverEntryOrder (PULONG Ids, ULONG Count);*/
void on_cb_NtSetDriverEntryOrder_enter(CPUState *cpu, target_ulong pc, uint32_t Ids, uint32_t Count) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x141\",\"syscall_name\" : \"NtSetDriverEntryOrder\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Ids\":\"0x%x\", \"Count\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Ids, Count, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Ids;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Ids;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Ids\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Ids\" : ");fprintf(outFile, "\"Unable to read Ids\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetDriverEntryOrder_return(CPUState *cpu, target_ulong pc, uint32_t Ids, uint32_t Count) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x141\",\"syscall_name\" : \"NtSetDriverEntryOrder\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Ids\":\"0x%x\", \"Count\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Ids, Count, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Ids;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Ids;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Ids\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Ids\" : ");fprintf(outFile, "\"Unable to read Ids\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*322 NTSTATUS NtSetEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);*/
void on_cb_NtSetEaFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t Buffer, uint32_t Length) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x142\",\"syscall_name\" : \"NtSetEaFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, Buffer, Length, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetEaFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t Buffer, uint32_t Length) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x142\",\"syscall_name\" : \"NtSetEaFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, Buffer, Length, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*323 NTSTATUS NtSetEvent (HANDLE EventHandle, PLONG PreviousState);*/
void on_cb_NtSetEvent_enter(CPUState *cpu, target_ulong pc, uint32_t EventHandle, uint32_t PreviousState) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x143\",\"syscall_name\" : \"NtSetEvent\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\", \"PreviousState\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventHandle, PreviousState, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PreviousState;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousState;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousState\" : ");dump_LONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousState\" : ");fprintf(outFile, "\"Unable to read PreviousState\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetEvent_return(CPUState *cpu, target_ulong pc, uint32_t EventHandle, uint32_t PreviousState) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x143\",\"syscall_name\" : \"NtSetEvent\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\", \"PreviousState\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventHandle, PreviousState, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PreviousState;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousState;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousState\" : ");dump_LONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousState\" : ");fprintf(outFile, "\"Unable to read PreviousState\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*324 NTSTATUS NtSetEventBoostPriority (HANDLE EventHandle);*/
void on_cb_NtSetEventBoostPriority_enter(CPUState *cpu, target_ulong pc, uint32_t EventHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x144\",\"syscall_name\" : \"NtSetEventBoostPriority\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetEventBoostPriority_return(CPUState *cpu, target_ulong pc, uint32_t EventHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x144\",\"syscall_name\" : \"NtSetEventBoostPriority\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*325 NTSTATUS NtSetHighEventPair (HANDLE EventPairHandle);*/
void on_cb_NtSetHighEventPair_enter(CPUState *cpu, target_ulong pc, uint32_t EventPairHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x145\",\"syscall_name\" : \"NtSetHighEventPair\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventPairHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventPairHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetHighEventPair_return(CPUState *cpu, target_ulong pc, uint32_t EventPairHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x145\",\"syscall_name\" : \"NtSetHighEventPair\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventPairHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventPairHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*326 NTSTATUS NtSetHighWaitLowEventPair (HANDLE EventPairHandle);*/
void on_cb_NtSetHighWaitLowEventPair_enter(CPUState *cpu, target_ulong pc, uint32_t EventPairHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x146\",\"syscall_name\" : \"NtSetHighWaitLowEventPair\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventPairHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventPairHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetHighWaitLowEventPair_return(CPUState *cpu, target_ulong pc, uint32_t EventPairHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x146\",\"syscall_name\" : \"NtSetHighWaitLowEventPair\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventPairHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventPairHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*327 NTSTATUS NtSetInformationDebugObject (HANDLE DebugObjectHandle, DEBUGOBJECTINFOCLASS DebugObjectInformationClass, PVOID DebugInformation, ULONG DebugInformationLength, PULONG ReturnLength);*/
void on_cb_NtSetInformationDebugObject_enter(CPUState *cpu, target_ulong pc, uint32_t DebugObjectHandle, uint32_t DebugObjectInformationClass, uint32_t DebugInformation, uint32_t DebugInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x147\",\"syscall_name\" : \"NtSetInformationDebugObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DebugObjectHandle\":\"0x%x\", \"DebugObjectInformationClass\":\"0x%x\", \"DebugInformation\":\"0x%x\", \"DebugInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, DebugObjectHandle, DebugObjectInformationClass, DebugInformation, DebugInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetInformationDebugObject_return(CPUState *cpu, target_ulong pc, uint32_t DebugObjectHandle, uint32_t DebugObjectInformationClass, uint32_t DebugInformation, uint32_t DebugInformationLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x147\",\"syscall_name\" : \"NtSetInformationDebugObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DebugObjectHandle\":\"0x%x\", \"DebugObjectInformationClass\":\"0x%x\", \"DebugInformation\":\"0x%x\", \"DebugInformationLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, DebugObjectHandle, DebugObjectInformationClass, DebugInformation, DebugInformationLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*328 NTSTATUS NtSetInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength);*/
void on_cb_NtSetInformationEnlistment_enter(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t EnlistmentInformationClass, uint32_t EnlistmentInformation, uint32_t EnlistmentInformationLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x148\",\"syscall_name\" : \"NtSetInformationEnlistment\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"EnlistmentInformationClass\":\"0x%x\", \"EnlistmentInformation\":\"0x%x\", \"EnlistmentInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, EnlistmentInformationClass, EnlistmentInformation, EnlistmentInformationLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetInformationEnlistment_return(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t EnlistmentInformationClass, uint32_t EnlistmentInformation, uint32_t EnlistmentInformationLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x148\",\"syscall_name\" : \"NtSetInformationEnlistment\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"EnlistmentInformationClass\":\"0x%x\", \"EnlistmentInformation\":\"0x%x\", \"EnlistmentInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, EnlistmentInformationClass, EnlistmentInformation, EnlistmentInformationLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*329 NTSTATUS NtSetInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);*/
void on_cb_NtSetInformationFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t FileInformation, uint32_t Length, uint32_t FileInformationClass) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x149\",\"syscall_name\" : \"NtSetInformationFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"FileInformation\":\"0x%x\", \"Length\":\"0x%x\", \"FileInformationClass\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, FileInformation, Length, FileInformationClass, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetInformationFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t FileInformation, uint32_t Length, uint32_t FileInformationClass) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x149\",\"syscall_name\" : \"NtSetInformationFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"FileInformation\":\"0x%x\", \"Length\":\"0x%x\", \"FileInformationClass\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, FileInformation, Length, FileInformationClass, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*330 NTSTATUS NtSetInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength);*/
void on_cb_NtSetInformationJobObject_enter(CPUState *cpu, target_ulong pc, uint32_t JobHandle, uint32_t JobObjectInformationClass, uint32_t JobObjectInformation, uint32_t JobObjectInformationLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x14a\",\"syscall_name\" : \"NtSetInformationJobObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"JobHandle\":\"0x%x\", \"JobObjectInformationClass\":\"0x%x\", \"JobObjectInformation\":\"0x%x\", \"JobObjectInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, JobHandle, JobObjectInformationClass, JobObjectInformation, JobObjectInformationLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetInformationJobObject_return(CPUState *cpu, target_ulong pc, uint32_t JobHandle, uint32_t JobObjectInformationClass, uint32_t JobObjectInformation, uint32_t JobObjectInformationLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x14a\",\"syscall_name\" : \"NtSetInformationJobObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"JobHandle\":\"0x%x\", \"JobObjectInformationClass\":\"0x%x\", \"JobObjectInformation\":\"0x%x\", \"JobObjectInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, JobHandle, JobObjectInformationClass, JobObjectInformation, JobObjectInformationLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*331 NTSTATUS NtSetInformationKey (HANDLE KeyHandle, KEY_SET_INFORMATION_CLASS KeySetInformationClass, PVOID KeySetInformation, ULONG KeySetInformationLength);*/
void on_cb_NtSetInformationKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t KeySetInformationClass, uint32_t KeySetInformation, uint32_t KeySetInformationLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x14b\",\"syscall_name\" : \"NtSetInformationKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"KeySetInformationClass\":\"0x%x\", \"KeySetInformation\":\"0x%x\", \"KeySetInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, KeySetInformationClass, KeySetInformation, KeySetInformationLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetInformationKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t KeySetInformationClass, uint32_t KeySetInformation, uint32_t KeySetInformationLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x14b\",\"syscall_name\" : \"NtSetInformationKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"KeySetInformationClass\":\"0x%x\", \"KeySetInformation\":\"0x%x\", \"KeySetInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, KeySetInformationClass, KeySetInformation, KeySetInformationLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*332 NTSTATUS NtSetInformationObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength);*/
void on_cb_NtSetInformationObject_enter(CPUState *cpu, target_ulong pc, uint32_t Handle, uint32_t ObjectInformationClass, uint32_t ObjectInformation, uint32_t ObjectInformationLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x14c\",\"syscall_name\" : \"NtSetInformationObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Handle\":\"0x%x\", \"ObjectInformationClass\":\"0x%x\", \"ObjectInformation\":\"0x%x\", \"ObjectInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Handle, ObjectInformationClass, ObjectInformation, ObjectInformationLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetInformationObject_return(CPUState *cpu, target_ulong pc, uint32_t Handle, uint32_t ObjectInformationClass, uint32_t ObjectInformation, uint32_t ObjectInformationLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x14c\",\"syscall_name\" : \"NtSetInformationObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Handle\":\"0x%x\", \"ObjectInformationClass\":\"0x%x\", \"ObjectInformation\":\"0x%x\", \"ObjectInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Handle, ObjectInformationClass, ObjectInformation, ObjectInformationLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*333 NTSTATUS NtSetInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);*/
void on_cb_NtSetInformationProcess_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t ProcessInformationClass, uint32_t ProcessInformation, uint32_t ProcessInformationLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x14d\",\"syscall_name\" : \"NtSetInformationProcess\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"ProcessInformationClass\":\"0x%x\", \"ProcessInformation\":\"0x%x\", \"ProcessInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetInformationProcess_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t ProcessInformationClass, uint32_t ProcessInformation, uint32_t ProcessInformationLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x14d\",\"syscall_name\" : \"NtSetInformationProcess\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"ProcessInformationClass\":\"0x%x\", \"ProcessInformation\":\"0x%x\", \"ProcessInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*334 NTSTATUS NtSetInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength);*/
void on_cb_NtSetInformationResourceManager_enter(CPUState *cpu, target_ulong pc, uint32_t ResourceManagerHandle, uint32_t ResourceManagerInformationClass, uint32_t ResourceManagerInformation, uint32_t ResourceManagerInformationLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x14e\",\"syscall_name\" : \"NtSetInformationResourceManager\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManagerHandle\":\"0x%x\", \"ResourceManagerInformationClass\":\"0x%x\", \"ResourceManagerInformation\":\"0x%x\", \"ResourceManagerInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ResourceManagerHandle, ResourceManagerInformationClass, ResourceManagerInformation, ResourceManagerInformationLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetInformationResourceManager_return(CPUState *cpu, target_ulong pc, uint32_t ResourceManagerHandle, uint32_t ResourceManagerInformationClass, uint32_t ResourceManagerInformation, uint32_t ResourceManagerInformationLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x14e\",\"syscall_name\" : \"NtSetInformationResourceManager\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ResourceManagerHandle\":\"0x%x\", \"ResourceManagerInformationClass\":\"0x%x\", \"ResourceManagerInformation\":\"0x%x\", \"ResourceManagerInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ResourceManagerHandle, ResourceManagerInformationClass, ResourceManagerInformation, ResourceManagerInformationLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*335 NTSTATUS NtSetInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);*/
void on_cb_NtSetInformationThread_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t ThreadInformationClass, uint32_t ThreadInformation, uint32_t ThreadInformationLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x14f\",\"syscall_name\" : \"NtSetInformationThread\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"ThreadInformationClass\":\"0x%x\", \"ThreadInformation\":\"0x%x\", \"ThreadInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetInformationThread_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t ThreadInformationClass, uint32_t ThreadInformation, uint32_t ThreadInformationLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x14f\",\"syscall_name\" : \"NtSetInformationThread\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"ThreadInformationClass\":\"0x%x\", \"ThreadInformation\":\"0x%x\", \"ThreadInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*336 NTSTATUS NtSetInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength);*/
void on_cb_NtSetInformationToken_enter(CPUState *cpu, target_ulong pc, uint32_t TokenHandle, uint32_t TokenInformationClass, uint32_t TokenInformation, uint32_t TokenInformationLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x150\",\"syscall_name\" : \"NtSetInformationToken\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TokenHandle\":\"0x%x\", \"TokenInformationClass\":\"0x%x\", \"TokenInformation\":\"0x%x\", \"TokenInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetInformationToken_return(CPUState *cpu, target_ulong pc, uint32_t TokenHandle, uint32_t TokenInformationClass, uint32_t TokenInformation, uint32_t TokenInformationLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x150\",\"syscall_name\" : \"NtSetInformationToken\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TokenHandle\":\"0x%x\", \"TokenInformationClass\":\"0x%x\", \"TokenInformation\":\"0x%x\", \"TokenInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*337 NTSTATUS NtSetInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength);*/
void on_cb_NtSetInformationTransaction_enter(CPUState *cpu, target_ulong pc, uint32_t TransactionHandle, uint32_t TransactionInformationClass, uint32_t TransactionInformation, uint32_t TransactionInformationLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x151\",\"syscall_name\" : \"NtSetInformationTransaction\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionHandle\":\"0x%x\", \"TransactionInformationClass\":\"0x%x\", \"TransactionInformation\":\"0x%x\", \"TransactionInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TransactionHandle, TransactionInformationClass, TransactionInformation, TransactionInformationLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetInformationTransaction_return(CPUState *cpu, target_ulong pc, uint32_t TransactionHandle, uint32_t TransactionInformationClass, uint32_t TransactionInformation, uint32_t TransactionInformationLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x151\",\"syscall_name\" : \"NtSetInformationTransaction\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TransactionHandle\":\"0x%x\", \"TransactionInformationClass\":\"0x%x\", \"TransactionInformation\":\"0x%x\", \"TransactionInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TransactionHandle, TransactionInformationClass, TransactionInformation, TransactionInformationLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*338 NTSTATUS NtSetInformationTransactionManager (HANDLE TmHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength);*/
void on_cb_NtSetInformationTransactionManager_enter(CPUState *cpu, target_ulong pc, uint32_t TmHandle, uint32_t TransactionManagerInformationClass, uint32_t TransactionManagerInformation, uint32_t TransactionManagerInformationLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x152\",\"syscall_name\" : \"NtSetInformationTransactionManager\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TmHandle\":\"0x%x\", \"TransactionManagerInformationClass\":\"0x%x\", \"TransactionManagerInformation\":\"0x%x\", \"TransactionManagerInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TmHandle, TransactionManagerInformationClass, TransactionManagerInformation, TransactionManagerInformationLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetInformationTransactionManager_return(CPUState *cpu, target_ulong pc, uint32_t TmHandle, uint32_t TransactionManagerInformationClass, uint32_t TransactionManagerInformation, uint32_t TransactionManagerInformationLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x152\",\"syscall_name\" : \"NtSetInformationTransactionManager\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TmHandle\":\"0x%x\", \"TransactionManagerInformationClass\":\"0x%x\", \"TransactionManagerInformation\":\"0x%x\", \"TransactionManagerInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TmHandle, TransactionManagerInformationClass, TransactionManagerInformation, TransactionManagerInformationLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*339 NTSTATUS NtSetInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength);*/
void on_cb_NtSetInformationWorkerFactory_enter(CPUState *cpu, target_ulong pc, uint32_t WorkerFactoryHandle, uint32_t WorkerFactoryInformationClass, uint32_t WorkerFactoryInformation, uint32_t WorkerFactoryInformationLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x153\",\"syscall_name\" : \"NtSetInformationWorkerFactory\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"WorkerFactoryHandle\":\"0x%x\", \"WorkerFactoryInformationClass\":\"0x%x\", \"WorkerFactoryInformation\":\"0x%x\", \"WorkerFactoryInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, WorkerFactoryHandle, WorkerFactoryInformationClass, WorkerFactoryInformation, WorkerFactoryInformationLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetInformationWorkerFactory_return(CPUState *cpu, target_ulong pc, uint32_t WorkerFactoryHandle, uint32_t WorkerFactoryInformationClass, uint32_t WorkerFactoryInformation, uint32_t WorkerFactoryInformationLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x153\",\"syscall_name\" : \"NtSetInformationWorkerFactory\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"WorkerFactoryHandle\":\"0x%x\", \"WorkerFactoryInformationClass\":\"0x%x\", \"WorkerFactoryInformation\":\"0x%x\", \"WorkerFactoryInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, WorkerFactoryHandle, WorkerFactoryInformationClass, WorkerFactoryInformation, WorkerFactoryInformationLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*340 NTSTATUS NtSetIntervalProfile (ULONG Interval, KPROFILE_SOURCE Source);*/
void on_cb_NtSetIntervalProfile_enter(CPUState *cpu, target_ulong pc, uint32_t Interval, uint32_t Source) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x154\",\"syscall_name\" : \"NtSetIntervalProfile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Interval\":\"0x%x\", \"Source\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Interval, Source, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetIntervalProfile_return(CPUState *cpu, target_ulong pc, uint32_t Interval, uint32_t Source) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x154\",\"syscall_name\" : \"NtSetIntervalProfile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Interval\":\"0x%x\", \"Source\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Interval, Source, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*341 NTSTATUS NtSetIoCompletion (HANDLE IoCompletionHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);*/
void on_cb_NtSetIoCompletion_enter(CPUState *cpu, target_ulong pc, uint32_t IoCompletionHandle, uint32_t KeyContext, uint32_t ApcContext, uint32_t IoStatus, uint32_t IoStatusInformation) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x155\",\"syscall_name\" : \"NtSetIoCompletion\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"IoCompletionHandle\":\"0x%x\", \"KeyContext\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatus\":\"0x%x\", \"IoStatusInformation\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, IoCompletionHandle, KeyContext, ApcContext, IoStatus, IoStatusInformation, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetIoCompletion_return(CPUState *cpu, target_ulong pc, uint32_t IoCompletionHandle, uint32_t KeyContext, uint32_t ApcContext, uint32_t IoStatus, uint32_t IoStatusInformation) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x155\",\"syscall_name\" : \"NtSetIoCompletion\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"IoCompletionHandle\":\"0x%x\", \"KeyContext\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatus\":\"0x%x\", \"IoStatusInformation\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, IoCompletionHandle, KeyContext, ApcContext, IoStatus, IoStatusInformation, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*342 NTSTATUS NtSetIoCompletionEx (HANDLE IoCompletionHandle, HANDLE IoCompletionReserveHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);*/
void on_cb_NtSetIoCompletionEx_enter(CPUState *cpu, target_ulong pc, uint32_t IoCompletionHandle, uint32_t IoCompletionReserveHandle, uint32_t KeyContext, uint32_t ApcContext, uint32_t IoStatus, uint32_t IoStatusInformation) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x156\",\"syscall_name\" : \"NtSetIoCompletionEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"IoCompletionHandle\":\"0x%x\", \"IoCompletionReserveHandle\":\"0x%x\", \"KeyContext\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatus\":\"0x%x\", \"IoStatusInformation\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, IoCompletionHandle, IoCompletionReserveHandle, KeyContext, ApcContext, IoStatus, IoStatusInformation, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetIoCompletionEx_return(CPUState *cpu, target_ulong pc, uint32_t IoCompletionHandle, uint32_t IoCompletionReserveHandle, uint32_t KeyContext, uint32_t ApcContext, uint32_t IoStatus, uint32_t IoStatusInformation) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x156\",\"syscall_name\" : \"NtSetIoCompletionEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"IoCompletionHandle\":\"0x%x\", \"IoCompletionReserveHandle\":\"0x%x\", \"KeyContext\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatus\":\"0x%x\", \"IoStatusInformation\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, IoCompletionHandle, IoCompletionReserveHandle, KeyContext, ApcContext, IoStatus, IoStatusInformation, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*343 NTSTATUS NtSetLdtEntries (ULONG Selector0, ULONG Entry0Low, ULONG Entry0Hi, ULONG Selector1, ULONG Entry1Low, ULONG Entry1Hi);*/
void on_cb_NtSetLdtEntries_enter(CPUState *cpu, target_ulong pc, uint32_t Selector0, uint32_t Entry0Low, uint32_t Entry0Hi, uint32_t Selector1, uint32_t Entry1Low, uint32_t Entry1Hi) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x157\",\"syscall_name\" : \"NtSetLdtEntries\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Selector0\":\"0x%x\", \"Entry0Low\":\"0x%x\", \"Entry0Hi\":\"0x%x\", \"Selector1\":\"0x%x\", \"Entry1Low\":\"0x%x\", \"Entry1Hi\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Selector0, Entry0Low, Entry0Hi, Selector1, Entry1Low, Entry1Hi, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetLdtEntries_return(CPUState *cpu, target_ulong pc, uint32_t Selector0, uint32_t Entry0Low, uint32_t Entry0Hi, uint32_t Selector1, uint32_t Entry1Low, uint32_t Entry1Hi) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x157\",\"syscall_name\" : \"NtSetLdtEntries\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Selector0\":\"0x%x\", \"Entry0Low\":\"0x%x\", \"Entry0Hi\":\"0x%x\", \"Selector1\":\"0x%x\", \"Entry1Low\":\"0x%x\", \"Entry1Hi\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Selector0, Entry0Low, Entry0Hi, Selector1, Entry1Low, Entry1Hi, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*344 NTSTATUS NtSetLowEventPair (HANDLE EventPairHandle);*/
void on_cb_NtSetLowEventPair_enter(CPUState *cpu, target_ulong pc, uint32_t EventPairHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x158\",\"syscall_name\" : \"NtSetLowEventPair\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventPairHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventPairHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetLowEventPair_return(CPUState *cpu, target_ulong pc, uint32_t EventPairHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x158\",\"syscall_name\" : \"NtSetLowEventPair\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventPairHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventPairHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*345 NTSTATUS NtSetLowWaitHighEventPair (HANDLE EventPairHandle);*/
void on_cb_NtSetLowWaitHighEventPair_enter(CPUState *cpu, target_ulong pc, uint32_t EventPairHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x159\",\"syscall_name\" : \"NtSetLowWaitHighEventPair\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventPairHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventPairHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetLowWaitHighEventPair_return(CPUState *cpu, target_ulong pc, uint32_t EventPairHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x159\",\"syscall_name\" : \"NtSetLowWaitHighEventPair\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventPairHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventPairHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*346 NTSTATUS NtSetQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);*/
void on_cb_NtSetQuotaInformationFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t Buffer, uint32_t Length) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x15a\",\"syscall_name\" : \"NtSetQuotaInformationFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, Buffer, Length, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetQuotaInformationFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t Buffer, uint32_t Length) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x15a\",\"syscall_name\" : \"NtSetQuotaInformationFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, Buffer, Length, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*347 NTSTATUS NtSetSecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);*/
void on_cb_NtSetSecurityObject_enter(CPUState *cpu, target_ulong pc, uint32_t Handle, uint32_t SecurityInformation, uint32_t SecurityDescriptor) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x15b\",\"syscall_name\" : \"NtSetSecurityObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Handle\":\"0x%x\", \"SecurityInformation\":\"0x%x\", \"SecurityDescriptor\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Handle, SecurityInformation, SecurityDescriptor, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetSecurityObject_return(CPUState *cpu, target_ulong pc, uint32_t Handle, uint32_t SecurityInformation, uint32_t SecurityDescriptor) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x15b\",\"syscall_name\" : \"NtSetSecurityObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Handle\":\"0x%x\", \"SecurityInformation\":\"0x%x\", \"SecurityDescriptor\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Handle, SecurityInformation, SecurityDescriptor, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*348 NTSTATUS NtSetSystemEnvironmentValue (PUNICODE_STRING VariableName, PUNICODE_STRING VariableValue);*/
void on_cb_NtSetSystemEnvironmentValue_enter(CPUState *cpu, target_ulong pc, uint32_t VariableName, uint32_t VariableValue) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x15c\",\"syscall_name\" : \"NtSetSystemEnvironmentValue\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"VariableName\":\"0x%x\", \"VariableValue\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, VariableName, VariableValue, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = VariableName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = VariableName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"VariableName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"VariableName\" : ");fprintf(outFile, "\"Unable to read VariableName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = VariableValue;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = VariableValue;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"VariableValue\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"VariableValue\" : ");fprintf(outFile, "\"Unable to read VariableValue\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetSystemEnvironmentValue_return(CPUState *cpu, target_ulong pc, uint32_t VariableName, uint32_t VariableValue) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x15c\",\"syscall_name\" : \"NtSetSystemEnvironmentValue\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"VariableName\":\"0x%x\", \"VariableValue\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, VariableName, VariableValue, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = VariableName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = VariableName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"VariableName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"VariableName\" : ");fprintf(outFile, "\"Unable to read VariableName\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = VariableValue;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = VariableValue;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"VariableValue\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"VariableValue\" : ");fprintf(outFile, "\"Unable to read VariableValue\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*349 NTSTATUS NtSetSystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes);*/
void on_cb_NtSetSystemEnvironmentValueEx_enter(CPUState *cpu, target_ulong pc, uint32_t VariableName, uint32_t VendorGuid, uint32_t Value, uint32_t ValueLength, uint32_t Attributes) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x15d\",\"syscall_name\" : \"NtSetSystemEnvironmentValueEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"VariableName\":\"0x%x\", \"VendorGuid\":\"0x%x\", \"Value\":\"0x%x\", \"ValueLength\":\"0x%x\", \"Attributes\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, VariableName, VendorGuid, Value, ValueLength, Attributes, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = VariableName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = VariableName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"VariableName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"VariableName\" : ");fprintf(outFile, "\"Unable to read VariableName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetSystemEnvironmentValueEx_return(CPUState *cpu, target_ulong pc, uint32_t VariableName, uint32_t VendorGuid, uint32_t Value, uint32_t ValueLength, uint32_t Attributes) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x15d\",\"syscall_name\" : \"NtSetSystemEnvironmentValueEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"VariableName\":\"0x%x\", \"VendorGuid\":\"0x%x\", \"Value\":\"0x%x\", \"ValueLength\":\"0x%x\", \"Attributes\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, VariableName, VendorGuid, Value, ValueLength, Attributes, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = VariableName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = VariableName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"VariableName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"VariableName\" : ");fprintf(outFile, "\"Unable to read VariableName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*350 NTSTATUS NtSetSystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);*/
void on_cb_NtSetSystemInformation_enter(CPUState *cpu, target_ulong pc, uint32_t SystemInformationClass, uint32_t SystemInformation, uint32_t SystemInformationLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x15e\",\"syscall_name\" : \"NtSetSystemInformation\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SystemInformationClass\":\"0x%x\", \"SystemInformation\":\"0x%x\", \"SystemInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SystemInformationClass, SystemInformation, SystemInformationLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetSystemInformation_return(CPUState *cpu, target_ulong pc, uint32_t SystemInformationClass, uint32_t SystemInformation, uint32_t SystemInformationLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x15e\",\"syscall_name\" : \"NtSetSystemInformation\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SystemInformationClass\":\"0x%x\", \"SystemInformation\":\"0x%x\", \"SystemInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SystemInformationClass, SystemInformation, SystemInformationLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*351 NTSTATUS NtSetSystemPowerState (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags);*/
void on_cb_NtSetSystemPowerState_enter(CPUState *cpu, target_ulong pc, uint32_t SystemAction, uint32_t MinSystemState, uint32_t Flags) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x15f\",\"syscall_name\" : \"NtSetSystemPowerState\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SystemAction\":\"0x%x\", \"MinSystemState\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SystemAction, MinSystemState, Flags, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetSystemPowerState_return(CPUState *cpu, target_ulong pc, uint32_t SystemAction, uint32_t MinSystemState, uint32_t Flags) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x15f\",\"syscall_name\" : \"NtSetSystemPowerState\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SystemAction\":\"0x%x\", \"MinSystemState\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SystemAction, MinSystemState, Flags, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*352 NTSTATUS NtSetSystemTime (PLARGE_INTEGER SystemTime, PLARGE_INTEGER PreviousTime);*/
void on_cb_NtSetSystemTime_enter(CPUState *cpu, target_ulong pc, uint32_t SystemTime, uint32_t PreviousTime) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x160\",\"syscall_name\" : \"NtSetSystemTime\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SystemTime\":\"0x%x\", \"PreviousTime\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SystemTime, PreviousTime, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SystemTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SystemTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SystemTime\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SystemTime\" : ");fprintf(outFile, "\"Unable to read SystemTime\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = PreviousTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousTime\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousTime\" : ");fprintf(outFile, "\"Unable to read PreviousTime\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetSystemTime_return(CPUState *cpu, target_ulong pc, uint32_t SystemTime, uint32_t PreviousTime) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x160\",\"syscall_name\" : \"NtSetSystemTime\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SystemTime\":\"0x%x\", \"PreviousTime\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SystemTime, PreviousTime, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = SystemTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = SystemTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"SystemTime\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"SystemTime\" : ");fprintf(outFile, "\"Unable to read SystemTime\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = PreviousTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousTime\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousTime\" : ");fprintf(outFile, "\"Unable to read PreviousTime\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*353 NTSTATUS NtSetThreadExecutionState (EXECUTION_STATE esFlags, PEXECUTION_STATE PreviousFlags);*/
void on_cb_NtSetThreadExecutionState_enter(CPUState *cpu, target_ulong pc, uint32_t esFlags, uint32_t PreviousFlags) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x161\",\"syscall_name\" : \"NtSetThreadExecutionState\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"esFlags\":\"0x%x\", \"PreviousFlags\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, esFlags, PreviousFlags, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetThreadExecutionState_return(CPUState *cpu, target_ulong pc, uint32_t esFlags, uint32_t PreviousFlags) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x161\",\"syscall_name\" : \"NtSetThreadExecutionState\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"esFlags\":\"0x%x\", \"PreviousFlags\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, esFlags, PreviousFlags, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*354 NTSTATUS NtSetTimer (HANDLE TimerHandle, PLARGE_INTEGER DueTime, PTIMER_APC_ROUTINE TimerApcRoutine, PVOID TimerContext, BOOLEAN WakeTimer, LONG Period, PBOOLEAN PreviousState);*/
void on_cb_NtSetTimer_enter(CPUState *cpu, target_ulong pc, uint32_t TimerHandle, uint32_t DueTime, uint32_t TimerApcRoutine, uint32_t TimerContext, uint32_t WakeTimer, int32_t Period, uint32_t PreviousState) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x162\",\"syscall_name\" : \"NtSetTimer\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TimerHandle\":\"0x%x\", \"DueTime\":\"0x%x\", \"TimerApcRoutine\":\"0x%x\", \"TimerContext\":\"0x%x\", \"WakeTimer\":\"0x%x\", \"Period\":\"0x%x\", \"PreviousState\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TimerHandle, DueTime, TimerApcRoutine, TimerContext, WakeTimer, Period, PreviousState, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DueTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DueTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DueTime\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DueTime\" : ");fprintf(outFile, "\"Unable to read DueTime\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetTimer_return(CPUState *cpu, target_ulong pc, uint32_t TimerHandle, uint32_t DueTime, uint32_t TimerApcRoutine, uint32_t TimerContext, uint32_t WakeTimer, int32_t Period, uint32_t PreviousState) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x162\",\"syscall_name\" : \"NtSetTimer\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TimerHandle\":\"0x%x\", \"DueTime\":\"0x%x\", \"TimerApcRoutine\":\"0x%x\", \"TimerContext\":\"0x%x\", \"WakeTimer\":\"0x%x\", \"Period\":\"0x%x\", \"PreviousState\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TimerHandle, DueTime, TimerApcRoutine, TimerContext, WakeTimer, Period, PreviousState, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DueTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DueTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DueTime\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DueTime\" : ");fprintf(outFile, "\"Unable to read DueTime\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*355 NTSTATUS NtSetTimerEx (HANDLE TimerHandle, TIMER_SET_INFORMATION_CLASS TimerSetInformationClass, PVOID TimerSetInformation, ULONG TimerSetInformationLength);*/
void on_cb_NtSetTimerEx_enter(CPUState *cpu, target_ulong pc, uint32_t TimerHandle, uint32_t TimerSetInformationClass, uint32_t TimerSetInformation, uint32_t TimerSetInformationLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x163\",\"syscall_name\" : \"NtSetTimerEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TimerHandle\":\"0x%x\", \"TimerSetInformationClass\":\"0x%x\", \"TimerSetInformation\":\"0x%x\", \"TimerSetInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TimerHandle, TimerSetInformationClass, TimerSetInformation, TimerSetInformationLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetTimerEx_return(CPUState *cpu, target_ulong pc, uint32_t TimerHandle, uint32_t TimerSetInformationClass, uint32_t TimerSetInformation, uint32_t TimerSetInformationLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x163\",\"syscall_name\" : \"NtSetTimerEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TimerHandle\":\"0x%x\", \"TimerSetInformationClass\":\"0x%x\", \"TimerSetInformation\":\"0x%x\", \"TimerSetInformationLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TimerHandle, TimerSetInformationClass, TimerSetInformation, TimerSetInformationLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*356 NTSTATUS NtSetTimerResolution (ULONG DesiredTime, BOOLEAN SetResolution, PULONG ActualTime);*/
void on_cb_NtSetTimerResolution_enter(CPUState *cpu, target_ulong pc, uint32_t DesiredTime, uint32_t SetResolution, uint32_t ActualTime) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x164\",\"syscall_name\" : \"NtSetTimerResolution\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DesiredTime\":\"0x%x\", \"SetResolution\":\"0x%x\", \"ActualTime\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, DesiredTime, SetResolution, ActualTime, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ActualTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ActualTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ActualTime\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ActualTime\" : ");fprintf(outFile, "\"Unable to read ActualTime\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetTimerResolution_return(CPUState *cpu, target_ulong pc, uint32_t DesiredTime, uint32_t SetResolution, uint32_t ActualTime) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x164\",\"syscall_name\" : \"NtSetTimerResolution\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DesiredTime\":\"0x%x\", \"SetResolution\":\"0x%x\", \"ActualTime\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, DesiredTime, SetResolution, ActualTime, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ActualTime;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ActualTime;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ActualTime\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ActualTime\" : ");fprintf(outFile, "\"Unable to read ActualTime\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*357 NTSTATUS NtSetUuidSeed (PCHAR Seed);*/
void on_cb_NtSetUuidSeed_enter(CPUState *cpu, target_ulong pc, uint32_t Seed) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x165\",\"syscall_name\" : \"NtSetUuidSeed\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Seed\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Seed, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetUuidSeed_return(CPUState *cpu, target_ulong pc, uint32_t Seed) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x165\",\"syscall_name\" : \"NtSetUuidSeed\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Seed\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Seed, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*358 NTSTATUS NtSetValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);*/
void on_cb_NtSetValueKey_enter(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t ValueName, uint32_t TitleIndex, uint32_t Type, uint32_t Data, uint32_t DataSize) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x166\",\"syscall_name\" : \"NtSetValueKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"ValueName\":\"0x%x\", \"TitleIndex\":\"0x%x\", \"Type\":\"0x%x\", \"Data\":\"0x%x\", \"DataSize\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, ValueName, TitleIndex, Type, Data, DataSize, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ValueName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ValueName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ValueName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ValueName\" : ");fprintf(outFile, "\"Unable to read ValueName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetValueKey_return(CPUState *cpu, target_ulong pc, uint32_t KeyHandle, uint32_t ValueName, uint32_t TitleIndex, uint32_t Type, uint32_t Data, uint32_t DataSize) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x166\",\"syscall_name\" : \"NtSetValueKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyHandle\":\"0x%x\", \"ValueName\":\"0x%x\", \"TitleIndex\":\"0x%x\", \"Type\":\"0x%x\", \"Data\":\"0x%x\", \"DataSize\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyHandle, ValueName, TitleIndex, Type, Data, DataSize, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ValueName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ValueName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ValueName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ValueName\" : ");fprintf(outFile, "\"Unable to read ValueName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*359 NTSTATUS NtSetVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);*/
void on_cb_NtSetVolumeInformationFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t FsInformation, uint32_t Length, uint32_t FsInformationClass) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x167\",\"syscall_name\" : \"NtSetVolumeInformationFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"FsInformation\":\"0x%x\", \"Length\":\"0x%x\", \"FsInformationClass\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, FsInformation, Length, FsInformationClass, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSetVolumeInformationFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t FsInformation, uint32_t Length, uint32_t FsInformationClass) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x167\",\"syscall_name\" : \"NtSetVolumeInformationFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"FsInformation\":\"0x%x\", \"Length\":\"0x%x\", \"FsInformationClass\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, FsInformation, Length, FsInformationClass, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*360 NTSTATUS NtShutdownSystem (SHUTDOWN_ACTION Action);*/
void on_cb_NtShutdownSystem_enter(CPUState *cpu, target_ulong pc, uint32_t Action) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x168\",\"syscall_name\" : \"NtShutdownSystem\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Action\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Action, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtShutdownSystem_return(CPUState *cpu, target_ulong pc, uint32_t Action) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x168\",\"syscall_name\" : \"NtShutdownSystem\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Action\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Action, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*361 NTSTATUS NtShutdownWorkerFactory (HANDLE WorkerFactoryHandle, LONG *PendingWorkerCount);*/
void on_cb_NtShutdownWorkerFactory_enter(CPUState *cpu, target_ulong pc, uint32_t WorkerFactoryHandle, uint32_t PendingWorkerCount) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x169\",\"syscall_name\" : \"NtShutdownWorkerFactory\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"WorkerFactoryHandle\":\"0x%x\", \"PendingWorkerCount\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, WorkerFactoryHandle, PendingWorkerCount, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PendingWorkerCount;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PendingWorkerCount;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PendingWorkerCount\" : ");dump_LONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PendingWorkerCount\" : ");fprintf(outFile, "\"Unable to read PendingWorkerCount\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtShutdownWorkerFactory_return(CPUState *cpu, target_ulong pc, uint32_t WorkerFactoryHandle, uint32_t PendingWorkerCount) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x169\",\"syscall_name\" : \"NtShutdownWorkerFactory\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"WorkerFactoryHandle\":\"0x%x\", \"PendingWorkerCount\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, WorkerFactoryHandle, PendingWorkerCount, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PendingWorkerCount;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PendingWorkerCount;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PendingWorkerCount\" : ");dump_LONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PendingWorkerCount\" : ");fprintf(outFile, "\"Unable to read PendingWorkerCount\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*362 NTSTATUS NtSignalAndWaitForSingleObject (HANDLE SignalHandle, HANDLE WaitHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);*/
void on_cb_NtSignalAndWaitForSingleObject_enter(CPUState *cpu, target_ulong pc, uint32_t SignalHandle, uint32_t WaitHandle, uint32_t Alertable, uint32_t Timeout) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x16a\",\"syscall_name\" : \"NtSignalAndWaitForSingleObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SignalHandle\":\"0x%x\", \"WaitHandle\":\"0x%x\", \"Alertable\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SignalHandle, WaitHandle, Alertable, Timeout, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSignalAndWaitForSingleObject_return(CPUState *cpu, target_ulong pc, uint32_t SignalHandle, uint32_t WaitHandle, uint32_t Alertable, uint32_t Timeout) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x16a\",\"syscall_name\" : \"NtSignalAndWaitForSingleObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SignalHandle\":\"0x%x\", \"WaitHandle\":\"0x%x\", \"Alertable\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SignalHandle, WaitHandle, Alertable, Timeout, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*363 NTSTATUS NtSinglePhaseReject (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);*/
void on_cb_NtSinglePhaseReject_enter(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x16b\",\"syscall_name\" : \"NtSinglePhaseReject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSinglePhaseReject_return(CPUState *cpu, target_ulong pc, uint32_t EnlistmentHandle, uint32_t TmVirtualClock) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x16b\",\"syscall_name\" : \"NtSinglePhaseReject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EnlistmentHandle\":\"0x%x\", \"TmVirtualClock\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EnlistmentHandle, TmVirtualClock, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TmVirtualClock;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TmVirtualClock;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TmVirtualClock\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TmVirtualClock\" : ");fprintf(outFile, "\"Unable to read TmVirtualClock\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*364 NTSTATUS NtStartProfile (HANDLE ProfileHandle);*/
void on_cb_NtStartProfile_enter(CPUState *cpu, target_ulong pc, uint32_t ProfileHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x16c\",\"syscall_name\" : \"NtStartProfile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProfileHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProfileHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtStartProfile_return(CPUState *cpu, target_ulong pc, uint32_t ProfileHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x16c\",\"syscall_name\" : \"NtStartProfile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProfileHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProfileHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*365 NTSTATUS NtStopProfile (HANDLE ProfileHandle);*/
void on_cb_NtStopProfile_enter(CPUState *cpu, target_ulong pc, uint32_t ProfileHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x16d\",\"syscall_name\" : \"NtStopProfile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProfileHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProfileHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtStopProfile_return(CPUState *cpu, target_ulong pc, uint32_t ProfileHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x16d\",\"syscall_name\" : \"NtStopProfile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProfileHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProfileHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*366 NTSTATUS NtSuspendProcess (HANDLE ProcessHandle);*/
void on_cb_NtSuspendProcess_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x16e\",\"syscall_name\" : \"NtSuspendProcess\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSuspendProcess_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x16e\",\"syscall_name\" : \"NtSuspendProcess\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*367 NTSTATUS NtSuspendThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);*/
void on_cb_NtSuspendThread_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t PreviousSuspendCount) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x16f\",\"syscall_name\" : \"NtSuspendThread\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"PreviousSuspendCount\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, PreviousSuspendCount, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PreviousSuspendCount;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousSuspendCount;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousSuspendCount\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousSuspendCount\" : ");fprintf(outFile, "\"Unable to read PreviousSuspendCount\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSuspendThread_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t PreviousSuspendCount) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x16f\",\"syscall_name\" : \"NtSuspendThread\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"PreviousSuspendCount\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, PreviousSuspendCount, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = PreviousSuspendCount;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = PreviousSuspendCount;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"PreviousSuspendCount\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"PreviousSuspendCount\" : ");fprintf(outFile, "\"Unable to read PreviousSuspendCount\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*368 NTSTATUS NtSystemDebugControl (SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength);*/
void on_cb_NtSystemDebugControl_enter(CPUState *cpu, target_ulong pc, uint32_t Command, uint32_t InputBuffer, uint32_t InputBufferLength, uint32_t OutputBuffer, uint32_t OutputBufferLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x170\",\"syscall_name\" : \"NtSystemDebugControl\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Command\":\"0x%x\", \"InputBuffer\":\"0x%x\", \"InputBufferLength\":\"0x%x\", \"OutputBuffer\":\"0x%x\", \"OutputBufferLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Command, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtSystemDebugControl_return(CPUState *cpu, target_ulong pc, uint32_t Command, uint32_t InputBuffer, uint32_t InputBufferLength, uint32_t OutputBuffer, uint32_t OutputBufferLength, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x170\",\"syscall_name\" : \"NtSystemDebugControl\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Command\":\"0x%x\", \"InputBuffer\":\"0x%x\", \"InputBufferLength\":\"0x%x\", \"OutputBuffer\":\"0x%x\", \"OutputBufferLength\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Command, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*369 NTSTATUS NtTerminateJobObject (HANDLE JobHandle, NTSTATUS ExitStatus);*/
void on_cb_NtTerminateJobObject_enter(CPUState *cpu, target_ulong pc, uint32_t JobHandle, uint32_t ExitStatus) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x171\",\"syscall_name\" : \"NtTerminateJobObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"JobHandle\":\"0x%x\", \"ExitStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, JobHandle, ExitStatus, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtTerminateJobObject_return(CPUState *cpu, target_ulong pc, uint32_t JobHandle, uint32_t ExitStatus) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x171\",\"syscall_name\" : \"NtTerminateJobObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"JobHandle\":\"0x%x\", \"ExitStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, JobHandle, ExitStatus, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*370 NTSTATUS NtTerminateProcess (HANDLE ProcessHandle, NTSTATUS ExitStatus);*/
void on_cb_NtTerminateProcess_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t ExitStatus) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x172\",\"syscall_name\" : \"NtTerminateProcess\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"ExitStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, ExitStatus, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtTerminateProcess_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t ExitStatus) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x172\",\"syscall_name\" : \"NtTerminateProcess\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"ExitStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, ExitStatus, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*371 NTSTATUS NtTerminateThread (HANDLE ThreadHandle, NTSTATUS ExitStatus);*/
void on_cb_NtTerminateThread_enter(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t ExitStatus) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x173\",\"syscall_name\" : \"NtTerminateThread\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"ExitStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, ExitStatus, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtTerminateThread_return(CPUState *cpu, target_ulong pc, uint32_t ThreadHandle, uint32_t ExitStatus) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x173\",\"syscall_name\" : \"NtTerminateThread\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ThreadHandle\":\"0x%x\", \"ExitStatus\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ThreadHandle, ExitStatus, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*372 NTSTATUS NtTestAlert ();*/
void on_cb_NtTestAlert_enter(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x174\",\"syscall_name\" : \"NtTestAlert\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtTestAlert_return(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x174\",\"syscall_name\" : \"NtTestAlert\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*373 NTSTATUS NtThawRegistry ();*/
void on_cb_NtThawRegistry_enter(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x175\",\"syscall_name\" : \"NtThawRegistry\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtThawRegistry_return(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x175\",\"syscall_name\" : \"NtThawRegistry\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*374 NTSTATUS NtThawTransactions ();*/
void on_cb_NtThawTransactions_enter(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x176\",\"syscall_name\" : \"NtThawTransactions\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtThawTransactions_return(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x176\",\"syscall_name\" : \"NtThawTransactions\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*375 NTSTATUS NtTraceControl (ULONG FunctionCode, PVOID InBuffer, ULONG InBufferLen, PVOID OutBuffer, ULONG OutBufferLen, PULONG ReturnLength);*/
void on_cb_NtTraceControl_enter(CPUState *cpu, target_ulong pc, uint32_t FunctionCode, uint32_t InBuffer, uint32_t InBufferLen, uint32_t OutBuffer, uint32_t OutBufferLen, uint32_t ReturnLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x177\",\"syscall_name\" : \"NtTraceControl\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FunctionCode\":\"0x%x\", \"InBuffer\":\"0x%x\", \"InBufferLen\":\"0x%x\", \"OutBuffer\":\"0x%x\", \"OutBufferLen\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FunctionCode, InBuffer, InBufferLen, OutBuffer, OutBufferLen, ReturnLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtTraceControl_return(CPUState *cpu, target_ulong pc, uint32_t FunctionCode, uint32_t InBuffer, uint32_t InBufferLen, uint32_t OutBuffer, uint32_t OutBufferLen, uint32_t ReturnLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x177\",\"syscall_name\" : \"NtTraceControl\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FunctionCode\":\"0x%x\", \"InBuffer\":\"0x%x\", \"InBufferLen\":\"0x%x\", \"OutBuffer\":\"0x%x\", \"OutBufferLen\":\"0x%x\", \"ReturnLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FunctionCode, InBuffer, InBufferLen, OutBuffer, OutBufferLen, ReturnLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ReturnLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ReturnLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ReturnLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ReturnLength\" : ");fprintf(outFile, "\"Unable to read ReturnLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*376 NTSTATUS NtTraceEvent (HANDLE TraceHandle, ULONG Flags, ULONG FieldSize, PVOID Fields);*/
void on_cb_NtTraceEvent_enter(CPUState *cpu, target_ulong pc, uint32_t TraceHandle, uint32_t Flags, uint32_t FieldSize, uint32_t Fields) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x178\",\"syscall_name\" : \"NtTraceEvent\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TraceHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"FieldSize\":\"0x%x\", \"Fields\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TraceHandle, Flags, FieldSize, Fields, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtTraceEvent_return(CPUState *cpu, target_ulong pc, uint32_t TraceHandle, uint32_t Flags, uint32_t FieldSize, uint32_t Fields) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x178\",\"syscall_name\" : \"NtTraceEvent\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TraceHandle\":\"0x%x\", \"Flags\":\"0x%x\", \"FieldSize\":\"0x%x\", \"Fields\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TraceHandle, Flags, FieldSize, Fields, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*377 NTSTATUS NtTranslateFilePath (PFILE_PATH InputFilePath, ULONG OutputType, PFILE_PATH OutputFilePath, PULONG OutputFilePathLength);*/
void on_cb_NtTranslateFilePath_enter(CPUState *cpu, target_ulong pc, uint32_t InputFilePath, uint32_t OutputType, uint32_t OutputFilePath, uint32_t OutputFilePathLength) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x179\",\"syscall_name\" : \"NtTranslateFilePath\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"InputFilePath\":\"0x%x\", \"OutputType\":\"0x%x\", \"OutputFilePath\":\"0x%x\", \"OutputFilePathLength\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, InputFilePath, OutputType, OutputFilePath, OutputFilePathLength, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = OutputFilePathLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = OutputFilePathLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"OutputFilePathLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"OutputFilePathLength\" : ");fprintf(outFile, "\"Unable to read OutputFilePathLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtTranslateFilePath_return(CPUState *cpu, target_ulong pc, uint32_t InputFilePath, uint32_t OutputType, uint32_t OutputFilePath, uint32_t OutputFilePathLength) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x179\",\"syscall_name\" : \"NtTranslateFilePath\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"InputFilePath\":\"0x%x\", \"OutputType\":\"0x%x\", \"OutputFilePath\":\"0x%x\", \"OutputFilePathLength\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, InputFilePath, OutputType, OutputFilePath, OutputFilePathLength, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = OutputFilePathLength;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = OutputFilePathLength;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"OutputFilePathLength\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"OutputFilePathLength\" : ");fprintf(outFile, "\"Unable to read OutputFilePathLength\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*378 NTSTATUS NtUmsThreadYield (PVOID SchedulerParam);*/
void on_cb_NtUmsThreadYield_enter(CPUState *cpu, target_ulong pc, uint32_t SchedulerParam) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x17a\",\"syscall_name\" : \"NtUmsThreadYield\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SchedulerParam\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, SchedulerParam, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtUmsThreadYield_return(CPUState *cpu, target_ulong pc, uint32_t SchedulerParam) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x17a\",\"syscall_name\" : \"NtUmsThreadYield\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"SchedulerParam\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, SchedulerParam, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*379 NTSTATUS NtUnloadDriver (PUNICODE_STRING DriverServiceName);*/
void on_cb_NtUnloadDriver_enter(CPUState *cpu, target_ulong pc, uint32_t DriverServiceName) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x17b\",\"syscall_name\" : \"NtUnloadDriver\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DriverServiceName\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, DriverServiceName, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DriverServiceName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DriverServiceName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DriverServiceName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DriverServiceName\" : ");fprintf(outFile, "\"Unable to read DriverServiceName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtUnloadDriver_return(CPUState *cpu, target_ulong pc, uint32_t DriverServiceName) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x17b\",\"syscall_name\" : \"NtUnloadDriver\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DriverServiceName\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, DriverServiceName, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = DriverServiceName;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = DriverServiceName;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            UNICODE_STRING pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"DriverServiceName\" : ");dump_UNICODE_STRING(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"DriverServiceName\" : ");fprintf(outFile, "\"Unable to read DriverServiceName\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*380 NTSTATUS NtUnloadKey (POBJECT_ATTRIBUTES TargetKey);*/
void on_cb_NtUnloadKey_enter(CPUState *cpu, target_ulong pc, uint32_t TargetKey) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x17c\",\"syscall_name\" : \"NtUnloadKey\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetKey\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TargetKey, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetKey;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetKey;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetKey\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetKey\" : ");fprintf(outFile, "\"Unable to read TargetKey\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtUnloadKey_return(CPUState *cpu, target_ulong pc, uint32_t TargetKey) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x17c\",\"syscall_name\" : \"NtUnloadKey\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetKey\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TargetKey, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetKey;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetKey;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetKey\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetKey\" : ");fprintf(outFile, "\"Unable to read TargetKey\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*381 NTSTATUS NtUnloadKey2 (POBJECT_ATTRIBUTES TargetKey, ULONG Flags);*/
void on_cb_NtUnloadKey2_enter(CPUState *cpu, target_ulong pc, uint32_t TargetKey, uint32_t Flags) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x17d\",\"syscall_name\" : \"NtUnloadKey2\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetKey\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TargetKey, Flags, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetKey;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetKey;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetKey\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetKey\" : ");fprintf(outFile, "\"Unable to read TargetKey\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtUnloadKey2_return(CPUState *cpu, target_ulong pc, uint32_t TargetKey, uint32_t Flags) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x17d\",\"syscall_name\" : \"NtUnloadKey2\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetKey\":\"0x%x\", \"Flags\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TargetKey, Flags, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetKey;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetKey;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetKey\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetKey\" : ");fprintf(outFile, "\"Unable to read TargetKey\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*382 NTSTATUS NtUnloadKeyEx (POBJECT_ATTRIBUTES TargetKey, HANDLE Event);*/
void on_cb_NtUnloadKeyEx_enter(CPUState *cpu, target_ulong pc, uint32_t TargetKey, uint32_t Event) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x17e\",\"syscall_name\" : \"NtUnloadKeyEx\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetKey\":\"0x%x\", \"Event\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, TargetKey, Event, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetKey;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetKey;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetKey\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetKey\" : ");fprintf(outFile, "\"Unable to read TargetKey\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtUnloadKeyEx_return(CPUState *cpu, target_ulong pc, uint32_t TargetKey, uint32_t Event) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x17e\",\"syscall_name\" : \"NtUnloadKeyEx\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"TargetKey\":\"0x%x\", \"Event\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, TargetKey, Event, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = TargetKey;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = TargetKey;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            OBJECT_ATTRIBUTES pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"TargetKey\" : ");dump_OBJECT_ATTRIBUTES(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"TargetKey\" : ");fprintf(outFile, "\"Unable to read TargetKey\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*383 NTSTATUS NtUnlockFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key);*/
void on_cb_NtUnlockFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t ByteOffset, uint32_t Length, uint32_t Key) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x17f\",\"syscall_name\" : \"NtUnlockFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"ByteOffset\":\"0x%x\", \"Length\":\"0x%x\", \"Key\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, ByteOffset, Length, Key, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ByteOffset;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ByteOffset;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ByteOffset\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ByteOffset\" : ");fprintf(outFile, "\"Unable to read ByteOffset\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Length;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Length;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Length\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Length\" : ");fprintf(outFile, "\"Unable to read Length\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtUnlockFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t IoStatusBlock, uint32_t ByteOffset, uint32_t Length, uint32_t Key) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x17f\",\"syscall_name\" : \"NtUnlockFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"ByteOffset\":\"0x%x\", \"Length\":\"0x%x\", \"Key\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, IoStatusBlock, ByteOffset, Length, Key, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ByteOffset;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ByteOffset;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ByteOffset\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ByteOffset\" : ");fprintf(outFile, "\"Unable to read ByteOffset\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Length;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Length;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Length\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Length\" : ");fprintf(outFile, "\"Unable to read Length\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*384 NTSTATUS NtUnlockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);*/
void on_cb_NtUnlockVirtualMemory_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t RegionSize, uint32_t MapType) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x180\",\"syscall_name\" : \"NtUnlockVirtualMemory\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"RegionSize\":\"0x%x\", \"MapType\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, RegionSize, MapType, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtUnlockVirtualMemory_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t RegionSize, uint32_t MapType) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x180\",\"syscall_name\" : \"NtUnlockVirtualMemory\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"RegionSize\":\"0x%x\", \"MapType\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, RegionSize, MapType, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = BaseAddress;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = BaseAddress;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            PVOID pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"BaseAddress\" : ");dump_PVOID(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"BaseAddress\" : ");fprintf(outFile, "\"Unable to read BaseAddress\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*385 NTSTATUS NtUnmapViewOfSection (HANDLE ProcessHandle, PVOID BaseAddress);*/
void on_cb_NtUnmapViewOfSection_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x181\",\"syscall_name\" : \"NtUnmapViewOfSection\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtUnmapViewOfSection_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x181\",\"syscall_name\" : \"NtUnmapViewOfSection\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*386 NTSTATUS NtVdmControl (VDMSERVICECLASS Service, PVOID ServiceData);*/
void on_cb_NtVdmControl_enter(CPUState *cpu, target_ulong pc, uint32_t Service, uint32_t ServiceData) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x182\",\"syscall_name\" : \"NtVdmControl\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Service\":\"0x%x\", \"ServiceData\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Service, ServiceData, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtVdmControl_return(CPUState *cpu, target_ulong pc, uint32_t Service, uint32_t ServiceData) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x182\",\"syscall_name\" : \"NtVdmControl\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Service\":\"0x%x\", \"ServiceData\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Service, ServiceData, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*387 NTSTATUS NtWaitForDebugEvent (HANDLE DebugObjectHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PDBGUI_WAIT_STATE_CHANGE WaitStateChange);*/
void on_cb_NtWaitForDebugEvent_enter(CPUState *cpu, target_ulong pc, uint32_t DebugObjectHandle, uint32_t Alertable, uint32_t Timeout, uint32_t WaitStateChange) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x183\",\"syscall_name\" : \"NtWaitForDebugEvent\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DebugObjectHandle\":\"0x%x\", \"Alertable\":\"0x%x\", \"Timeout\":\"0x%x\", \"WaitStateChange\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, DebugObjectHandle, Alertable, Timeout, WaitStateChange, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtWaitForDebugEvent_return(CPUState *cpu, target_ulong pc, uint32_t DebugObjectHandle, uint32_t Alertable, uint32_t Timeout, uint32_t WaitStateChange) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x183\",\"syscall_name\" : \"NtWaitForDebugEvent\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"DebugObjectHandle\":\"0x%x\", \"Alertable\":\"0x%x\", \"Timeout\":\"0x%x\", \"WaitStateChange\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, DebugObjectHandle, Alertable, Timeout, WaitStateChange, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*388 NTSTATUS NtWaitForKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);*/
void on_cb_NtWaitForKeyedEvent_enter(CPUState *cpu, target_ulong pc, uint32_t KeyedEventHandle, uint32_t KeyValue, uint32_t Alertable, uint32_t Timeout) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x184\",\"syscall_name\" : \"NtWaitForKeyedEvent\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyedEventHandle\":\"0x%x\", \"KeyValue\":\"0x%x\", \"Alertable\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, KeyedEventHandle, KeyValue, Alertable, Timeout, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtWaitForKeyedEvent_return(CPUState *cpu, target_ulong pc, uint32_t KeyedEventHandle, uint32_t KeyValue, uint32_t Alertable, uint32_t Timeout) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x184\",\"syscall_name\" : \"NtWaitForKeyedEvent\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"KeyedEventHandle\":\"0x%x\", \"KeyValue\":\"0x%x\", \"Alertable\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, KeyedEventHandle, KeyValue, Alertable, Timeout, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*389 NTSTATUS NtWaitForMultipleObjects (ULONG Count, HANDLE Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);*/
void on_cb_NtWaitForMultipleObjects_enter(CPUState *cpu, target_ulong pc, uint32_t Count, uint32_t Handles, uint32_t WaitType, uint32_t Alertable, uint32_t Timeout) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x185\",\"syscall_name\" : \"NtWaitForMultipleObjects\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Count\":\"0x%x\", \"Handles\":\"0x%x\", \"WaitType\":\"0x%x\", \"Alertable\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Count, Handles, WaitType, Alertable, Timeout, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtWaitForMultipleObjects_return(CPUState *cpu, target_ulong pc, uint32_t Count, uint32_t Handles, uint32_t WaitType, uint32_t Alertable, uint32_t Timeout) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x185\",\"syscall_name\" : \"NtWaitForMultipleObjects\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Count\":\"0x%x\", \"Handles\":\"0x%x\", \"WaitType\":\"0x%x\", \"Alertable\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Count, Handles, WaitType, Alertable, Timeout, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*390 NTSTATUS NtWaitForMultipleObjects32 (ULONG Count, LONG Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);*/
void on_cb_NtWaitForMultipleObjects32_enter(CPUState *cpu, target_ulong pc, uint32_t Count, uint32_t Handles, uint32_t WaitType, uint32_t Alertable, uint32_t Timeout) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x186\",\"syscall_name\" : \"NtWaitForMultipleObjects32\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Count\":\"0x%x\", \"Handles\":\"0x%x\", \"WaitType\":\"0x%x\", \"Alertable\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Count, Handles, WaitType, Alertable, Timeout, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtWaitForMultipleObjects32_return(CPUState *cpu, target_ulong pc, uint32_t Count, uint32_t Handles, uint32_t WaitType, uint32_t Alertable, uint32_t Timeout) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x186\",\"syscall_name\" : \"NtWaitForMultipleObjects32\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Count\":\"0x%x\", \"Handles\":\"0x%x\", \"WaitType\":\"0x%x\", \"Alertable\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Count, Handles, WaitType, Alertable, Timeout, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*391 NTSTATUS NtWaitForSingleObject (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);*/
void on_cb_NtWaitForSingleObject_enter(CPUState *cpu, target_ulong pc, uint32_t Handle, uint32_t Alertable, uint32_t Timeout) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x187\",\"syscall_name\" : \"NtWaitForSingleObject\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Handle\":\"0x%x\", \"Alertable\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, Handle, Alertable, Timeout, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtWaitForSingleObject_return(CPUState *cpu, target_ulong pc, uint32_t Handle, uint32_t Alertable, uint32_t Timeout) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x187\",\"syscall_name\" : \"NtWaitForSingleObject\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"Handle\":\"0x%x\", \"Alertable\":\"0x%x\", \"Timeout\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, Handle, Alertable, Timeout, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = Timeout;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Timeout;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Timeout\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Timeout\" : ");fprintf(outFile, "\"Unable to read Timeout\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*392 NTSTATUS NtWaitForWorkViaWorkerFactory (HANDLE WorkerFactoryHandle, PFILE_IO_COMPLETION_INFORMATION MiniPacket);*/
void on_cb_NtWaitForWorkViaWorkerFactory_enter(CPUState *cpu, target_ulong pc, uint32_t WorkerFactoryHandle, uint32_t MiniPacket) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x188\",\"syscall_name\" : \"NtWaitForWorkViaWorkerFactory\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"WorkerFactoryHandle\":\"0x%x\", \"MiniPacket\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, WorkerFactoryHandle, MiniPacket, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtWaitForWorkViaWorkerFactory_return(CPUState *cpu, target_ulong pc, uint32_t WorkerFactoryHandle, uint32_t MiniPacket) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x188\",\"syscall_name\" : \"NtWaitForWorkViaWorkerFactory\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"WorkerFactoryHandle\":\"0x%x\", \"MiniPacket\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, WorkerFactoryHandle, MiniPacket, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*393 NTSTATUS NtWaitHighEventPair (HANDLE EventPairHandle);*/
void on_cb_NtWaitHighEventPair_enter(CPUState *cpu, target_ulong pc, uint32_t EventPairHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x189\",\"syscall_name\" : \"NtWaitHighEventPair\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventPairHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventPairHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtWaitHighEventPair_return(CPUState *cpu, target_ulong pc, uint32_t EventPairHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x189\",\"syscall_name\" : \"NtWaitHighEventPair\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventPairHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventPairHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*394 NTSTATUS NtWaitLowEventPair (HANDLE EventPairHandle);*/
void on_cb_NtWaitLowEventPair_enter(CPUState *cpu, target_ulong pc, uint32_t EventPairHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x18a\",\"syscall_name\" : \"NtWaitLowEventPair\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventPairHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, EventPairHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtWaitLowEventPair_return(CPUState *cpu, target_ulong pc, uint32_t EventPairHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x18a\",\"syscall_name\" : \"NtWaitLowEventPair\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"EventPairHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, EventPairHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*395 NTSTATUS NtWorkerFactoryWorkerReady (HANDLE WorkerFactoryHandle);*/
void on_cb_NtWorkerFactoryWorkerReady_enter(CPUState *cpu, target_ulong pc, uint32_t WorkerFactoryHandle) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x18b\",\"syscall_name\" : \"NtWorkerFactoryWorkerReady\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"WorkerFactoryHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, WorkerFactoryHandle, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtWorkerFactoryWorkerReady_return(CPUState *cpu, target_ulong pc, uint32_t WorkerFactoryHandle) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x18b\",\"syscall_name\" : \"NtWorkerFactoryWorkerReady\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"WorkerFactoryHandle\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, WorkerFactoryHandle, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*396 NTSTATUS NtWriteFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);*/
void on_cb_NtWriteFile_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t Buffer, uint32_t Length, uint32_t ByteOffset, uint32_t Key) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x18c\",\"syscall_name\" : \"NtWriteFile\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\", \"ByteOffset\":\"0x%x\", \"Key\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, ByteOffset, Key, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ByteOffset;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ByteOffset;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ByteOffset\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ByteOffset\" : ");fprintf(outFile, "\"Unable to read ByteOffset\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Key;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Key;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Key\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Key\" : ");fprintf(outFile, "\"Unable to read Key\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtWriteFile_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t Buffer, uint32_t Length, uint32_t ByteOffset, uint32_t Key) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x18c\",\"syscall_name\" : \"NtWriteFile\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"Buffer\":\"0x%x\", \"Length\":\"0x%x\", \"ByteOffset\":\"0x%x\", \"Key\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, ByteOffset, Key, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ByteOffset;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ByteOffset;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ByteOffset\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ByteOffset\" : ");fprintf(outFile, "\"Unable to read ByteOffset\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Key;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Key;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Key\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Key\" : ");fprintf(outFile, "\"Unable to read Key\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*397 NTSTATUS NtWriteFileGather (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);*/
void on_cb_NtWriteFileGather_enter(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t SegmentArray, uint32_t Length, uint32_t ByteOffset, uint32_t Key) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x18d\",\"syscall_name\" : \"NtWriteFileGather\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"SegmentArray\":\"0x%x\", \"Length\":\"0x%x\", \"ByteOffset\":\"0x%x\", \"Key\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, SegmentArray, Length, ByteOffset, Key, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ByteOffset;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ByteOffset;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ByteOffset\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ByteOffset\" : ");fprintf(outFile, "\"Unable to read ByteOffset\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Key;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Key;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Key\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Key\" : ");fprintf(outFile, "\"Unable to read Key\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtWriteFileGather_return(CPUState *cpu, target_ulong pc, uint32_t FileHandle, uint32_t Event, uint32_t ApcRoutine, uint32_t ApcContext, uint32_t IoStatusBlock, uint32_t SegmentArray, uint32_t Length, uint32_t ByteOffset, uint32_t Key) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x18d\",\"syscall_name\" : \"NtWriteFileGather\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"FileHandle\":\"0x%x\", \"Event\":\"0x%x\", \"ApcRoutine\":\"0x%x\", \"ApcContext\":\"0x%x\", \"IoStatusBlock\":\"0x%x\", \"SegmentArray\":\"0x%x\", \"Length\":\"0x%x\", \"ByteOffset\":\"0x%x\", \"Key\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, SegmentArray, Length, ByteOffset, Key, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    {
        uint32_t paddr = ByteOffset;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = ByteOffset;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            LARGE_INTEGER pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"ByteOffset\" : ");dump_LARGE_INTEGER(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"ByteOffset\" : ");fprintf(outFile, "\"Unable to read ByteOffset\"");
        }
        fprintf(outFile, ",");

    }
    {
        uint32_t paddr = Key;
        bool fail_read = false;
        {
            uint32_t tmpv0;
            tmpv0 = 0;
            uint32_t tmpv1;
            tmpv1 = 0;
            tmpv0 = Key;
            for (int i=1; i<1; ++i) {
                if (!fail_read) {
                    if (-1 == panda_virtual_memory_read(cpu, tmpv0, (uint8_t*)(&tmpv1), sizeof(tmpv1))) {
                        fail_read = true;
                        break;
                    } else {
                        tmpv0 = tmpv1;
                    }
                }
            }
            paddr = tmpv0;
        }
        if (!fail_read) {
            ULONG pargv;
            memset((void*)(&pargv), 0, sizeof(pargv));
            if (-1 == panda_virtual_memory_read(cpu, paddr, (uint8_t*)(&pargv), sizeof(pargv))) {
                fail_read = true;
            }
            if (!fail_read) {
                fprintf(outFile, "\"Key\" : ");dump_ULONG(cpu, pargv);
            }
        }
        if (fail_read) {
            fprintf(outFile, "\"Key\" : ");fprintf(outFile, "\"Unable to read Key\"");
        }
        fprintf(outFile, ",");

    }
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*398 NTSTATUS NtWriteRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);*/
void on_cb_NtWriteRequestData_enter(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Message, uint32_t DataEntryIndex, uint32_t Buffer, uint32_t BufferSize, uint32_t NumberOfBytesWritten) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x18e\",\"syscall_name\" : \"NtWriteRequestData\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Message\":\"0x%x\", \"DataEntryIndex\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\", \"NumberOfBytesWritten\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Message, DataEntryIndex, Buffer, BufferSize, NumberOfBytesWritten, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtWriteRequestData_return(CPUState *cpu, target_ulong pc, uint32_t PortHandle, uint32_t Message, uint32_t DataEntryIndex, uint32_t Buffer, uint32_t BufferSize, uint32_t NumberOfBytesWritten) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x18e\",\"syscall_name\" : \"NtWriteRequestData\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"PortHandle\":\"0x%x\", \"Message\":\"0x%x\", \"DataEntryIndex\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\", \"NumberOfBytesWritten\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, PortHandle, Message, DataEntryIndex, Buffer, BufferSize, NumberOfBytesWritten, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*399 NTSTATUS NtWriteVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);*/
void on_cb_NtWriteVirtualMemory_enter(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t Buffer, uint32_t BufferSize, uint32_t NumberOfBytesWritten) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x18f\",\"syscall_name\" : \"NtWriteVirtualMemory\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\", \"NumberOfBytesWritten\":\"0x%x\"},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, Buffer, BufferSize, NumberOfBytesWritten, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtWriteVirtualMemory_return(CPUState *cpu, target_ulong pc, uint32_t ProcessHandle, uint32_t BaseAddress, uint32_t Buffer, uint32_t BufferSize, uint32_t NumberOfBytesWritten) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x18f\",\"syscall_name\" : \"NtWriteVirtualMemory\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{\"ProcessHandle\":\"0x%x\", \"BaseAddress\":\"0x%x\", \"Buffer\":\"0x%x\", \"BufferSize\":\"0x%x\", \"NumberOfBytesWritten\":\"0x%x\"},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, ProcessHandle, BaseAddress, Buffer, BufferSize, NumberOfBytesWritten, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/*400 NTSTATUS NtYieldExecution ();*/
void on_cb_NtYieldExecution_enter(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x190\",\"syscall_name\" : \"NtYieldExecution\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

void on_cb_NtYieldExecution_return(CPUState *cpu, target_ulong pc) {
#ifdef TARGET_I386
    target_ulong asid = panda_current_asid(cpu);
    RR_prog_point pp = rr_prog_point();
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x190\",\"syscall_name\" : \"NtYieldExecution\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"", (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count, retval);
    fprintf(outFile, ",\n");
    fprintf(outFile, "\"parameters_detailed\" : {\n");
    fprintf(outFile, "\"-s.e.n.t.i.n.e.l-\" : \"\"\n");
    fprintf(outFile, "}\n");
    fprintf(outFile, "},\n");
#endif
}

/* Missing: NtGdiAbortDoc */
/* Missing: NtGdiAbortPath */
/* Missing: NtGdiAddFontResourceW */
/* Missing: NtGdiAddRemoteFontToDC */
/* Missing: NtGdiAddFontMemResourceEx */
/* Missing: NtGdiRemoveMergeFont */
/* Missing: NtGdiAddRemoteMMInstanceToDC */
/* Missing: NtGdiAlphaBlend */
/* Missing: NtGdiAngleArc */
/* Missing: NtGdiAnyLinkedFonts */
/* Missing: NtGdiFontIsLinked */
/* Missing: NtGdiArcInternal */
/* Missing: NtGdiBeginGdiRendering */
/* Missing: NtGdiBeginPath */
/* Missing: NtGdiBitBlt */
/* Missing: NtGdiCancelDC */
/* Missing: NtGdiCheckBitmapBits */
/* Missing: NtGdiCloseFigure */
/* Missing: NtGdiClearBitmapAttributes */
/* Missing: NtGdiClearBrushAttributes */
/* Missing: NtGdiColorCorrectPalette */
/* Missing: NtGdiCombineRgn */
/* Missing: NtGdiCombineTransform */
/* Missing: NtGdiComputeXformCoefficients */
/* Missing: NtGdiConfigureOPMProtectedOutput */
/* Missing: NtGdiConvertMetafileRect */
/* Missing: NtGdiCreateBitmap */
/* Missing: NtGdiCreateBitmapFromDxSurface */
/* Missing: NtGdiCreateClientObj */
/* Missing: NtGdiCreateColorSpace */
/* Missing: NtGdiCreateColorTransform */
/* Missing: NtGdiCreateCompatibleBitmap */
/* Missing: NtGdiCreateCompatibleDC */
/* Missing: NtGdiCreateDIBBrush */
/* Missing: NtGdiCreateDIBitmapInternal */
/* Missing: NtGdiCreateDIBSection */
/* Missing: NtGdiCreateEllipticRgn */
/* Missing: NtGdiCreateHalftonePalette */
/* Missing: NtGdiCreateHatchBrushInternal */
/* Missing: NtGdiCreateMetafileDC */
/* Missing: NtGdiCreateOPMProtectedOutputs */
/* Missing: NtGdiCreatePaletteInternal */
/* Missing: NtGdiCreatePatternBrushInternal */
/* Missing: NtGdiCreatePen */
/* Missing: NtGdiCreateRectRgn */
/* Missing: NtGdiCreateRoundRectRgn */
/* Missing: NtGdiCreateServerMetaFile */
/* Missing: NtGdiCreateSolidBrush */
/* Missing: NtGdiD3dContextCreate */
/* Missing: NtGdiD3dContextDestroy */
/* Missing: NtGdiD3dContextDestroyAll */
/* Missing: NtGdiD3dValidateTextureStageState */
/* Missing: NtGdiD3dDrawPrimitives2 */
/* Missing: NtGdiDdGetDriverState */
/* Missing: NtGdiDdAddAttachedSurface */
/* Missing: NtGdiDdAlphaBlt */
/* Missing: NtGdiDdAttachSurface */
/* Missing: NtGdiDdBeginMoCompFrame */
/* Missing: NtGdiDdBlt */
/* Missing: NtGdiDdCanCreateSurface */
/* Missing: NtGdiDdCanCreateD3DBuffer */
/* Missing: NtGdiDdColorControl */
/* Missing: NtGdiDdCreateDirectDrawObject */
/* Missing: NtGdiDdCreateSurface */
/* Missing: NtGdiDdCreateD3DBuffer */
/* Missing: NtGdiDdCreateMoComp */
/* Missing: NtGdiDdCreateSurfaceObject */
/* Missing: NtGdiDdDeleteDirectDrawObject */
/* Missing: NtGdiDdDeleteSurfaceObject */
/* Missing: NtGdiDdDestroyMoComp */
/* Missing: NtGdiDdDestroySurface */
/* Missing: NtGdiDdDestroyD3DBuffer */
/* Missing: NtGdiDdEndMoCompFrame */
/* Missing: NtGdiDdFlip */
/* Missing: NtGdiDdFlipToGDISurface */
/* Missing: NtGdiDdGetAvailDriverMemory */
/* Missing: NtGdiDdGetBltStatus */
/* Missing: NtGdiDdGetDC */
/* Missing: NtGdiDdGetDriverInfo */
/* Missing: NtGdiDdGetDxHandle */
/* Missing: NtGdiDdGetFlipStatus */
/* Missing: NtGdiDdGetInternalMoCompInfo */
/* Missing: NtGdiDdGetMoCompBuffInfo */
/* Missing: NtGdiDdGetMoCompGuids */
/* Missing: NtGdiDdGetMoCompFormats */
/* Missing: NtGdiDdGetScanLine */
/* Missing: NtGdiDdLock */
/* Missing: NtGdiDdLockD3D */
/* Missing: NtGdiDdQueryDirectDrawObject */
/* Missing: NtGdiDdQueryMoCompStatus */
/* Missing: NtGdiDdReenableDirectDrawObject */
/* Missing: NtGdiDdReleaseDC */
/* Missing: NtGdiDdRenderMoComp */
/* Missing: NtGdiDdResetVisrgn */
/* Missing: NtGdiDdSetColorKey */
/* Missing: NtGdiDdSetExclusiveMode */
/* Missing: NtGdiDdSetGammaRamp */
/* Missing: NtGdiDdCreateSurfaceEx */
/* Missing: NtGdiDdSetOverlayPosition */
/* Missing: NtGdiDdUnattachSurface */
/* Missing: NtGdiDdUnlock */
/* Missing: NtGdiDdUnlockD3D */
/* Missing: NtGdiDdUpdateOverlay */
/* Missing: NtGdiDdWaitForVerticalBlank */
/* Missing: NtGdiDvpCanCreateVideoPort */
/* Missing: NtGdiDvpColorControl */
/* Missing: NtGdiDvpCreateVideoPort */
/* Missing: NtGdiDvpDestroyVideoPort */
/* Missing: NtGdiDvpFlipVideoPort */
/* Missing: NtGdiDvpGetVideoPortBandwidth */
/* Missing: NtGdiDvpGetVideoPortField */
/* Missing: NtGdiDvpGetVideoPortFlipStatus */
/* Missing: NtGdiDvpGetVideoPortInputFormats */
/* Missing: NtGdiDvpGetVideoPortLine */
/* Missing: NtGdiDvpGetVideoPortOutputFormats */
/* Missing: NtGdiDvpGetVideoPortConnectInfo */
/* Missing: NtGdiDvpGetVideoSignalStatus */
/* Missing: NtGdiDvpUpdateVideoPort */
/* Missing: NtGdiDvpWaitForVideoPortSync */
/* Missing: NtGdiDvpAcquireNotification */
/* Missing: NtGdiDvpReleaseNotification */
/* Missing: NtGdiDxgGenericThunk */
/* Missing: NtGdiDeleteClientObj */
/* Missing: NtGdiDeleteColorSpace */
/* Missing: NtGdiDeleteColorTransform */
/* Missing: NtGdiDeleteObjectApp */
/* Missing: NtGdiDescribePixelFormat */
/* Missing: NtGdiDestroyOPMProtectedOutput */
/* Missing: NtGdiGetPerBandInfo */
/* Missing: NtGdiDoBanding */
/* Missing: NtGdiDoPalette */
/* Missing: NtGdiDrawEscape */
/* Missing: NtGdiEllipse */
/* Missing: NtGdiEnableEudc */
/* Missing: NtGdiEndDoc */
/* Missing: NtGdiEndGdiRendering */
/* Missing: NtGdiEndPage */
/* Missing: NtGdiEndPath */
/* Missing: NtGdiEnumFonts */
/* Missing: NtGdiEnumObjects */
/* Missing: NtGdiEqualRgn */
/* Missing: NtGdiEudcLoadUnloadLink */
/* Missing: NtGdiExcludeClipRect */
/* Missing: NtGdiExtCreatePen */
/* Missing: NtGdiExtCreateRegion */
/* Missing: NtGdiExtEscape */
/* Missing: NtGdiExtFloodFill */
/* Missing: NtGdiExtGetObjectW */
/* Missing: NtGdiExtSelectClipRgn */
/* Missing: NtGdiExtTextOutW */
/* Missing: NtGdiFillPath */
/* Missing: NtGdiFillRgn */
/* Missing: NtGdiFlattenPath */
/* Missing: NtGdiFlush */
/* Missing: NtGdiForceUFIMapping */
/* Missing: NtGdiFrameRgn */
/* Missing: NtGdiFullscreenControl */
/* Missing: NtGdiGetAndSetDCDword */
/* Missing: NtGdiGetAppClipBox */
/* Missing: NtGdiGetBitmapBits */
/* Missing: NtGdiGetBitmapDimension */
/* Missing: NtGdiGetBoundsRect */
/* Missing: NtGdiGetCertificate */
/* Missing: NtGdiGetCertificateSize */
/* Missing: NtGdiGetCharABCWidthsW */
/* Missing: NtGdiGetCharacterPlacementW */
/* Missing: NtGdiGetCharSet */
/* Missing: NtGdiGetCharWidthW */
/* Missing: NtGdiGetCharWidthInfo */
/* Missing: NtGdiGetColorAdjustment */
/* Missing: NtGdiGetColorSpaceforBitmap */
/* Missing: NtGdiGetCOPPCompatibleOPMInformation */
/* Missing: NtGdiGetDCDword */
/* Missing: NtGdiGetDCforBitmap */
/* Missing: NtGdiGetDCObject */
/* Missing: NtGdiGetDCPoint */
/* Missing: NtGdiGetDeviceCaps */
/* Missing: NtGdiGetDeviceGammaRamp */
/* Missing: NtGdiGetDeviceCapsAll */
/* Missing: NtGdiGetDIBitsInternal */
/* Missing: NtGdiGetETM */
/* Missing: NtGdiGetEudcTimeStampEx */
/* Missing: NtGdiGetFontData */
/* Missing: NtGdiGetFontFileData */
/* Missing: NtGdiGetFontFileInfo */
/* Missing: NtGdiGetFontResourceInfoInternalW */
/* Missing: NtGdiGetGlyphIndicesW */
/* Missing: NtGdiGetGlyphIndicesWInternal */
/* Missing: NtGdiGetGlyphOutline */
/* Missing: NtGdiGetOPMInformation */
/* Missing: NtGdiGetKerningPairs */
/* Missing: NtGdiGetLinkedUFIs */
/* Missing: NtGdiGetMiterLimit */
/* Missing: NtGdiGetMonitorID */
/* Missing: NtGdiGetNearestColor */
/* Missing: NtGdiGetNearestPaletteIndex */
/* Missing: NtGdiGetObjectBitmapHandle */
/* Missing: NtGdiGetOPMRandomNumber */
/* Missing: NtGdiGetOutlineTextMetricsInternalW */
/* Missing: NtGdiGetPath */
/* Missing: NtGdiGetPixel */
/* Missing: NtGdiGetRandomRgn */
/* Missing: NtGdiGetRasterizerCaps */
/* Missing: NtGdiGetRealizationInfo */
/* Missing: NtGdiGetRegionData */
/* Missing: NtGdiGetRgnBox */
/* Missing: NtGdiGetServerMetaFileBits */
/* Missing: NtGdiGetSpoolMessage */
/* Missing: NtGdiGetStats */
/* Missing: NtGdiGetStockObject */
/* Missing: NtGdiGetStringBitmapW */
/* Missing: NtGdiGetSuggestedOPMProtectedOutputArraySize */
/* Missing: NtGdiGetSystemPaletteUse */
/* Missing: NtGdiGetTextCharsetInfo */
/* Missing: NtGdiGetTextExtent */
/* Missing: NtGdiGetTextExtentExW */
/* Missing: NtGdiGetTextFaceW */
/* Missing: NtGdiGetTextMetricsW */
/* Missing: NtGdiGetTransform */
/* Missing: NtGdiGetUFI */
/* Missing: NtGdiGetEmbUFI */
/* Missing: NtGdiGetUFIPathname */
/* Missing: NtGdiGetEmbedFonts */
/* Missing: NtGdiChangeGhostFont */
/* Missing: NtGdiAddEmbFontToDC */
/* Missing: NtGdiGetFontUnicodeRanges */
/* Missing: NtGdiGetWidthTable */
/* Missing: NtGdiGradientFill */
/* Missing: NtGdiHfontCreate */
/* Missing: NtGdiIcmBrushInfo */
/* Missing: NtGdiInit */
/* Missing: NtGdiInitSpool */
/* Missing: NtGdiIntersectClipRect */
/* Missing: NtGdiInvertRgn */
/* Missing: NtGdiLineTo */
/* Missing: NtGdiMakeFontDir */
/* Missing: NtGdiMakeInfoDC */
/* Missing: NtGdiMaskBlt */
/* Missing: NtGdiModifyWorldTransform */
/* Missing: NtGdiMonoBitmap */
/* Missing: NtGdiMoveTo */
/* Missing: NtGdiOffsetClipRgn */
/* Missing: NtGdiOffsetRgn */
/* Missing: NtGdiOpenDCW */
/* Missing: NtGdiPatBlt */
/* Missing: NtGdiPolyPatBlt */
/* Missing: NtGdiPathToRegion */
/* Missing: NtGdiPlgBlt */
/* Missing: NtGdiPolyDraw */
/* Missing: NtGdiPolyPolyDraw */
/* Missing: NtGdiPolyTextOutW */
/* Missing: NtGdiPtInRegion */
/* Missing: NtGdiPtVisible */
/* Missing: NtGdiQueryFonts */
/* Missing: NtGdiQueryFontAssocInfo */
/* Missing: NtGdiRectangle */
/* Missing: NtGdiRectInRegion */
/* Missing: NtGdiRectVisible */
/* Missing: NtGdiRemoveFontResourceW */
/* Missing: NtGdiRemoveFontMemResourceEx */
/* Missing: NtGdiResetDC */
/* Missing: NtGdiResizePalette */
/* Missing: NtGdiRestoreDC */
/* Missing: NtGdiRoundRect */
/* Missing: NtGdiSaveDC */
/* Missing: NtGdiScaleViewportExtEx */
/* Missing: NtGdiScaleWindowExtEx */
/* Missing: NtGdiSelectBitmap */
/* Missing: NtGdiSelectBrush */
/* Missing: NtGdiSelectClipPath */
/* Missing: NtGdiSelectFont */
/* Missing: NtGdiSelectPen */
/* Missing: NtGdiSetBitmapAttributes */
/* Missing: NtGdiSetBitmapBits */
/* Missing: NtGdiSetBitmapDimension */
/* Missing: NtGdiSetBoundsRect */
/* Missing: NtGdiSetBrushAttributes */
/* Missing: NtGdiSetBrushOrg */
/* Missing: NtGdiSetColorAdjustment */
/* Missing: NtGdiSetColorSpace */
/* Missing: NtGdiSetDeviceGammaRamp */
/* Missing: NtGdiSetDIBitsToDeviceInternal */
/* Missing: NtGdiSetFontEnumeration */
/* Missing: NtGdiSetFontXform */
/* Missing: NtGdiSetIcmMode */
/* Missing: NtGdiSetLinkedUFIs */
/* Missing: NtGdiSetMagicColors */
/* Missing: NtGdiSetMetaRgn */
/* Missing: NtGdiSetMiterLimit */
/* Missing: NtGdiGetDeviceWidth */
/* Missing: NtGdiMirrorWindowOrg */
/* Missing: NtGdiSetLayout */
/* Missing: NtGdiSetOPMSigningKeyAndSequenceNumbers */
/* Missing: NtGdiSetPixel */
/* Missing: NtGdiSetPixelFormat */
/* Missing: NtGdiSetRectRgn */
/* Missing: NtGdiSetSystemPaletteUse */
/* Missing: NtGdiSetTextJustification */
/* Missing: NtGdiSetVirtualResolution */
/* Missing: NtGdiSetSizeDevice */
/* Missing: NtGdiStartDoc */
/* Missing: NtGdiStartPage */
/* Missing: NtGdiStretchBlt */
/* Missing: NtGdiStretchDIBitsInternal */
/* Missing: NtGdiStrokeAndFillPath */
/* Missing: NtGdiStrokePath */
/* Missing: NtGdiSwapBuffers */
/* Missing: NtGdiTransformPoints */
/* Missing: NtGdiTransparentBlt */
/* Missing: NtGdiUnloadPrinterDriver */
/* Missing: NtGdiUnmapMemFont */
/* Missing: NtGdiUnrealizeObject */
/* Missing: NtGdiUpdateColors */
/* Missing: NtGdiWidenPath */
/* Missing: NtUserActivateKeyboardLayout */
/* Missing: NtUserAddClipboardFormatListener */
/* Missing: NtUserAlterWindowStyle */
/* Missing: NtUserAssociateInputContext */
/* Missing: NtUserAttachThreadInput */
/* Missing: NtUserBeginPaint */
/* Missing: NtUserBitBltSysBmp */
/* Missing: NtUserBlockInput */
/* Missing: NtUserBuildHimcList */
/* Missing: NtUserBuildHwndList */
/* Missing: NtUserBuildNameList */
/* Missing: NtUserBuildPropList */
/* Missing: NtUserCallHwnd */
/* Missing: NtUserCallHwndLock */
/* Missing: NtUserCallHwndOpt */
/* Missing: NtUserCallHwndParam */
/* Missing: NtUserCallHwndParamLock */
/* Missing: NtUserCallMsgFilter */
/* Missing: NtUserCallNextHookEx */
/* Missing: NtUserCallNoParam */
/* Missing: NtUserCallOneParam */
/* Missing: NtUserCallTwoParam */
/* Missing: NtUserChangeClipboardChain */
/* Missing: NtUserChangeDisplaySettings */
/* Missing: NtUserGetDisplayConfigBufferSizes */
/* Missing: NtUserSetDisplayConfig */
/* Missing: NtUserQueryDisplayConfig */
/* Missing: NtUserDisplayConfigGetDeviceInfo */
/* Missing: NtUserDisplayConfigSetDeviceInfo */
/* Missing: NtUserCheckAccessForIntegrityLevel */
/* Missing: NtUserCheckDesktopByThreadId */
/* Missing: NtUserCheckWindowThreadDesktop */
/* Missing: NtUserCheckMenuItem */
/* Missing: NtUserChildWindowFromPointEx */
/* Missing: NtUserClipCursor */
/* Missing: NtUserCloseClipboard */
/* Missing: NtUserCloseDesktop */
/* Missing: NtUserCloseWindowStation */
/* Missing: NtUserConsoleControl */
/* Missing: NtUserConvertMemHandle */
/* Missing: NtUserCopyAcceleratorTable */
/* Missing: NtUserCountClipboardFormats */
/* Missing: NtUserCreateAcceleratorTable */
/* Missing: NtUserCreateCaret */
/* Missing: NtUserCreateDesktopEx */
/* Missing: NtUserCreateInputContext */
/* Missing: NtUserCreateLocalMemHandle */
/* Missing: NtUserCreateWindowEx */
/* Missing: NtUserCreateWindowStation */
/* Missing: NtUserDdeInitialize */
/* Missing: NtUserDeferWindowPos */
/* Missing: NtUserDefSetText */
/* Missing: NtUserDeleteMenu */
/* Missing: NtUserDestroyAcceleratorTable */
/* Missing: NtUserDestroyCursor */
/* Missing: NtUserDestroyInputContext */
/* Missing: NtUserDestroyMenu */
/* Missing: NtUserDestroyWindow */
/* Missing: NtUserDisableThreadIme */
/* Missing: NtUserDispatchMessage */
/* Missing: NtUserDoSoundConnect */
/* Missing: NtUserDoSoundDisconnect */
/* Missing: NtUserDragDetect */
/* Missing: NtUserDragObject */
/* Missing: NtUserDrawAnimatedRects */
/* Missing: NtUserDrawCaption */
/* Missing: NtUserDrawCaptionTemp */
/* Missing: NtUserDrawIconEx */
/* Missing: NtUserDrawMenuBarTemp */
/* Missing: NtUserEmptyClipboard */
/* Missing: NtUserEnableMenuItem */
/* Missing: NtUserEnableScrollBar */
/* Missing: NtUserEndDeferWindowPosEx */
/* Missing: NtUserEndMenu */
/* Missing: NtUserEndPaint */
/* Missing: NtUserEnumDisplayDevices */
/* Missing: NtUserEnumDisplayMonitors */
/* Missing: NtUserEnumDisplaySettings */
/* Missing: NtUserEvent */
/* Missing: NtUserExcludeUpdateRgn */
/* Missing: NtUserFillWindow */
/* Missing: NtUserFindExistingCursorIcon */
/* Missing: NtUserFindWindowEx */
/* Missing: NtUserFlashWindowEx */
/* Missing: NtUserFrostCrashedWindow */
/* Missing: NtUserGetAltTabInfo */
/* Missing: NtUserGetAncestor */
/* Missing: NtUserGetAppImeLevel */
/* Missing: NtUserGetAsyncKeyState */
/* Missing: NtUserGetAtomName */
/* Missing: NtUserGetCaretBlinkTime */
/* Missing: NtUserGetCaretPos */
/* Missing: NtUserGetClassInfoEx */
/* Missing: NtUserGetClassName */
/* Missing: NtUserGetClipboardData */
/* Missing: NtUserGetClipboardFormatName */
/* Missing: NtUserGetClipboardOwner */
/* Missing: NtUserGetClipboardSequenceNumber */
/* Missing: NtUserGetClipboardViewer */
/* Missing: NtUserGetClipCursor */
/* Missing: NtUserGetComboBoxInfo */
/* Missing: NtUserGetControlBrush */
/* Missing: NtUserGetControlColor */
/* Missing: NtUserGetCPD */
/* Missing: NtUserGetCursorFrameInfo */
/* Missing: NtUserGetCursorInfo */
/* Missing: NtUserGetDC */
/* Missing: NtUserGetDCEx */
/* Missing: NtUserGetDoubleClickTime */
/* Missing: NtUserGetForegroundWindow */
/* Missing: NtUserGetGuiResources */
/* Missing: NtUserGetGUIThreadInfo */
/* Missing: NtUserGetIconInfo */
/* Missing: NtUserGetIconSize */
/* Missing: NtUserGetImeHotKey */
/* Missing: NtUserGetImeInfoEx */
/* Missing: NtUserGetInputLocaleInfo */
/* Missing: NtUserGetInternalWindowPos */
/* Missing: NtUserGetKeyboardLayoutList */
/* Missing: NtUserGetKeyboardLayoutName */
/* Missing: NtUserGetKeyboardState */
/* Missing: NtUserGetKeyNameText */
/* Missing: NtUserGetKeyState */
/* Missing: NtUserGetListBoxInfo */
/* Missing: NtUserGetMenuBarInfo */
/* Missing: NtUserGetMenuIndex */
/* Missing: NtUserGetMenuItemRect */
/* Missing: NtUserGetMessage */
/* Missing: NtUserGetMouseMovePointsEx */
/* Missing: NtUserGetObjectInformation */
/* Missing: NtUserGetOpenClipboardWindow */
/* Missing: NtUserGetPriorityClipboardFormat */
/* Missing: NtUserGetProcessWindowStation */
/* Missing: NtUserGetRawInputBuffer */
/* Missing: NtUserGetRawInputData */
/* Missing: NtUserGetRawInputDeviceInfo */
/* Missing: NtUserGetRawInputDeviceList */
/* Missing: NtUserGetRegisteredRawInputDevices */
/* Missing: NtUserGetScrollBarInfo */
/* Missing: NtUserGetSystemMenu */
/* Missing: NtUserGetThreadDesktop */
/* Missing: NtUserGetThreadState */
/* Missing: NtUserGetTitleBarInfo */
/* Missing: NtUserGetTopLevelWindow */
/* Missing: NtUserGetUpdatedClipboardFormats */
/* Missing: NtUserGetUpdateRect */
/* Missing: NtUserGetUpdateRgn */
/* Missing: NtUserGetWindowCompositionInfo */
/* Missing: NtUserGetWindowCompositionAttribute */
/* Missing: NtUserGetWindowDC */
/* Missing: NtUserGetWindowDisplayAffinity */
/* Missing: NtUserGetWindowPlacement */
/* Missing: NtUserGetWOWClass */
/* Missing: NtUserGhostWindowFromHungWindow */
/* Missing: NtUserHardErrorControl */
/* Missing: NtUserHideCaret */
/* Missing: NtUserHiliteMenuItem */
/* Missing: NtUserHungWindowFromGhostWindow */
/* Missing: NtUserImpersonateDdeClientWindow */
/* Missing: NtUserInitialize */
/* Missing: NtUserInitializeClientPfnArrays */
/* Missing: NtUserInitTask */
/* Missing: NtUserInternalGetWindowText */
/* Missing: NtUserInternalGetWindowIcon */
/* Missing: NtUserInvalidateRect */
/* Missing: NtUserInvalidateRgn */
/* Missing: NtUserIsClipboardFormatAvailable */
/* Missing: NtUserIsTopLevelWindow */
/* Missing: NtUserKillTimer */
/* Missing: NtUserLoadKeyboardLayoutEx */
/* Missing: NtUserLockWindowStation */
/* Missing: NtUserLockWindowUpdate */
/* Missing: NtUserLockWorkStation */
/* Missing: NtUserLogicalToPhysicalPoint */
/* Missing: NtUserMapVirtualKeyEx */
/* Missing: NtUserMenuItemFromPoint */
/* Missing: NtUserMessageCall */
/* Missing: NtUserMinMaximize */
/* Missing: NtUserMNDragLeave */
/* Missing: NtUserMNDragOver */
/* Missing: NtUserModifyUserStartupInfoFlags */
/* Missing: NtUserMoveWindow */
/* Missing: NtUserNotifyIMEStatus */
/* Missing: NtUserNotifyProcessCreate */
/* Missing: NtUserNotifyWinEvent */
/* Missing: NtUserOpenClipboard */
/* Missing: NtUserOpenDesktop */
/* Missing: NtUserOpenInputDesktop */
/* Missing: NtUserOpenThreadDesktop */
/* Missing: NtUserOpenWindowStation */
/* Missing: NtUserPaintDesktop */
/* Missing: NtUserPaintMonitor */
/* Missing: NtUserPeekMessage */
/* Missing: NtUserPhysicalToLogicalPoint */
/* Missing: NtUserPostMessage */
/* Missing: NtUserPostThreadMessage */
/* Missing: NtUserPrintWindow */
/* Missing: NtUserProcessConnect */
/* Missing: NtUserQueryInformationThread */
/* Missing: NtUserQueryInputContext */
/* Missing: NtUserQuerySendMessage */
/* Missing: NtUserQueryWindow */
/* Missing: NtUserRealChildWindowFromPoint */
/* Missing: NtUserRealInternalGetMessage */
/* Missing: NtUserRealWaitMessageEx */
/* Missing: NtUserRedrawWindow */
/* Missing: NtUserRegisterClassExWOW */
/* Missing: NtUserRegisterErrorReportingDialog */
/* Missing: NtUserRegisterUserApiHook */
/* Missing: NtUserRegisterHotKey */
/* Missing: NtUserRegisterRawInputDevices */
/* Missing: NtUserRegisterServicesProcess */
/* Missing: NtUserRegisterTasklist */
/* Missing: NtUserRegisterWindowMessage */
/* Missing: NtUserRemoveClipboardFormatListener */
/* Missing: NtUserRemoveMenu */
/* Missing: NtUserRemoveProp */
/* Missing: NtUserResolveDesktopForWOW */
/* Missing: NtUserSBGetParms */
/* Missing: NtUserScrollDC */
/* Missing: NtUserScrollWindowEx */
/* Missing: NtUserSelectPalette */
/* Missing: NtUserSendInput */
/* Missing: NtUserSetActiveWindow */
/* Missing: NtUserSetAppImeLevel */
/* Missing: NtUserSetCapture */
/* Missing: NtUserSetChildWindowNoActivate */
/* Missing: NtUserSetClassLong */
/* Missing: NtUserSetClassWord */
/* Missing: NtUserSetClipboardData */
/* Missing: NtUserSetClipboardViewer */
/* Missing: NtUserSetCursor */
/* Missing: NtUserSetCursorContents */
/* Missing: NtUserSetCursorIconData */
/* Missing: NtUserSetFocus */
/* Missing: NtUserSetImeHotKey */
/* Missing: NtUserSetImeInfoEx */
/* Missing: NtUserSetImeOwnerWindow */
/* Missing: NtUserSetInformationThread */
/* Missing: NtUserSetInternalWindowPos */
/* Missing: NtUserSetKeyboardState */
/* Missing: NtUserSetMenu */
/* Missing: NtUserSetMenuContextHelpId */
/* Missing: NtUserSetMenuDefaultItem */
/* Missing: NtUserSetMenuFlagRtoL */
/* Missing: NtUserSetObjectInformation */
/* Missing: NtUserSetParent */
/* Missing: NtUserSetProcessWindowStation */
/* Missing: NtUserGetProp */
/* Missing: NtUserSetProp */
/* Missing: NtUserSetScrollInfo */
/* Missing: NtUserSetShellWindowEx */
/* Missing: NtUserSetSysColors */
/* Missing: NtUserSetSystemCursor */
/* Missing: NtUserSetSystemMenu */
/* Missing: NtUserSetSystemTimer */
/* Missing: NtUserSetThreadDesktop */
/* Missing: NtUserSetThreadLayoutHandles */
/* Missing: NtUserSetThreadState */
/* Missing: NtUserSetTimer */
/* Missing: NtUserSetProcessDPIAware */
/* Missing: NtUserSetWindowCompositionAttribute */
/* Missing: NtUserSetWindowDisplayAffinity */
/* Missing: NtUserSetWindowFNID */
/* Missing: NtUserSetWindowLong */
/* Missing: NtUserSetWindowPlacement */
/* Missing: NtUserSetWindowPos */
/* Missing: NtUserSetWindowRgn */
/* Missing: NtUserGetWindowRgnEx */
/* Missing: NtUserSetWindowRgnEx */
/* Missing: NtUserSetWindowsHookAW */
/* Missing: NtUserSetWindowsHookEx */
/* Missing: NtUserSetWindowStationUser */
/* Missing: NtUserSetWindowWord */
/* Missing: NtUserSetWinEventHook */
/* Missing: NtUserShowCaret */
/* Missing: NtUserShowScrollBar */
/* Missing: NtUserShowWindow */
/* Missing: NtUserShowWindowAsync */
/* Missing: NtUserSoundSentry */
/* Missing: NtUserSwitchDesktop */
/* Missing: NtUserSystemParametersInfo */
/* Missing: NtUserTestForInteractiveUser */
/* Missing: NtUserThunkedMenuInfo */
/* Missing: NtUserThunkedMenuItemInfo */
/* Missing: NtUserToUnicodeEx */
/* Missing: NtUserTrackMouseEvent */
/* Missing: NtUserTrackPopupMenuEx */
/* Missing: NtUserCalculatePopupWindowPosition */
/* Missing: NtUserCalcMenuBar */
/* Missing: NtUserPaintMenuBar */
/* Missing: NtUserTranslateAccelerator */
/* Missing: NtUserTranslateMessage */
/* Missing: NtUserUnhookWindowsHookEx */
/* Missing: NtUserUnhookWinEvent */
/* Missing: NtUserUnloadKeyboardLayout */
/* Missing: NtUserUnlockWindowStation */
/* Missing: NtUserUnregisterClass */
/* Missing: NtUserUnregisterUserApiHook */
/* Missing: NtUserUnregisterHotKey */
/* Missing: NtUserUpdateInputContext */
/* Missing: NtUserUpdateInstance */
/* Missing: NtUserUpdateLayeredWindow */
/* Missing: NtUserGetLayeredWindowAttributes */
/* Missing: NtUserSetLayeredWindowAttributes */
/* Missing: NtUserUpdatePerUserSystemParameters */
/* Missing: NtUserUserHandleGrantAccess */
/* Missing: NtUserValidateHandleSecure */
/* Missing: NtUserValidateRect */
/* Missing: NtUserValidateTimerCallback */
/* Missing: NtUserVkKeyScanEx */
/* Missing: NtUserWaitForInputIdle */
/* Missing: NtUserWaitForMsgAndEvent */
/* Missing: NtUserWaitMessage */
/* Missing: NtUserWindowFromPhysicalPoint */
/* Missing: NtUserWindowFromPoint */
/* Missing: NtUserYieldTask */
/* Missing: NtUserRemoteConnect */
/* Missing: NtUserRemoteRedrawRectangle */
/* Missing: NtUserRemoteRedrawScreen */
/* Missing: NtUserRemoteStopScreenUpdates */
/* Missing: NtUserCtxDisplayIOCtl */
/* Missing: NtUserRegisterSessionPort */
/* Missing: NtUserUnregisterSessionPort */
/* Missing: NtUserUpdateWindowTransform */
/* Missing: NtUserDwmStartRedirection */
/* Missing: NtUserDwmStopRedirection */
/* Missing: NtUserGetWindowMinimizeRect */
/* Missing: NtUserSfmDxBindSwapChain */
/* Missing: NtUserSfmDxOpenSwapChain */
/* Missing: NtUserSfmDxReleaseSwapChain */
/* Missing: NtUserSfmDxSetSwapChainBindingStatus */
/* Missing: NtUserSfmDxQuerySwapChainBindingStatus */
/* Missing: NtUserSfmDxReportPendingBindingsToDwm */
/* Missing: NtUserSfmDxGetSwapChainStats */
/* Missing: NtUserSfmDxSetSwapChainStats */
/* Missing: NtUserSfmGetLogicalSurfaceBinding */
/* Missing: NtUserSfmDestroyLogicalSurfaceBinding */
/* Missing: NtUserModifyWindowTouchCapability */
/* Missing: NtUserIsTouchWindow */
/* Missing: NtUserSendTouchInput */
/* Missing: NtUserEndTouchOperation */
/* Missing: NtUserGetTouchInputInfo */
/* Missing: NtUserChangeWindowMessageFilterEx */
/* Missing: NtUserInjectGesture */
/* Missing: NtUserGetGestureInfo */
/* Missing: NtUserGetGestureExtArgs */
/* Missing: NtUserManageGestureHandlerWindow */
/* Missing: NtUserSetGestureConfig */
/* Missing: NtUserGetGestureConfig */
/* Missing: NtGdiEngAssociateSurface */
/* Missing: NtGdiEngCreateBitmap */
/* Missing: NtGdiEngCreateDeviceSurface */
/* Missing: NtGdiEngCreateDeviceBitmap */
/* Missing: NtGdiEngCreatePalette */
/* Missing: NtGdiEngComputeGlyphSet */
/* Missing: NtGdiEngCopyBits */
/* Missing: NtGdiEngDeletePalette */
/* Missing: NtGdiEngDeleteSurface */
/* Missing: NtGdiEngEraseSurface */
/* Missing: NtGdiEngUnlockSurface */
/* Missing: NtGdiEngLockSurface */
/* Missing: NtGdiEngBitBlt */
/* Missing: NtGdiEngStretchBlt */
/* Missing: NtGdiEngPlgBlt */
/* Missing: NtGdiEngMarkBandingSurface */
/* Missing: NtGdiEngStrokePath */
/* Missing: NtGdiEngFillPath */
/* Missing: NtGdiEngStrokeAndFillPath */
/* Missing: NtGdiEngPaint */
/* Missing: NtGdiEngLineTo */
/* Missing: NtGdiEngAlphaBlend */
/* Missing: NtGdiEngGradientFill */
/* Missing: NtGdiEngTransparentBlt */
/* Missing: NtGdiEngTextOut */
/* Missing: NtGdiEngStretchBltROP */
/* Missing: NtGdiXLATEOBJ_cGetPalette */
/* Missing: NtGdiXLATEOBJ_iXlate */
/* Missing: NtGdiXLATEOBJ_hGetColorTransform */
/* Missing: NtGdiCLIPOBJ_bEnum */
/* Missing: NtGdiCLIPOBJ_cEnumStart */
/* Missing: NtGdiCLIPOBJ_ppoGetPath */
/* Missing: NtGdiEngDeletePath */
/* Missing: NtGdiEngCreateClip */
/* Missing: NtGdiEngDeleteClip */
/* Missing: NtGdiBRUSHOBJ_ulGetBrushColor */
/* Missing: NtGdiBRUSHOBJ_pvAllocRbrush */
/* Missing: NtGdiBRUSHOBJ_pvGetRbrush */
/* Missing: NtGdiBRUSHOBJ_hGetColorTransform */
/* Missing: NtGdiXFORMOBJ_bApplyXform */
/* Missing: NtGdiXFORMOBJ_iGetXform */
/* Missing: NtGdiFONTOBJ_vGetInfo */
/* Missing: NtGdiFONTOBJ_pxoGetXform */
/* Missing: NtGdiFONTOBJ_cGetGlyphs */
/* Missing: NtGdiFONTOBJ_pifi */
/* Missing: NtGdiFONTOBJ_pfdg */
/* Missing: NtGdiFONTOBJ_pQueryGlyphAttrs */
/* Missing: NtGdiFONTOBJ_pvTrueTypeFontFile */
/* Missing: NtGdiFONTOBJ_cGetAllGlyphHandles */
/* Missing: NtGdiSTROBJ_bEnum */
/* Missing: NtGdiSTROBJ_bEnumPositionsOnly */
/* Missing: NtGdiSTROBJ_bGetAdvanceWidths */
/* Missing: NtGdiSTROBJ_vEnumStart */
/* Missing: NtGdiSTROBJ_dwGetCodePage */
/* Missing: NtGdiPATHOBJ_vGetBounds */
/* Missing: NtGdiPATHOBJ_bEnum */
/* Missing: NtGdiPATHOBJ_vEnumStart */
/* Missing: NtGdiPATHOBJ_vEnumStartClipLines */
/* Missing: NtGdiPATHOBJ_bEnumClipLines */
/* Missing: NtGdiGetDhpdev */
/* Missing: NtGdiEngCheckAbort */
/* Missing: NtGdiHT_Get8BPPFormatPalette */
/* Missing: NtGdiHT_Get8BPPMaskPalette */
/* Missing: NtGdiUpdateTransform */
/* Missing: NtGdiSetPUMPDOBJ */
/* Missing: NtGdiBRUSHOBJ_DeleteRbrush */
/* Missing: NtGdiUMPDEngFreeUserMem */
/* Missing: NtGdiDrawStream */
/* Missing: NtGdiSfmGetNotificationTokens */
/* Missing: NtGdiHLSurfGetInformation */
/* Missing: NtGdiHLSurfSetInformation */
/* Missing: NtGdiDdDDICreateAllocation */
/* Missing: NtGdiDdDDIQueryResourceInfo */
/* Missing: NtGdiDdDDIOpenResource */
/* Missing: NtGdiDdDDIDestroyAllocation */
/* Missing: NtGdiDdDDISetAllocationPriority */
/* Missing: NtGdiDdDDIQueryAllocationResidency */
/* Missing: NtGdiDdDDICreateDevice */
/* Missing: NtGdiDdDDIDestroyDevice */
/* Missing: NtGdiDdDDICreateContext */
/* Missing: NtGdiDdDDIDestroyContext */
/* Missing: NtGdiDdDDICreateSynchronizationObject */
/* Missing: NtGdiDdDDIOpenSynchronizationObject */
/* Missing: NtGdiDdDDIDestroySynchronizationObject */
/* Missing: NtGdiDdDDIWaitForSynchronizationObject */
/* Missing: NtGdiDdDDISignalSynchronizationObject */
/* Missing: NtGdiDdDDIGetRuntimeData */
/* Missing: NtGdiDdDDIQueryAdapterInfo */
/* Missing: NtGdiDdDDILock */
/* Missing: NtGdiDdDDIUnlock */
/* Missing: NtGdiDdDDIGetDisplayModeList */
/* Missing: NtGdiDdDDISetDisplayMode */
/* Missing: NtGdiDdDDIGetMultisampleMethodList */
/* Missing: NtGdiDdDDIPresent */
/* Missing: NtGdiDdDDIRender */
/* Missing: NtGdiDdDDIOpenAdapterFromDeviceName */
/* Missing: NtGdiDdDDIOpenAdapterFromHdc */
/* Missing: NtGdiDdDDICloseAdapter */
/* Missing: NtGdiDdDDIGetSharedPrimaryHandle */
/* Missing: NtGdiDdDDIEscape */
/* Missing: NtGdiDdDDIQueryStatistics */
/* Missing: NtGdiDdDDISetVidPnSourceOwner */
/* Missing: NtGdiDdDDIGetPresentHistory */
/* Missing: NtGdiDdDDIGetPresentQueueEvent */
/* Missing: NtGdiDdDDICreateOverlay */
/* Missing: NtGdiDdDDIUpdateOverlay */
/* Missing: NtGdiDdDDIFlipOverlay */
/* Missing: NtGdiDdDDIDestroyOverlay */
/* Missing: NtGdiDdDDIWaitForVerticalBlankEvent */
/* Missing: NtGdiDdDDISetGammaRamp */
/* Missing: NtGdiDdDDIGetDeviceState */
/* Missing: NtGdiDdDDICreateDCFromMemory */
/* Missing: NtGdiDdDDIDestroyDCFromMemory */
/* Missing: NtGdiDdDDISetContextSchedulingPriority */
/* Missing: NtGdiDdDDIGetContextSchedulingPriority */
/* Missing: NtGdiDdDDISetProcessSchedulingPriorityClass */
/* Missing: NtGdiDdDDIGetProcessSchedulingPriorityClass */
/* Missing: NtGdiDdDDIReleaseProcessVidPnSourceOwners */
/* Missing: NtGdiDdDDIGetScanLine */
/* Missing: NtGdiDdDDISetQueuedLimit */
/* Missing: NtGdiDdDDIPollDisplayChildren */
/* Missing: NtGdiDdDDIInvalidateActiveVidPn */
/* Missing: NtGdiDdDDICheckOcclusion */
/* Missing: NtGdiDdDDIWaitForIdle */
/* Missing: NtGdiDdDDICheckMonitorPowerState */
/* Missing: NtGdiDdDDICheckExclusiveOwnership */
/* Missing: NtGdiDdDDISetDisplayPrivateDriverFormat */
/* Missing: NtGdiDdDDISharedPrimaryLockNotification */
/* Missing: NtGdiDdDDISharedPrimaryUnLockNotification */
/* Missing: NtGdiDdDDICreateKeyedMutex */
/* Missing: NtGdiDdDDIOpenKeyedMutex */
/* Missing: NtGdiDdDDIDestroyKeyedMutex */
/* Missing: NtGdiDdDDIAcquireKeyedMutex */
/* Missing: NtGdiDdDDIReleaseKeyedMutex */
/* Missing: NtGdiDdDDIConfigureSharedResource */
/* Missing: NtGdiDdDDIGetOverlayState */
/* Missing: NtGdiDdDDICheckVidPnExclusiveOwnership */
/* Missing: NtGdiDdDDICheckSharedResourceAccess */
/* Missing: DxgStubEnableDirectDrawRedirection */
/* Missing: DxgStubDeleteDirectDrawObject */
/* Missing: NtGdiGetNumberOfPhysicalMonitors */
/* Missing: NtGdiGetPhysicalMonitors */
/* Missing: NtGdiGetPhysicalMonitorDescription */
/* Missing: NtGdiDestroyPhysicalMonitor */
/* Missing: NtGdiDDCCIGetVCPFeature */
/* Missing: NtGdiDDCCISetVCPFeature */
/* Missing: NtGdiDDCCISaveCurrentSettings */
/* Missing: NtGdiDDCCIGetCapabilitiesStringLength */
/* Missing: NtGdiDDCCIGetCapabilitiesString */
/* Missing: NtGdiDDCCIGetTimingReport */
/* Missing: NtGdiDdCreateFullscreenSprite */
/* Missing: NtGdiDdNotifyFullscreenSpriteUpdate */
/* Missing: NtGdiDdDestroyFullscreenSprite */
/* Missing: NtGdiDdQueryVisRgnUniqueness */
/* Missing: NtUserSetMirrorRendering */
/* Missing: NtUserShowSystemCursor */
/* Missing: NtUserMagControl */
/* Missing: NtUserMagSetContextInformation */
/* Missing: NtUserMagGetContextInformation */
/* Missing: NtUserHwndQueryRedirectionInfo */
/* Missing: NtUserHwndSetRedirectionInfo */
void on_cb_unknown_enter(CPUState *cpu, target_ulong pc, target_ulong callno) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    fprintf(outFile, "{\"syscall_number\" : \"0x%x\",\"syscall_name\" : \"unknown\",\"trace_location\" : \"entry\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\"},\n", (uint32_t)callno, (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count);
#endif
}
void on_cb_unknown_return(CPUState *cpu, target_ulong pc, target_ulong callno) {
#ifdef TARGET_I386
    RR_prog_point pp = rr_prog_point();
    target_ulong asid = panda_current_asid(cpu);
    CPUArchState * cpuarch = reinterpret_cast<CPUArchState*>(cpu->env_ptr);
    uint32_t retval = cpuarch->regs[R_EAX];
    fprintf(outFile, "{\"syscall_number\" : \"0x%x\",\"syscall_name\" : \"unknown\",\"trace_location\" : \"return\",\"asid\" : \"0x%x\",\"pc\" : \"0x%x\",\"parameters\":{},\"instrcnt\" : \"%llu\",\"return\":\"0x%x\"},\n", (uint32_t)callno, (uint32_t)asid, (uint32_t)pc, (unsigned long long int) pp.guest_instr_count, retval);
#endif
}



bool init_plugin(void *self) {
#ifdef TARGET_I386
    outFile = fopen("sysmon1.txt", "w");
    if (!outFile) {
        printf("Error opening file sysmon1.txt for output");
        return false;
    }
    fprintf(outFile, "[\n");
    assert (!(panda_os_familyno == OS_UNKNOWN));
    panda_require("osi");
    assert(init_osi_api());
    panda_require("syscalls2");
    if (panda_os_familyno == OS_WINDOWS) {
        panda_require("wintrospection");
        assert(init_wintrospection_api());
        PPP_REG_CB("syscalls2", on_NtAcceptConnectPort_enter, on_cb_NtAcceptConnectPort_enter);
        PPP_REG_CB("syscalls2", on_NtAcceptConnectPort_return, on_cb_NtAcceptConnectPort_return);
        PPP_REG_CB("syscalls2", on_NtAccessCheck_enter, on_cb_NtAccessCheck_enter);
        PPP_REG_CB("syscalls2", on_NtAccessCheck_return, on_cb_NtAccessCheck_return);
        PPP_REG_CB("syscalls2", on_NtAccessCheckAndAuditAlarm_enter, on_cb_NtAccessCheckAndAuditAlarm_enter);
        PPP_REG_CB("syscalls2", on_NtAccessCheckAndAuditAlarm_return, on_cb_NtAccessCheckAndAuditAlarm_return);
        PPP_REG_CB("syscalls2", on_NtAccessCheckByType_enter, on_cb_NtAccessCheckByType_enter);
        PPP_REG_CB("syscalls2", on_NtAccessCheckByType_return, on_cb_NtAccessCheckByType_return);
        PPP_REG_CB("syscalls2", on_NtAccessCheckByTypeAndAuditAlarm_enter, on_cb_NtAccessCheckByTypeAndAuditAlarm_enter);
        PPP_REG_CB("syscalls2", on_NtAccessCheckByTypeAndAuditAlarm_return, on_cb_NtAccessCheckByTypeAndAuditAlarm_return);
        PPP_REG_CB("syscalls2", on_NtAccessCheckByTypeResultList_enter, on_cb_NtAccessCheckByTypeResultList_enter);
        PPP_REG_CB("syscalls2", on_NtAccessCheckByTypeResultList_return, on_cb_NtAccessCheckByTypeResultList_return);
        PPP_REG_CB("syscalls2", on_NtAccessCheckByTypeResultListAndAuditAlarm_enter, on_cb_NtAccessCheckByTypeResultListAndAuditAlarm_enter);
        PPP_REG_CB("syscalls2", on_NtAccessCheckByTypeResultListAndAuditAlarm_return, on_cb_NtAccessCheckByTypeResultListAndAuditAlarm_return);
        PPP_REG_CB("syscalls2", on_NtAccessCheckByTypeResultListAndAuditAlarmByHandle_enter, on_cb_NtAccessCheckByTypeResultListAndAuditAlarmByHandle_enter);
        PPP_REG_CB("syscalls2", on_NtAccessCheckByTypeResultListAndAuditAlarmByHandle_return, on_cb_NtAccessCheckByTypeResultListAndAuditAlarmByHandle_return);
        PPP_REG_CB("syscalls2", on_NtAddAtom_enter, on_cb_NtAddAtom_enter);
        PPP_REG_CB("syscalls2", on_NtAddAtom_return, on_cb_NtAddAtom_return);
        PPP_REG_CB("syscalls2", on_NtAddBootEntry_enter, on_cb_NtAddBootEntry_enter);
        PPP_REG_CB("syscalls2", on_NtAddBootEntry_return, on_cb_NtAddBootEntry_return);
        PPP_REG_CB("syscalls2", on_NtAddDriverEntry_enter, on_cb_NtAddDriverEntry_enter);
        PPP_REG_CB("syscalls2", on_NtAddDriverEntry_return, on_cb_NtAddDriverEntry_return);
        PPP_REG_CB("syscalls2", on_NtAdjustGroupsToken_enter, on_cb_NtAdjustGroupsToken_enter);
        PPP_REG_CB("syscalls2", on_NtAdjustGroupsToken_return, on_cb_NtAdjustGroupsToken_return);
        PPP_REG_CB("syscalls2", on_NtAdjustPrivilegesToken_enter, on_cb_NtAdjustPrivilegesToken_enter);
        PPP_REG_CB("syscalls2", on_NtAdjustPrivilegesToken_return, on_cb_NtAdjustPrivilegesToken_return);
        PPP_REG_CB("syscalls2", on_NtAlertResumeThread_enter, on_cb_NtAlertResumeThread_enter);
        PPP_REG_CB("syscalls2", on_NtAlertResumeThread_return, on_cb_NtAlertResumeThread_return);
        PPP_REG_CB("syscalls2", on_NtAlertThread_enter, on_cb_NtAlertThread_enter);
        PPP_REG_CB("syscalls2", on_NtAlertThread_return, on_cb_NtAlertThread_return);
        PPP_REG_CB("syscalls2", on_NtAllocateLocallyUniqueId_enter, on_cb_NtAllocateLocallyUniqueId_enter);
        PPP_REG_CB("syscalls2", on_NtAllocateLocallyUniqueId_return, on_cb_NtAllocateLocallyUniqueId_return);
        PPP_REG_CB("syscalls2", on_NtAllocateReserveObject_enter, on_cb_NtAllocateReserveObject_enter);
        PPP_REG_CB("syscalls2", on_NtAllocateReserveObject_return, on_cb_NtAllocateReserveObject_return);
        PPP_REG_CB("syscalls2", on_NtAllocateUserPhysicalPages_enter, on_cb_NtAllocateUserPhysicalPages_enter);
        PPP_REG_CB("syscalls2", on_NtAllocateUserPhysicalPages_return, on_cb_NtAllocateUserPhysicalPages_return);
        PPP_REG_CB("syscalls2", on_NtAllocateUuids_enter, on_cb_NtAllocateUuids_enter);
        PPP_REG_CB("syscalls2", on_NtAllocateUuids_return, on_cb_NtAllocateUuids_return);
        PPP_REG_CB("syscalls2", on_NtAllocateVirtualMemory_enter, on_cb_NtAllocateVirtualMemory_enter);
        PPP_REG_CB("syscalls2", on_NtAllocateVirtualMemory_return, on_cb_NtAllocateVirtualMemory_return);
        PPP_REG_CB("syscalls2", on_NtAlpcAcceptConnectPort_enter, on_cb_NtAlpcAcceptConnectPort_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcAcceptConnectPort_return, on_cb_NtAlpcAcceptConnectPort_return);
        PPP_REG_CB("syscalls2", on_NtAlpcCancelMessage_enter, on_cb_NtAlpcCancelMessage_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcCancelMessage_return, on_cb_NtAlpcCancelMessage_return);
        PPP_REG_CB("syscalls2", on_NtAlpcConnectPort_enter, on_cb_NtAlpcConnectPort_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcConnectPort_return, on_cb_NtAlpcConnectPort_return);
        PPP_REG_CB("syscalls2", on_NtAlpcCreatePort_enter, on_cb_NtAlpcCreatePort_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcCreatePort_return, on_cb_NtAlpcCreatePort_return);
        PPP_REG_CB("syscalls2", on_NtAlpcCreatePortSection_enter, on_cb_NtAlpcCreatePortSection_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcCreatePortSection_return, on_cb_NtAlpcCreatePortSection_return);
        PPP_REG_CB("syscalls2", on_NtAlpcCreateResourceReserve_enter, on_cb_NtAlpcCreateResourceReserve_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcCreateResourceReserve_return, on_cb_NtAlpcCreateResourceReserve_return);
        PPP_REG_CB("syscalls2", on_NtAlpcCreateSectionView_enter, on_cb_NtAlpcCreateSectionView_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcCreateSectionView_return, on_cb_NtAlpcCreateSectionView_return);
        PPP_REG_CB("syscalls2", on_NtAlpcCreateSecurityContext_enter, on_cb_NtAlpcCreateSecurityContext_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcCreateSecurityContext_return, on_cb_NtAlpcCreateSecurityContext_return);
        PPP_REG_CB("syscalls2", on_NtAlpcDeletePortSection_enter, on_cb_NtAlpcDeletePortSection_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcDeletePortSection_return, on_cb_NtAlpcDeletePortSection_return);
        PPP_REG_CB("syscalls2", on_NtAlpcDeleteResourceReserve_enter, on_cb_NtAlpcDeleteResourceReserve_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcDeleteResourceReserve_return, on_cb_NtAlpcDeleteResourceReserve_return);
        PPP_REG_CB("syscalls2", on_NtAlpcDeleteSectionView_enter, on_cb_NtAlpcDeleteSectionView_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcDeleteSectionView_return, on_cb_NtAlpcDeleteSectionView_return);
        PPP_REG_CB("syscalls2", on_NtAlpcDeleteSecurityContext_enter, on_cb_NtAlpcDeleteSecurityContext_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcDeleteSecurityContext_return, on_cb_NtAlpcDeleteSecurityContext_return);
        PPP_REG_CB("syscalls2", on_NtAlpcDisconnectPort_enter, on_cb_NtAlpcDisconnectPort_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcDisconnectPort_return, on_cb_NtAlpcDisconnectPort_return);
        PPP_REG_CB("syscalls2", on_NtAlpcImpersonateClientOfPort_enter, on_cb_NtAlpcImpersonateClientOfPort_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcImpersonateClientOfPort_return, on_cb_NtAlpcImpersonateClientOfPort_return);
        PPP_REG_CB("syscalls2", on_NtAlpcOpenSenderProcess_enter, on_cb_NtAlpcOpenSenderProcess_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcOpenSenderProcess_return, on_cb_NtAlpcOpenSenderProcess_return);
        PPP_REG_CB("syscalls2", on_NtAlpcOpenSenderThread_enter, on_cb_NtAlpcOpenSenderThread_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcOpenSenderThread_return, on_cb_NtAlpcOpenSenderThread_return);
        PPP_REG_CB("syscalls2", on_NtAlpcQueryInformation_enter, on_cb_NtAlpcQueryInformation_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcQueryInformation_return, on_cb_NtAlpcQueryInformation_return);
        PPP_REG_CB("syscalls2", on_NtAlpcQueryInformationMessage_enter, on_cb_NtAlpcQueryInformationMessage_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcQueryInformationMessage_return, on_cb_NtAlpcQueryInformationMessage_return);
        PPP_REG_CB("syscalls2", on_NtAlpcRevokeSecurityContext_enter, on_cb_NtAlpcRevokeSecurityContext_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcRevokeSecurityContext_return, on_cb_NtAlpcRevokeSecurityContext_return);
        PPP_REG_CB("syscalls2", on_NtAlpcSendWaitReceivePort_enter, on_cb_NtAlpcSendWaitReceivePort_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcSendWaitReceivePort_return, on_cb_NtAlpcSendWaitReceivePort_return);
        PPP_REG_CB("syscalls2", on_NtAlpcSetInformation_enter, on_cb_NtAlpcSetInformation_enter);
        PPP_REG_CB("syscalls2", on_NtAlpcSetInformation_return, on_cb_NtAlpcSetInformation_return);
        PPP_REG_CB("syscalls2", on_NtApphelpCacheControl_enter, on_cb_NtApphelpCacheControl_enter);
        PPP_REG_CB("syscalls2", on_NtApphelpCacheControl_return, on_cb_NtApphelpCacheControl_return);
        PPP_REG_CB("syscalls2", on_NtAreMappedFilesTheSame_enter, on_cb_NtAreMappedFilesTheSame_enter);
        PPP_REG_CB("syscalls2", on_NtAreMappedFilesTheSame_return, on_cb_NtAreMappedFilesTheSame_return);
        PPP_REG_CB("syscalls2", on_NtAssignProcessToJobObject_enter, on_cb_NtAssignProcessToJobObject_enter);
        PPP_REG_CB("syscalls2", on_NtAssignProcessToJobObject_return, on_cb_NtAssignProcessToJobObject_return);
        PPP_REG_CB("syscalls2", on_NtCallbackReturn_enter, on_cb_NtCallbackReturn_enter);
        PPP_REG_CB("syscalls2", on_NtCallbackReturn_return, on_cb_NtCallbackReturn_return);
        PPP_REG_CB("syscalls2", on_NtCancelIoFile_enter, on_cb_NtCancelIoFile_enter);
        PPP_REG_CB("syscalls2", on_NtCancelIoFile_return, on_cb_NtCancelIoFile_return);
        PPP_REG_CB("syscalls2", on_NtCancelIoFileEx_enter, on_cb_NtCancelIoFileEx_enter);
        PPP_REG_CB("syscalls2", on_NtCancelIoFileEx_return, on_cb_NtCancelIoFileEx_return);
        PPP_REG_CB("syscalls2", on_NtCancelSynchronousIoFile_enter, on_cb_NtCancelSynchronousIoFile_enter);
        PPP_REG_CB("syscalls2", on_NtCancelSynchronousIoFile_return, on_cb_NtCancelSynchronousIoFile_return);
        PPP_REG_CB("syscalls2", on_NtCancelTimer_enter, on_cb_NtCancelTimer_enter);
        PPP_REG_CB("syscalls2", on_NtCancelTimer_return, on_cb_NtCancelTimer_return);
        PPP_REG_CB("syscalls2", on_NtClearEvent_enter, on_cb_NtClearEvent_enter);
        PPP_REG_CB("syscalls2", on_NtClearEvent_return, on_cb_NtClearEvent_return);
        PPP_REG_CB("syscalls2", on_NtClose_enter, on_cb_NtClose_enter);
        PPP_REG_CB("syscalls2", on_NtClose_return, on_cb_NtClose_return);
        PPP_REG_CB("syscalls2", on_NtCloseObjectAuditAlarm_enter, on_cb_NtCloseObjectAuditAlarm_enter);
        PPP_REG_CB("syscalls2", on_NtCloseObjectAuditAlarm_return, on_cb_NtCloseObjectAuditAlarm_return);
        PPP_REG_CB("syscalls2", on_NtCommitComplete_enter, on_cb_NtCommitComplete_enter);
        PPP_REG_CB("syscalls2", on_NtCommitComplete_return, on_cb_NtCommitComplete_return);
        PPP_REG_CB("syscalls2", on_NtCommitEnlistment_enter, on_cb_NtCommitEnlistment_enter);
        PPP_REG_CB("syscalls2", on_NtCommitEnlistment_return, on_cb_NtCommitEnlistment_return);
        PPP_REG_CB("syscalls2", on_NtCommitTransaction_enter, on_cb_NtCommitTransaction_enter);
        PPP_REG_CB("syscalls2", on_NtCommitTransaction_return, on_cb_NtCommitTransaction_return);
        PPP_REG_CB("syscalls2", on_NtCompactKeys_enter, on_cb_NtCompactKeys_enter);
        PPP_REG_CB("syscalls2", on_NtCompactKeys_return, on_cb_NtCompactKeys_return);
        PPP_REG_CB("syscalls2", on_NtCompareTokens_enter, on_cb_NtCompareTokens_enter);
        PPP_REG_CB("syscalls2", on_NtCompareTokens_return, on_cb_NtCompareTokens_return);
        PPP_REG_CB("syscalls2", on_NtCompleteConnectPort_enter, on_cb_NtCompleteConnectPort_enter);
        PPP_REG_CB("syscalls2", on_NtCompleteConnectPort_return, on_cb_NtCompleteConnectPort_return);
        PPP_REG_CB("syscalls2", on_NtCompressKey_enter, on_cb_NtCompressKey_enter);
        PPP_REG_CB("syscalls2", on_NtCompressKey_return, on_cb_NtCompressKey_return);
        PPP_REG_CB("syscalls2", on_NtConnectPort_enter, on_cb_NtConnectPort_enter);
        PPP_REG_CB("syscalls2", on_NtConnectPort_return, on_cb_NtConnectPort_return);
        PPP_REG_CB("syscalls2", on_NtContinue_enter, on_cb_NtContinue_enter);
        PPP_REG_CB("syscalls2", on_NtContinue_return, on_cb_NtContinue_return);
        PPP_REG_CB("syscalls2", on_NtCreateDebugObject_enter, on_cb_NtCreateDebugObject_enter);
        PPP_REG_CB("syscalls2", on_NtCreateDebugObject_return, on_cb_NtCreateDebugObject_return);
        PPP_REG_CB("syscalls2", on_NtCreateDirectoryObject_enter, on_cb_NtCreateDirectoryObject_enter);
        PPP_REG_CB("syscalls2", on_NtCreateDirectoryObject_return, on_cb_NtCreateDirectoryObject_return);
        PPP_REG_CB("syscalls2", on_NtCreateEnlistment_enter, on_cb_NtCreateEnlistment_enter);
        PPP_REG_CB("syscalls2", on_NtCreateEnlistment_return, on_cb_NtCreateEnlistment_return);
        PPP_REG_CB("syscalls2", on_NtCreateEvent_enter, on_cb_NtCreateEvent_enter);
        PPP_REG_CB("syscalls2", on_NtCreateEvent_return, on_cb_NtCreateEvent_return);
        PPP_REG_CB("syscalls2", on_NtCreateEventPair_enter, on_cb_NtCreateEventPair_enter);
        PPP_REG_CB("syscalls2", on_NtCreateEventPair_return, on_cb_NtCreateEventPair_return);
        PPP_REG_CB("syscalls2", on_NtCreateFile_enter, on_cb_NtCreateFile_enter);
        PPP_REG_CB("syscalls2", on_NtCreateFile_return, on_cb_NtCreateFile_return);
        PPP_REG_CB("syscalls2", on_NtCreateIoCompletion_enter, on_cb_NtCreateIoCompletion_enter);
        PPP_REG_CB("syscalls2", on_NtCreateIoCompletion_return, on_cb_NtCreateIoCompletion_return);
        PPP_REG_CB("syscalls2", on_NtCreateJobObject_enter, on_cb_NtCreateJobObject_enter);
        PPP_REG_CB("syscalls2", on_NtCreateJobObject_return, on_cb_NtCreateJobObject_return);
        PPP_REG_CB("syscalls2", on_NtCreateJobSet_enter, on_cb_NtCreateJobSet_enter);
        PPP_REG_CB("syscalls2", on_NtCreateJobSet_return, on_cb_NtCreateJobSet_return);
        PPP_REG_CB("syscalls2", on_NtCreateKey_enter, on_cb_NtCreateKey_enter);
        PPP_REG_CB("syscalls2", on_NtCreateKey_return, on_cb_NtCreateKey_return);
        PPP_REG_CB("syscalls2", on_NtCreateKeyedEvent_enter, on_cb_NtCreateKeyedEvent_enter);
        PPP_REG_CB("syscalls2", on_NtCreateKeyedEvent_return, on_cb_NtCreateKeyedEvent_return);
        PPP_REG_CB("syscalls2", on_NtCreateKeyTransacted_enter, on_cb_NtCreateKeyTransacted_enter);
        PPP_REG_CB("syscalls2", on_NtCreateKeyTransacted_return, on_cb_NtCreateKeyTransacted_return);
        PPP_REG_CB("syscalls2", on_NtCreateMailslotFile_enter, on_cb_NtCreateMailslotFile_enter);
        PPP_REG_CB("syscalls2", on_NtCreateMailslotFile_return, on_cb_NtCreateMailslotFile_return);
        PPP_REG_CB("syscalls2", on_NtCreateMutant_enter, on_cb_NtCreateMutant_enter);
        PPP_REG_CB("syscalls2", on_NtCreateMutant_return, on_cb_NtCreateMutant_return);
        PPP_REG_CB("syscalls2", on_NtCreateNamedPipeFile_enter, on_cb_NtCreateNamedPipeFile_enter);
        PPP_REG_CB("syscalls2", on_NtCreateNamedPipeFile_return, on_cb_NtCreateNamedPipeFile_return);
        PPP_REG_CB("syscalls2", on_NtCreatePagingFile_enter, on_cb_NtCreatePagingFile_enter);
        PPP_REG_CB("syscalls2", on_NtCreatePagingFile_return, on_cb_NtCreatePagingFile_return);
        PPP_REG_CB("syscalls2", on_NtCreatePort_enter, on_cb_NtCreatePort_enter);
        PPP_REG_CB("syscalls2", on_NtCreatePort_return, on_cb_NtCreatePort_return);
        PPP_REG_CB("syscalls2", on_NtCreatePrivateNamespace_enter, on_cb_NtCreatePrivateNamespace_enter);
        PPP_REG_CB("syscalls2", on_NtCreatePrivateNamespace_return, on_cb_NtCreatePrivateNamespace_return);
        PPP_REG_CB("syscalls2", on_NtCreateProcess_enter, on_cb_NtCreateProcess_enter);
        PPP_REG_CB("syscalls2", on_NtCreateProcess_return, on_cb_NtCreateProcess_return);
        PPP_REG_CB("syscalls2", on_NtCreateProcessEx_enter, on_cb_NtCreateProcessEx_enter);
        PPP_REG_CB("syscalls2", on_NtCreateProcessEx_return, on_cb_NtCreateProcessEx_return);
        PPP_REG_CB("syscalls2", on_NtCreateProfile_enter, on_cb_NtCreateProfile_enter);
        PPP_REG_CB("syscalls2", on_NtCreateProfile_return, on_cb_NtCreateProfile_return);
        PPP_REG_CB("syscalls2", on_NtCreateProfileEx_enter, on_cb_NtCreateProfileEx_enter);
        PPP_REG_CB("syscalls2", on_NtCreateProfileEx_return, on_cb_NtCreateProfileEx_return);
        PPP_REG_CB("syscalls2", on_NtCreateResourceManager_enter, on_cb_NtCreateResourceManager_enter);
        PPP_REG_CB("syscalls2", on_NtCreateResourceManager_return, on_cb_NtCreateResourceManager_return);
        PPP_REG_CB("syscalls2", on_NtCreateSection_enter, on_cb_NtCreateSection_enter);
        PPP_REG_CB("syscalls2", on_NtCreateSection_return, on_cb_NtCreateSection_return);
        PPP_REG_CB("syscalls2", on_NtCreateSemaphore_enter, on_cb_NtCreateSemaphore_enter);
        PPP_REG_CB("syscalls2", on_NtCreateSemaphore_return, on_cb_NtCreateSemaphore_return);
        PPP_REG_CB("syscalls2", on_NtCreateSymbolicLinkObject_enter, on_cb_NtCreateSymbolicLinkObject_enter);
        PPP_REG_CB("syscalls2", on_NtCreateSymbolicLinkObject_return, on_cb_NtCreateSymbolicLinkObject_return);
        PPP_REG_CB("syscalls2", on_NtCreateThread_enter, on_cb_NtCreateThread_enter);
        PPP_REG_CB("syscalls2", on_NtCreateThread_return, on_cb_NtCreateThread_return);
        PPP_REG_CB("syscalls2", on_NtCreateThreadEx_enter, on_cb_NtCreateThreadEx_enter);
        PPP_REG_CB("syscalls2", on_NtCreateThreadEx_return, on_cb_NtCreateThreadEx_return);
        PPP_REG_CB("syscalls2", on_NtCreateTimer_enter, on_cb_NtCreateTimer_enter);
        PPP_REG_CB("syscalls2", on_NtCreateTimer_return, on_cb_NtCreateTimer_return);
        PPP_REG_CB("syscalls2", on_NtCreateToken_enter, on_cb_NtCreateToken_enter);
        PPP_REG_CB("syscalls2", on_NtCreateToken_return, on_cb_NtCreateToken_return);
        PPP_REG_CB("syscalls2", on_NtCreateTransaction_enter, on_cb_NtCreateTransaction_enter);
        PPP_REG_CB("syscalls2", on_NtCreateTransaction_return, on_cb_NtCreateTransaction_return);
        PPP_REG_CB("syscalls2", on_NtCreateTransactionManager_enter, on_cb_NtCreateTransactionManager_enter);
        PPP_REG_CB("syscalls2", on_NtCreateTransactionManager_return, on_cb_NtCreateTransactionManager_return);
        PPP_REG_CB("syscalls2", on_NtCreateUserProcess_enter, on_cb_NtCreateUserProcess_enter);
        PPP_REG_CB("syscalls2", on_NtCreateUserProcess_return, on_cb_NtCreateUserProcess_return);
        PPP_REG_CB("syscalls2", on_NtCreateWaitablePort_enter, on_cb_NtCreateWaitablePort_enter);
        PPP_REG_CB("syscalls2", on_NtCreateWaitablePort_return, on_cb_NtCreateWaitablePort_return);
        PPP_REG_CB("syscalls2", on_NtCreateWorkerFactory_enter, on_cb_NtCreateWorkerFactory_enter);
        PPP_REG_CB("syscalls2", on_NtCreateWorkerFactory_return, on_cb_NtCreateWorkerFactory_return);
        PPP_REG_CB("syscalls2", on_NtDebugActiveProcess_enter, on_cb_NtDebugActiveProcess_enter);
        PPP_REG_CB("syscalls2", on_NtDebugActiveProcess_return, on_cb_NtDebugActiveProcess_return);
        PPP_REG_CB("syscalls2", on_NtDebugContinue_enter, on_cb_NtDebugContinue_enter);
        PPP_REG_CB("syscalls2", on_NtDebugContinue_return, on_cb_NtDebugContinue_return);
        PPP_REG_CB("syscalls2", on_NtDelayExecution_enter, on_cb_NtDelayExecution_enter);
        PPP_REG_CB("syscalls2", on_NtDelayExecution_return, on_cb_NtDelayExecution_return);
        PPP_REG_CB("syscalls2", on_NtDeleteAtom_enter, on_cb_NtDeleteAtom_enter);
        PPP_REG_CB("syscalls2", on_NtDeleteAtom_return, on_cb_NtDeleteAtom_return);
        PPP_REG_CB("syscalls2", on_NtDeleteBootEntry_enter, on_cb_NtDeleteBootEntry_enter);
        PPP_REG_CB("syscalls2", on_NtDeleteBootEntry_return, on_cb_NtDeleteBootEntry_return);
        PPP_REG_CB("syscalls2", on_NtDeleteDriverEntry_enter, on_cb_NtDeleteDriverEntry_enter);
        PPP_REG_CB("syscalls2", on_NtDeleteDriverEntry_return, on_cb_NtDeleteDriverEntry_return);
        PPP_REG_CB("syscalls2", on_NtDeleteFile_enter, on_cb_NtDeleteFile_enter);
        PPP_REG_CB("syscalls2", on_NtDeleteFile_return, on_cb_NtDeleteFile_return);
        PPP_REG_CB("syscalls2", on_NtDeleteKey_enter, on_cb_NtDeleteKey_enter);
        PPP_REG_CB("syscalls2", on_NtDeleteKey_return, on_cb_NtDeleteKey_return);
        PPP_REG_CB("syscalls2", on_NtDeleteObjectAuditAlarm_enter, on_cb_NtDeleteObjectAuditAlarm_enter);
        PPP_REG_CB("syscalls2", on_NtDeleteObjectAuditAlarm_return, on_cb_NtDeleteObjectAuditAlarm_return);
        PPP_REG_CB("syscalls2", on_NtDeletePrivateNamespace_enter, on_cb_NtDeletePrivateNamespace_enter);
        PPP_REG_CB("syscalls2", on_NtDeletePrivateNamespace_return, on_cb_NtDeletePrivateNamespace_return);
        PPP_REG_CB("syscalls2", on_NtDeleteValueKey_enter, on_cb_NtDeleteValueKey_enter);
        PPP_REG_CB("syscalls2", on_NtDeleteValueKey_return, on_cb_NtDeleteValueKey_return);
        PPP_REG_CB("syscalls2", on_NtDeviceIoControlFile_enter, on_cb_NtDeviceIoControlFile_enter);
        PPP_REG_CB("syscalls2", on_NtDeviceIoControlFile_return, on_cb_NtDeviceIoControlFile_return);
        PPP_REG_CB("syscalls2", on_NtDisableLastKnownGood_enter, on_cb_NtDisableLastKnownGood_enter);
        PPP_REG_CB("syscalls2", on_NtDisableLastKnownGood_return, on_cb_NtDisableLastKnownGood_return);
        PPP_REG_CB("syscalls2", on_NtDisplayString_enter, on_cb_NtDisplayString_enter);
        PPP_REG_CB("syscalls2", on_NtDisplayString_return, on_cb_NtDisplayString_return);
        PPP_REG_CB("syscalls2", on_NtDrawText_enter, on_cb_NtDrawText_enter);
        PPP_REG_CB("syscalls2", on_NtDrawText_return, on_cb_NtDrawText_return);
        PPP_REG_CB("syscalls2", on_NtDuplicateObject_enter, on_cb_NtDuplicateObject_enter);
        PPP_REG_CB("syscalls2", on_NtDuplicateObject_return, on_cb_NtDuplicateObject_return);
        PPP_REG_CB("syscalls2", on_NtDuplicateToken_enter, on_cb_NtDuplicateToken_enter);
        PPP_REG_CB("syscalls2", on_NtDuplicateToken_return, on_cb_NtDuplicateToken_return);
        PPP_REG_CB("syscalls2", on_NtEnableLastKnownGood_enter, on_cb_NtEnableLastKnownGood_enter);
        PPP_REG_CB("syscalls2", on_NtEnableLastKnownGood_return, on_cb_NtEnableLastKnownGood_return);
        PPP_REG_CB("syscalls2", on_NtEnumerateBootEntries_enter, on_cb_NtEnumerateBootEntries_enter);
        PPP_REG_CB("syscalls2", on_NtEnumerateBootEntries_return, on_cb_NtEnumerateBootEntries_return);
        PPP_REG_CB("syscalls2", on_NtEnumerateDriverEntries_enter, on_cb_NtEnumerateDriverEntries_enter);
        PPP_REG_CB("syscalls2", on_NtEnumerateDriverEntries_return, on_cb_NtEnumerateDriverEntries_return);
        PPP_REG_CB("syscalls2", on_NtEnumerateKey_enter, on_cb_NtEnumerateKey_enter);
        PPP_REG_CB("syscalls2", on_NtEnumerateKey_return, on_cb_NtEnumerateKey_return);
        PPP_REG_CB("syscalls2", on_NtEnumerateSystemEnvironmentValuesEx_enter, on_cb_NtEnumerateSystemEnvironmentValuesEx_enter);
        PPP_REG_CB("syscalls2", on_NtEnumerateSystemEnvironmentValuesEx_return, on_cb_NtEnumerateSystemEnvironmentValuesEx_return);
        PPP_REG_CB("syscalls2", on_NtEnumerateTransactionObject_enter, on_cb_NtEnumerateTransactionObject_enter);
        PPP_REG_CB("syscalls2", on_NtEnumerateTransactionObject_return, on_cb_NtEnumerateTransactionObject_return);
        PPP_REG_CB("syscalls2", on_NtEnumerateValueKey_enter, on_cb_NtEnumerateValueKey_enter);
        PPP_REG_CB("syscalls2", on_NtEnumerateValueKey_return, on_cb_NtEnumerateValueKey_return);
        PPP_REG_CB("syscalls2", on_NtExtendSection_enter, on_cb_NtExtendSection_enter);
        PPP_REG_CB("syscalls2", on_NtExtendSection_return, on_cb_NtExtendSection_return);
        PPP_REG_CB("syscalls2", on_NtFilterToken_enter, on_cb_NtFilterToken_enter);
        PPP_REG_CB("syscalls2", on_NtFilterToken_return, on_cb_NtFilterToken_return);
        PPP_REG_CB("syscalls2", on_NtFindAtom_enter, on_cb_NtFindAtom_enter);
        PPP_REG_CB("syscalls2", on_NtFindAtom_return, on_cb_NtFindAtom_return);
        PPP_REG_CB("syscalls2", on_NtFlushBuffersFile_enter, on_cb_NtFlushBuffersFile_enter);
        PPP_REG_CB("syscalls2", on_NtFlushBuffersFile_return, on_cb_NtFlushBuffersFile_return);
        PPP_REG_CB("syscalls2", on_NtFlushInstallUILanguage_enter, on_cb_NtFlushInstallUILanguage_enter);
        PPP_REG_CB("syscalls2", on_NtFlushInstallUILanguage_return, on_cb_NtFlushInstallUILanguage_return);
        PPP_REG_CB("syscalls2", on_NtFlushInstructionCache_enter, on_cb_NtFlushInstructionCache_enter);
        PPP_REG_CB("syscalls2", on_NtFlushInstructionCache_return, on_cb_NtFlushInstructionCache_return);
        PPP_REG_CB("syscalls2", on_NtFlushKey_enter, on_cb_NtFlushKey_enter);
        PPP_REG_CB("syscalls2", on_NtFlushKey_return, on_cb_NtFlushKey_return);
        PPP_REG_CB("syscalls2", on_NtFlushProcessWriteBuffers_enter, on_cb_NtFlushProcessWriteBuffers_enter);
        PPP_REG_CB("syscalls2", on_NtFlushProcessWriteBuffers_return, on_cb_NtFlushProcessWriteBuffers_return);
        PPP_REG_CB("syscalls2", on_NtFlushVirtualMemory_enter, on_cb_NtFlushVirtualMemory_enter);
        PPP_REG_CB("syscalls2", on_NtFlushVirtualMemory_return, on_cb_NtFlushVirtualMemory_return);
        PPP_REG_CB("syscalls2", on_NtFlushWriteBuffer_enter, on_cb_NtFlushWriteBuffer_enter);
        PPP_REG_CB("syscalls2", on_NtFlushWriteBuffer_return, on_cb_NtFlushWriteBuffer_return);
        PPP_REG_CB("syscalls2", on_NtFreeUserPhysicalPages_enter, on_cb_NtFreeUserPhysicalPages_enter);
        PPP_REG_CB("syscalls2", on_NtFreeUserPhysicalPages_return, on_cb_NtFreeUserPhysicalPages_return);
        PPP_REG_CB("syscalls2", on_NtFreeVirtualMemory_enter, on_cb_NtFreeVirtualMemory_enter);
        PPP_REG_CB("syscalls2", on_NtFreeVirtualMemory_return, on_cb_NtFreeVirtualMemory_return);
        PPP_REG_CB("syscalls2", on_NtFreezeRegistry_enter, on_cb_NtFreezeRegistry_enter);
        PPP_REG_CB("syscalls2", on_NtFreezeRegistry_return, on_cb_NtFreezeRegistry_return);
        PPP_REG_CB("syscalls2", on_NtFreezeTransactions_enter, on_cb_NtFreezeTransactions_enter);
        PPP_REG_CB("syscalls2", on_NtFreezeTransactions_return, on_cb_NtFreezeTransactions_return);
        PPP_REG_CB("syscalls2", on_NtFsControlFile_enter, on_cb_NtFsControlFile_enter);
        PPP_REG_CB("syscalls2", on_NtFsControlFile_return, on_cb_NtFsControlFile_return);
        PPP_REG_CB("syscalls2", on_NtGetContextThread_enter, on_cb_NtGetContextThread_enter);
        PPP_REG_CB("syscalls2", on_NtGetContextThread_return, on_cb_NtGetContextThread_return);
        PPP_REG_CB("syscalls2", on_NtGetCurrentProcessorNumber_enter, on_cb_NtGetCurrentProcessorNumber_enter);
        PPP_REG_CB("syscalls2", on_NtGetCurrentProcessorNumber_return, on_cb_NtGetCurrentProcessorNumber_return);
        PPP_REG_CB("syscalls2", on_NtGetDevicePowerState_enter, on_cb_NtGetDevicePowerState_enter);
        PPP_REG_CB("syscalls2", on_NtGetDevicePowerState_return, on_cb_NtGetDevicePowerState_return);
        PPP_REG_CB("syscalls2", on_NtGetMUIRegistryInfo_enter, on_cb_NtGetMUIRegistryInfo_enter);
        PPP_REG_CB("syscalls2", on_NtGetMUIRegistryInfo_return, on_cb_NtGetMUIRegistryInfo_return);
        PPP_REG_CB("syscalls2", on_NtGetNextProcess_enter, on_cb_NtGetNextProcess_enter);
        PPP_REG_CB("syscalls2", on_NtGetNextProcess_return, on_cb_NtGetNextProcess_return);
        PPP_REG_CB("syscalls2", on_NtGetNextThread_enter, on_cb_NtGetNextThread_enter);
        PPP_REG_CB("syscalls2", on_NtGetNextThread_return, on_cb_NtGetNextThread_return);
        PPP_REG_CB("syscalls2", on_NtGetNlsSectionPtr_enter, on_cb_NtGetNlsSectionPtr_enter);
        PPP_REG_CB("syscalls2", on_NtGetNlsSectionPtr_return, on_cb_NtGetNlsSectionPtr_return);
        PPP_REG_CB("syscalls2", on_NtGetNotificationResourceManager_enter, on_cb_NtGetNotificationResourceManager_enter);
        PPP_REG_CB("syscalls2", on_NtGetNotificationResourceManager_return, on_cb_NtGetNotificationResourceManager_return);
        PPP_REG_CB("syscalls2", on_NtGetPlugPlayEvent_enter, on_cb_NtGetPlugPlayEvent_enter);
        PPP_REG_CB("syscalls2", on_NtGetPlugPlayEvent_return, on_cb_NtGetPlugPlayEvent_return);
        PPP_REG_CB("syscalls2", on_NtGetWriteWatch_enter, on_cb_NtGetWriteWatch_enter);
        PPP_REG_CB("syscalls2", on_NtGetWriteWatch_return, on_cb_NtGetWriteWatch_return);
        PPP_REG_CB("syscalls2", on_NtImpersonateAnonymousToken_enter, on_cb_NtImpersonateAnonymousToken_enter);
        PPP_REG_CB("syscalls2", on_NtImpersonateAnonymousToken_return, on_cb_NtImpersonateAnonymousToken_return);
        PPP_REG_CB("syscalls2", on_NtImpersonateClientOfPort_enter, on_cb_NtImpersonateClientOfPort_enter);
        PPP_REG_CB("syscalls2", on_NtImpersonateClientOfPort_return, on_cb_NtImpersonateClientOfPort_return);
        PPP_REG_CB("syscalls2", on_NtImpersonateThread_enter, on_cb_NtImpersonateThread_enter);
        PPP_REG_CB("syscalls2", on_NtImpersonateThread_return, on_cb_NtImpersonateThread_return);
        PPP_REG_CB("syscalls2", on_NtInitializeNlsFiles_enter, on_cb_NtInitializeNlsFiles_enter);
        PPP_REG_CB("syscalls2", on_NtInitializeNlsFiles_return, on_cb_NtInitializeNlsFiles_return);
        PPP_REG_CB("syscalls2", on_NtInitializeRegistry_enter, on_cb_NtInitializeRegistry_enter);
        PPP_REG_CB("syscalls2", on_NtInitializeRegistry_return, on_cb_NtInitializeRegistry_return);
        PPP_REG_CB("syscalls2", on_NtInitiatePowerAction_enter, on_cb_NtInitiatePowerAction_enter);
        PPP_REG_CB("syscalls2", on_NtInitiatePowerAction_return, on_cb_NtInitiatePowerAction_return);
        PPP_REG_CB("syscalls2", on_NtIsProcessInJob_enter, on_cb_NtIsProcessInJob_enter);
        PPP_REG_CB("syscalls2", on_NtIsProcessInJob_return, on_cb_NtIsProcessInJob_return);
        PPP_REG_CB("syscalls2", on_NtIsSystemResumeAutomatic_enter, on_cb_NtIsSystemResumeAutomatic_enter);
        PPP_REG_CB("syscalls2", on_NtIsSystemResumeAutomatic_return, on_cb_NtIsSystemResumeAutomatic_return);
        PPP_REG_CB("syscalls2", on_NtIsUILanguageComitted_enter, on_cb_NtIsUILanguageComitted_enter);
        PPP_REG_CB("syscalls2", on_NtIsUILanguageComitted_return, on_cb_NtIsUILanguageComitted_return);
        PPP_REG_CB("syscalls2", on_NtListenPort_enter, on_cb_NtListenPort_enter);
        PPP_REG_CB("syscalls2", on_NtListenPort_return, on_cb_NtListenPort_return);
        PPP_REG_CB("syscalls2", on_NtLoadDriver_enter, on_cb_NtLoadDriver_enter);
        PPP_REG_CB("syscalls2", on_NtLoadDriver_return, on_cb_NtLoadDriver_return);
        PPP_REG_CB("syscalls2", on_NtLoadKey_enter, on_cb_NtLoadKey_enter);
        PPP_REG_CB("syscalls2", on_NtLoadKey_return, on_cb_NtLoadKey_return);
        PPP_REG_CB("syscalls2", on_NtLoadKey2_enter, on_cb_NtLoadKey2_enter);
        PPP_REG_CB("syscalls2", on_NtLoadKey2_return, on_cb_NtLoadKey2_return);
        PPP_REG_CB("syscalls2", on_NtLoadKeyEx_enter, on_cb_NtLoadKeyEx_enter);
        PPP_REG_CB("syscalls2", on_NtLoadKeyEx_return, on_cb_NtLoadKeyEx_return);
        PPP_REG_CB("syscalls2", on_NtLockFile_enter, on_cb_NtLockFile_enter);
        PPP_REG_CB("syscalls2", on_NtLockFile_return, on_cb_NtLockFile_return);
        PPP_REG_CB("syscalls2", on_NtLockProductActivationKeys_enter, on_cb_NtLockProductActivationKeys_enter);
        PPP_REG_CB("syscalls2", on_NtLockProductActivationKeys_return, on_cb_NtLockProductActivationKeys_return);
        PPP_REG_CB("syscalls2", on_NtLockRegistryKey_enter, on_cb_NtLockRegistryKey_enter);
        PPP_REG_CB("syscalls2", on_NtLockRegistryKey_return, on_cb_NtLockRegistryKey_return);
        PPP_REG_CB("syscalls2", on_NtLockVirtualMemory_enter, on_cb_NtLockVirtualMemory_enter);
        PPP_REG_CB("syscalls2", on_NtLockVirtualMemory_return, on_cb_NtLockVirtualMemory_return);
        PPP_REG_CB("syscalls2", on_NtMakePermanentObject_enter, on_cb_NtMakePermanentObject_enter);
        PPP_REG_CB("syscalls2", on_NtMakePermanentObject_return, on_cb_NtMakePermanentObject_return);
        PPP_REG_CB("syscalls2", on_NtMakeTemporaryObject_enter, on_cb_NtMakeTemporaryObject_enter);
        PPP_REG_CB("syscalls2", on_NtMakeTemporaryObject_return, on_cb_NtMakeTemporaryObject_return);
        PPP_REG_CB("syscalls2", on_NtMapCMFModule_enter, on_cb_NtMapCMFModule_enter);
        PPP_REG_CB("syscalls2", on_NtMapCMFModule_return, on_cb_NtMapCMFModule_return);
        PPP_REG_CB("syscalls2", on_NtMapUserPhysicalPages_enter, on_cb_NtMapUserPhysicalPages_enter);
        PPP_REG_CB("syscalls2", on_NtMapUserPhysicalPages_return, on_cb_NtMapUserPhysicalPages_return);
        PPP_REG_CB("syscalls2", on_NtMapUserPhysicalPagesScatter_enter, on_cb_NtMapUserPhysicalPagesScatter_enter);
        PPP_REG_CB("syscalls2", on_NtMapUserPhysicalPagesScatter_return, on_cb_NtMapUserPhysicalPagesScatter_return);
        PPP_REG_CB("syscalls2", on_NtMapViewOfSection_enter, on_cb_NtMapViewOfSection_enter);
        PPP_REG_CB("syscalls2", on_NtMapViewOfSection_return, on_cb_NtMapViewOfSection_return);
        PPP_REG_CB("syscalls2", on_NtModifyBootEntry_enter, on_cb_NtModifyBootEntry_enter);
        PPP_REG_CB("syscalls2", on_NtModifyBootEntry_return, on_cb_NtModifyBootEntry_return);
        PPP_REG_CB("syscalls2", on_NtModifyDriverEntry_enter, on_cb_NtModifyDriverEntry_enter);
        PPP_REG_CB("syscalls2", on_NtModifyDriverEntry_return, on_cb_NtModifyDriverEntry_return);
        PPP_REG_CB("syscalls2", on_NtNotifyChangeDirectoryFile_enter, on_cb_NtNotifyChangeDirectoryFile_enter);
        PPP_REG_CB("syscalls2", on_NtNotifyChangeDirectoryFile_return, on_cb_NtNotifyChangeDirectoryFile_return);
        PPP_REG_CB("syscalls2", on_NtNotifyChangeKey_enter, on_cb_NtNotifyChangeKey_enter);
        PPP_REG_CB("syscalls2", on_NtNotifyChangeKey_return, on_cb_NtNotifyChangeKey_return);
        PPP_REG_CB("syscalls2", on_NtNotifyChangeMultipleKeys_enter, on_cb_NtNotifyChangeMultipleKeys_enter);
        PPP_REG_CB("syscalls2", on_NtNotifyChangeMultipleKeys_return, on_cb_NtNotifyChangeMultipleKeys_return);
        PPP_REG_CB("syscalls2", on_NtNotifyChangeSession_enter, on_cb_NtNotifyChangeSession_enter);
        PPP_REG_CB("syscalls2", on_NtNotifyChangeSession_return, on_cb_NtNotifyChangeSession_return);
        PPP_REG_CB("syscalls2", on_NtOpenDirectoryObject_enter, on_cb_NtOpenDirectoryObject_enter);
        PPP_REG_CB("syscalls2", on_NtOpenDirectoryObject_return, on_cb_NtOpenDirectoryObject_return);
        PPP_REG_CB("syscalls2", on_NtOpenEnlistment_enter, on_cb_NtOpenEnlistment_enter);
        PPP_REG_CB("syscalls2", on_NtOpenEnlistment_return, on_cb_NtOpenEnlistment_return);
        PPP_REG_CB("syscalls2", on_NtOpenEvent_enter, on_cb_NtOpenEvent_enter);
        PPP_REG_CB("syscalls2", on_NtOpenEvent_return, on_cb_NtOpenEvent_return);
        PPP_REG_CB("syscalls2", on_NtOpenEventPair_enter, on_cb_NtOpenEventPair_enter);
        PPP_REG_CB("syscalls2", on_NtOpenEventPair_return, on_cb_NtOpenEventPair_return);
        PPP_REG_CB("syscalls2", on_NtOpenFile_enter, on_cb_NtOpenFile_enter);
        PPP_REG_CB("syscalls2", on_NtOpenFile_return, on_cb_NtOpenFile_return);
        PPP_REG_CB("syscalls2", on_NtOpenIoCompletion_enter, on_cb_NtOpenIoCompletion_enter);
        PPP_REG_CB("syscalls2", on_NtOpenIoCompletion_return, on_cb_NtOpenIoCompletion_return);
        PPP_REG_CB("syscalls2", on_NtOpenJobObject_enter, on_cb_NtOpenJobObject_enter);
        PPP_REG_CB("syscalls2", on_NtOpenJobObject_return, on_cb_NtOpenJobObject_return);
        PPP_REG_CB("syscalls2", on_NtOpenKey_enter, on_cb_NtOpenKey_enter);
        PPP_REG_CB("syscalls2", on_NtOpenKey_return, on_cb_NtOpenKey_return);
        PPP_REG_CB("syscalls2", on_NtOpenKeyEx_enter, on_cb_NtOpenKeyEx_enter);
        PPP_REG_CB("syscalls2", on_NtOpenKeyEx_return, on_cb_NtOpenKeyEx_return);
        PPP_REG_CB("syscalls2", on_NtOpenKeyedEvent_enter, on_cb_NtOpenKeyedEvent_enter);
        PPP_REG_CB("syscalls2", on_NtOpenKeyedEvent_return, on_cb_NtOpenKeyedEvent_return);
        PPP_REG_CB("syscalls2", on_NtOpenKeyTransacted_enter, on_cb_NtOpenKeyTransacted_enter);
        PPP_REG_CB("syscalls2", on_NtOpenKeyTransacted_return, on_cb_NtOpenKeyTransacted_return);
        PPP_REG_CB("syscalls2", on_NtOpenKeyTransactedEx_enter, on_cb_NtOpenKeyTransactedEx_enter);
        PPP_REG_CB("syscalls2", on_NtOpenKeyTransactedEx_return, on_cb_NtOpenKeyTransactedEx_return);
        PPP_REG_CB("syscalls2", on_NtOpenMutant_enter, on_cb_NtOpenMutant_enter);
        PPP_REG_CB("syscalls2", on_NtOpenMutant_return, on_cb_NtOpenMutant_return);
        PPP_REG_CB("syscalls2", on_NtOpenObjectAuditAlarm_enter, on_cb_NtOpenObjectAuditAlarm_enter);
        PPP_REG_CB("syscalls2", on_NtOpenObjectAuditAlarm_return, on_cb_NtOpenObjectAuditAlarm_return);
        PPP_REG_CB("syscalls2", on_NtOpenPrivateNamespace_enter, on_cb_NtOpenPrivateNamespace_enter);
        PPP_REG_CB("syscalls2", on_NtOpenPrivateNamespace_return, on_cb_NtOpenPrivateNamespace_return);
        PPP_REG_CB("syscalls2", on_NtOpenProcess_enter, on_cb_NtOpenProcess_enter);
        PPP_REG_CB("syscalls2", on_NtOpenProcess_return, on_cb_NtOpenProcess_return);
        PPP_REG_CB("syscalls2", on_NtOpenProcessToken_enter, on_cb_NtOpenProcessToken_enter);
        PPP_REG_CB("syscalls2", on_NtOpenProcessToken_return, on_cb_NtOpenProcessToken_return);
        PPP_REG_CB("syscalls2", on_NtOpenProcessTokenEx_enter, on_cb_NtOpenProcessTokenEx_enter);
        PPP_REG_CB("syscalls2", on_NtOpenProcessTokenEx_return, on_cb_NtOpenProcessTokenEx_return);
        PPP_REG_CB("syscalls2", on_NtOpenResourceManager_enter, on_cb_NtOpenResourceManager_enter);
        PPP_REG_CB("syscalls2", on_NtOpenResourceManager_return, on_cb_NtOpenResourceManager_return);
        PPP_REG_CB("syscalls2", on_NtOpenSection_enter, on_cb_NtOpenSection_enter);
        PPP_REG_CB("syscalls2", on_NtOpenSection_return, on_cb_NtOpenSection_return);
        PPP_REG_CB("syscalls2", on_NtOpenSemaphore_enter, on_cb_NtOpenSemaphore_enter);
        PPP_REG_CB("syscalls2", on_NtOpenSemaphore_return, on_cb_NtOpenSemaphore_return);
        PPP_REG_CB("syscalls2", on_NtOpenSession_enter, on_cb_NtOpenSession_enter);
        PPP_REG_CB("syscalls2", on_NtOpenSession_return, on_cb_NtOpenSession_return);
        PPP_REG_CB("syscalls2", on_NtOpenSymbolicLinkObject_enter, on_cb_NtOpenSymbolicLinkObject_enter);
        PPP_REG_CB("syscalls2", on_NtOpenSymbolicLinkObject_return, on_cb_NtOpenSymbolicLinkObject_return);
        PPP_REG_CB("syscalls2", on_NtOpenThread_enter, on_cb_NtOpenThread_enter);
        PPP_REG_CB("syscalls2", on_NtOpenThread_return, on_cb_NtOpenThread_return);
        PPP_REG_CB("syscalls2", on_NtOpenThreadToken_enter, on_cb_NtOpenThreadToken_enter);
        PPP_REG_CB("syscalls2", on_NtOpenThreadToken_return, on_cb_NtOpenThreadToken_return);
        PPP_REG_CB("syscalls2", on_NtOpenThreadTokenEx_enter, on_cb_NtOpenThreadTokenEx_enter);
        PPP_REG_CB("syscalls2", on_NtOpenThreadTokenEx_return, on_cb_NtOpenThreadTokenEx_return);
        PPP_REG_CB("syscalls2", on_NtOpenTimer_enter, on_cb_NtOpenTimer_enter);
        PPP_REG_CB("syscalls2", on_NtOpenTimer_return, on_cb_NtOpenTimer_return);
        PPP_REG_CB("syscalls2", on_NtOpenTransaction_enter, on_cb_NtOpenTransaction_enter);
        PPP_REG_CB("syscalls2", on_NtOpenTransaction_return, on_cb_NtOpenTransaction_return);
        PPP_REG_CB("syscalls2", on_NtOpenTransactionManager_enter, on_cb_NtOpenTransactionManager_enter);
        PPP_REG_CB("syscalls2", on_NtOpenTransactionManager_return, on_cb_NtOpenTransactionManager_return);
        PPP_REG_CB("syscalls2", on_NtPlugPlayControl_enter, on_cb_NtPlugPlayControl_enter);
        PPP_REG_CB("syscalls2", on_NtPlugPlayControl_return, on_cb_NtPlugPlayControl_return);
        PPP_REG_CB("syscalls2", on_NtPowerInformation_enter, on_cb_NtPowerInformation_enter);
        PPP_REG_CB("syscalls2", on_NtPowerInformation_return, on_cb_NtPowerInformation_return);
        PPP_REG_CB("syscalls2", on_NtPrepareComplete_enter, on_cb_NtPrepareComplete_enter);
        PPP_REG_CB("syscalls2", on_NtPrepareComplete_return, on_cb_NtPrepareComplete_return);
        PPP_REG_CB("syscalls2", on_NtPrepareEnlistment_enter, on_cb_NtPrepareEnlistment_enter);
        PPP_REG_CB("syscalls2", on_NtPrepareEnlistment_return, on_cb_NtPrepareEnlistment_return);
        PPP_REG_CB("syscalls2", on_NtPrePrepareComplete_enter, on_cb_NtPrePrepareComplete_enter);
        PPP_REG_CB("syscalls2", on_NtPrePrepareComplete_return, on_cb_NtPrePrepareComplete_return);
        PPP_REG_CB("syscalls2", on_NtPrePrepareEnlistment_enter, on_cb_NtPrePrepareEnlistment_enter);
        PPP_REG_CB("syscalls2", on_NtPrePrepareEnlistment_return, on_cb_NtPrePrepareEnlistment_return);
        PPP_REG_CB("syscalls2", on_NtPrivilegeCheck_enter, on_cb_NtPrivilegeCheck_enter);
        PPP_REG_CB("syscalls2", on_NtPrivilegeCheck_return, on_cb_NtPrivilegeCheck_return);
        PPP_REG_CB("syscalls2", on_NtPrivilegedServiceAuditAlarm_enter, on_cb_NtPrivilegedServiceAuditAlarm_enter);
        PPP_REG_CB("syscalls2", on_NtPrivilegedServiceAuditAlarm_return, on_cb_NtPrivilegedServiceAuditAlarm_return);
        PPP_REG_CB("syscalls2", on_NtPrivilegeObjectAuditAlarm_enter, on_cb_NtPrivilegeObjectAuditAlarm_enter);
        PPP_REG_CB("syscalls2", on_NtPrivilegeObjectAuditAlarm_return, on_cb_NtPrivilegeObjectAuditAlarm_return);
        PPP_REG_CB("syscalls2", on_NtPropagationComplete_enter, on_cb_NtPropagationComplete_enter);
        PPP_REG_CB("syscalls2", on_NtPropagationComplete_return, on_cb_NtPropagationComplete_return);
        PPP_REG_CB("syscalls2", on_NtPropagationFailed_enter, on_cb_NtPropagationFailed_enter);
        PPP_REG_CB("syscalls2", on_NtPropagationFailed_return, on_cb_NtPropagationFailed_return);
        PPP_REG_CB("syscalls2", on_NtProtectVirtualMemory_enter, on_cb_NtProtectVirtualMemory_enter);
        PPP_REG_CB("syscalls2", on_NtProtectVirtualMemory_return, on_cb_NtProtectVirtualMemory_return);
        PPP_REG_CB("syscalls2", on_NtPulseEvent_enter, on_cb_NtPulseEvent_enter);
        PPP_REG_CB("syscalls2", on_NtPulseEvent_return, on_cb_NtPulseEvent_return);
        PPP_REG_CB("syscalls2", on_NtQueryAttributesFile_enter, on_cb_NtQueryAttributesFile_enter);
        PPP_REG_CB("syscalls2", on_NtQueryAttributesFile_return, on_cb_NtQueryAttributesFile_return);
        PPP_REG_CB("syscalls2", on_NtQueryBootEntryOrder_enter, on_cb_NtQueryBootEntryOrder_enter);
        PPP_REG_CB("syscalls2", on_NtQueryBootEntryOrder_return, on_cb_NtQueryBootEntryOrder_return);
        PPP_REG_CB("syscalls2", on_NtQueryBootOptions_enter, on_cb_NtQueryBootOptions_enter);
        PPP_REG_CB("syscalls2", on_NtQueryBootOptions_return, on_cb_NtQueryBootOptions_return);
        PPP_REG_CB("syscalls2", on_NtQueryDebugFilterState_enter, on_cb_NtQueryDebugFilterState_enter);
        PPP_REG_CB("syscalls2", on_NtQueryDebugFilterState_return, on_cb_NtQueryDebugFilterState_return);
        PPP_REG_CB("syscalls2", on_NtQueryDefaultLocale_enter, on_cb_NtQueryDefaultLocale_enter);
        PPP_REG_CB("syscalls2", on_NtQueryDefaultLocale_return, on_cb_NtQueryDefaultLocale_return);
        PPP_REG_CB("syscalls2", on_NtQueryDefaultUILanguage_enter, on_cb_NtQueryDefaultUILanguage_enter);
        PPP_REG_CB("syscalls2", on_NtQueryDefaultUILanguage_return, on_cb_NtQueryDefaultUILanguage_return);
        PPP_REG_CB("syscalls2", on_NtQueryDirectoryFile_enter, on_cb_NtQueryDirectoryFile_enter);
        PPP_REG_CB("syscalls2", on_NtQueryDirectoryFile_return, on_cb_NtQueryDirectoryFile_return);
        PPP_REG_CB("syscalls2", on_NtQueryDirectoryObject_enter, on_cb_NtQueryDirectoryObject_enter);
        PPP_REG_CB("syscalls2", on_NtQueryDirectoryObject_return, on_cb_NtQueryDirectoryObject_return);
        PPP_REG_CB("syscalls2", on_NtQueryDriverEntryOrder_enter, on_cb_NtQueryDriverEntryOrder_enter);
        PPP_REG_CB("syscalls2", on_NtQueryDriverEntryOrder_return, on_cb_NtQueryDriverEntryOrder_return);
        PPP_REG_CB("syscalls2", on_NtQueryEaFile_enter, on_cb_NtQueryEaFile_enter);
        PPP_REG_CB("syscalls2", on_NtQueryEaFile_return, on_cb_NtQueryEaFile_return);
        PPP_REG_CB("syscalls2", on_NtQueryEvent_enter, on_cb_NtQueryEvent_enter);
        PPP_REG_CB("syscalls2", on_NtQueryEvent_return, on_cb_NtQueryEvent_return);
        PPP_REG_CB("syscalls2", on_NtQueryFullAttributesFile_enter, on_cb_NtQueryFullAttributesFile_enter);
        PPP_REG_CB("syscalls2", on_NtQueryFullAttributesFile_return, on_cb_NtQueryFullAttributesFile_return);
        PPP_REG_CB("syscalls2", on_NtQueryInformationAtom_enter, on_cb_NtQueryInformationAtom_enter);
        PPP_REG_CB("syscalls2", on_NtQueryInformationAtom_return, on_cb_NtQueryInformationAtom_return);
        PPP_REG_CB("syscalls2", on_NtQueryInformationEnlistment_enter, on_cb_NtQueryInformationEnlistment_enter);
        PPP_REG_CB("syscalls2", on_NtQueryInformationEnlistment_return, on_cb_NtQueryInformationEnlistment_return);
        PPP_REG_CB("syscalls2", on_NtQueryInformationFile_enter, on_cb_NtQueryInformationFile_enter);
        PPP_REG_CB("syscalls2", on_NtQueryInformationFile_return, on_cb_NtQueryInformationFile_return);
        PPP_REG_CB("syscalls2", on_NtQueryInformationJobObject_enter, on_cb_NtQueryInformationJobObject_enter);
        PPP_REG_CB("syscalls2", on_NtQueryInformationJobObject_return, on_cb_NtQueryInformationJobObject_return);
        PPP_REG_CB("syscalls2", on_NtQueryInformationPort_enter, on_cb_NtQueryInformationPort_enter);
        PPP_REG_CB("syscalls2", on_NtQueryInformationPort_return, on_cb_NtQueryInformationPort_return);
        PPP_REG_CB("syscalls2", on_NtQueryInformationProcess_enter, on_cb_NtQueryInformationProcess_enter);
        PPP_REG_CB("syscalls2", on_NtQueryInformationProcess_return, on_cb_NtQueryInformationProcess_return);
        PPP_REG_CB("syscalls2", on_NtQueryInformationResourceManager_enter, on_cb_NtQueryInformationResourceManager_enter);
        PPP_REG_CB("syscalls2", on_NtQueryInformationResourceManager_return, on_cb_NtQueryInformationResourceManager_return);
        PPP_REG_CB("syscalls2", on_NtQueryInformationThread_enter, on_cb_NtQueryInformationThread_enter);
        PPP_REG_CB("syscalls2", on_NtQueryInformationThread_return, on_cb_NtQueryInformationThread_return);
        PPP_REG_CB("syscalls2", on_NtQueryInformationToken_enter, on_cb_NtQueryInformationToken_enter);
        PPP_REG_CB("syscalls2", on_NtQueryInformationToken_return, on_cb_NtQueryInformationToken_return);
        PPP_REG_CB("syscalls2", on_NtQueryInformationTransaction_enter, on_cb_NtQueryInformationTransaction_enter);
        PPP_REG_CB("syscalls2", on_NtQueryInformationTransaction_return, on_cb_NtQueryInformationTransaction_return);
        PPP_REG_CB("syscalls2", on_NtQueryInformationTransactionManager_enter, on_cb_NtQueryInformationTransactionManager_enter);
        PPP_REG_CB("syscalls2", on_NtQueryInformationTransactionManager_return, on_cb_NtQueryInformationTransactionManager_return);
        PPP_REG_CB("syscalls2", on_NtQueryInformationWorkerFactory_enter, on_cb_NtQueryInformationWorkerFactory_enter);
        PPP_REG_CB("syscalls2", on_NtQueryInformationWorkerFactory_return, on_cb_NtQueryInformationWorkerFactory_return);
        PPP_REG_CB("syscalls2", on_NtQueryInstallUILanguage_enter, on_cb_NtQueryInstallUILanguage_enter);
        PPP_REG_CB("syscalls2", on_NtQueryInstallUILanguage_return, on_cb_NtQueryInstallUILanguage_return);
        PPP_REG_CB("syscalls2", on_NtQueryIntervalProfile_enter, on_cb_NtQueryIntervalProfile_enter);
        PPP_REG_CB("syscalls2", on_NtQueryIntervalProfile_return, on_cb_NtQueryIntervalProfile_return);
        PPP_REG_CB("syscalls2", on_NtQueryIoCompletion_enter, on_cb_NtQueryIoCompletion_enter);
        PPP_REG_CB("syscalls2", on_NtQueryIoCompletion_return, on_cb_NtQueryIoCompletion_return);
        PPP_REG_CB("syscalls2", on_NtQueryKey_enter, on_cb_NtQueryKey_enter);
        PPP_REG_CB("syscalls2", on_NtQueryKey_return, on_cb_NtQueryKey_return);
        PPP_REG_CB("syscalls2", on_NtQueryLicenseValue_enter, on_cb_NtQueryLicenseValue_enter);
        PPP_REG_CB("syscalls2", on_NtQueryLicenseValue_return, on_cb_NtQueryLicenseValue_return);
        PPP_REG_CB("syscalls2", on_NtQueryMultipleValueKey_enter, on_cb_NtQueryMultipleValueKey_enter);
        PPP_REG_CB("syscalls2", on_NtQueryMultipleValueKey_return, on_cb_NtQueryMultipleValueKey_return);
        PPP_REG_CB("syscalls2", on_NtQueryMutant_enter, on_cb_NtQueryMutant_enter);
        PPP_REG_CB("syscalls2", on_NtQueryMutant_return, on_cb_NtQueryMutant_return);
        PPP_REG_CB("syscalls2", on_NtQueryObject_enter, on_cb_NtQueryObject_enter);
        PPP_REG_CB("syscalls2", on_NtQueryObject_return, on_cb_NtQueryObject_return);
        PPP_REG_CB("syscalls2", on_NtQueryOpenSubKeys_enter, on_cb_NtQueryOpenSubKeys_enter);
        PPP_REG_CB("syscalls2", on_NtQueryOpenSubKeys_return, on_cb_NtQueryOpenSubKeys_return);
        PPP_REG_CB("syscalls2", on_NtQueryOpenSubKeysEx_enter, on_cb_NtQueryOpenSubKeysEx_enter);
        PPP_REG_CB("syscalls2", on_NtQueryOpenSubKeysEx_return, on_cb_NtQueryOpenSubKeysEx_return);
        PPP_REG_CB("syscalls2", on_NtQueryPerformanceCounter_enter, on_cb_NtQueryPerformanceCounter_enter);
        PPP_REG_CB("syscalls2", on_NtQueryPerformanceCounter_return, on_cb_NtQueryPerformanceCounter_return);
        PPP_REG_CB("syscalls2", on_NtQueryPortInformationProcess_enter, on_cb_NtQueryPortInformationProcess_enter);
        PPP_REG_CB("syscalls2", on_NtQueryPortInformationProcess_return, on_cb_NtQueryPortInformationProcess_return);
        PPP_REG_CB("syscalls2", on_NtQueryQuotaInformationFile_enter, on_cb_NtQueryQuotaInformationFile_enter);
        PPP_REG_CB("syscalls2", on_NtQueryQuotaInformationFile_return, on_cb_NtQueryQuotaInformationFile_return);
        PPP_REG_CB("syscalls2", on_NtQuerySection_enter, on_cb_NtQuerySection_enter);
        PPP_REG_CB("syscalls2", on_NtQuerySection_return, on_cb_NtQuerySection_return);
        PPP_REG_CB("syscalls2", on_NtQuerySecurityAttributesToken_enter, on_cb_NtQuerySecurityAttributesToken_enter);
        PPP_REG_CB("syscalls2", on_NtQuerySecurityAttributesToken_return, on_cb_NtQuerySecurityAttributesToken_return);
        PPP_REG_CB("syscalls2", on_NtQuerySecurityObject_enter, on_cb_NtQuerySecurityObject_enter);
        PPP_REG_CB("syscalls2", on_NtQuerySecurityObject_return, on_cb_NtQuerySecurityObject_return);
        PPP_REG_CB("syscalls2", on_NtQuerySemaphore_enter, on_cb_NtQuerySemaphore_enter);
        PPP_REG_CB("syscalls2", on_NtQuerySemaphore_return, on_cb_NtQuerySemaphore_return);
        PPP_REG_CB("syscalls2", on_NtQuerySymbolicLinkObject_enter, on_cb_NtQuerySymbolicLinkObject_enter);
        PPP_REG_CB("syscalls2", on_NtQuerySymbolicLinkObject_return, on_cb_NtQuerySymbolicLinkObject_return);
        PPP_REG_CB("syscalls2", on_NtQuerySystemEnvironmentValue_enter, on_cb_NtQuerySystemEnvironmentValue_enter);
        PPP_REG_CB("syscalls2", on_NtQuerySystemEnvironmentValue_return, on_cb_NtQuerySystemEnvironmentValue_return);
        PPP_REG_CB("syscalls2", on_NtQuerySystemEnvironmentValueEx_enter, on_cb_NtQuerySystemEnvironmentValueEx_enter);
        PPP_REG_CB("syscalls2", on_NtQuerySystemEnvironmentValueEx_return, on_cb_NtQuerySystemEnvironmentValueEx_return);
        PPP_REG_CB("syscalls2", on_NtQuerySystemInformation_enter, on_cb_NtQuerySystemInformation_enter);
        PPP_REG_CB("syscalls2", on_NtQuerySystemInformation_return, on_cb_NtQuerySystemInformation_return);
        PPP_REG_CB("syscalls2", on_NtQuerySystemInformationEx_enter, on_cb_NtQuerySystemInformationEx_enter);
        PPP_REG_CB("syscalls2", on_NtQuerySystemInformationEx_return, on_cb_NtQuerySystemInformationEx_return);
        PPP_REG_CB("syscalls2", on_NtQuerySystemTime_enter, on_cb_NtQuerySystemTime_enter);
        PPP_REG_CB("syscalls2", on_NtQuerySystemTime_return, on_cb_NtQuerySystemTime_return);
        PPP_REG_CB("syscalls2", on_NtQueryTimer_enter, on_cb_NtQueryTimer_enter);
        PPP_REG_CB("syscalls2", on_NtQueryTimer_return, on_cb_NtQueryTimer_return);
        PPP_REG_CB("syscalls2", on_NtQueryTimerResolution_enter, on_cb_NtQueryTimerResolution_enter);
        PPP_REG_CB("syscalls2", on_NtQueryTimerResolution_return, on_cb_NtQueryTimerResolution_return);
        PPP_REG_CB("syscalls2", on_NtQueryValueKey_enter, on_cb_NtQueryValueKey_enter);
        PPP_REG_CB("syscalls2", on_NtQueryValueKey_return, on_cb_NtQueryValueKey_return);
        PPP_REG_CB("syscalls2", on_NtQueryVirtualMemory_enter, on_cb_NtQueryVirtualMemory_enter);
        PPP_REG_CB("syscalls2", on_NtQueryVirtualMemory_return, on_cb_NtQueryVirtualMemory_return);
        PPP_REG_CB("syscalls2", on_NtQueryVolumeInformationFile_enter, on_cb_NtQueryVolumeInformationFile_enter);
        PPP_REG_CB("syscalls2", on_NtQueryVolumeInformationFile_return, on_cb_NtQueryVolumeInformationFile_return);
        PPP_REG_CB("syscalls2", on_NtQueueApcThread_enter, on_cb_NtQueueApcThread_enter);
        PPP_REG_CB("syscalls2", on_NtQueueApcThread_return, on_cb_NtQueueApcThread_return);
        PPP_REG_CB("syscalls2", on_NtQueueApcThreadEx_enter, on_cb_NtQueueApcThreadEx_enter);
        PPP_REG_CB("syscalls2", on_NtQueueApcThreadEx_return, on_cb_NtQueueApcThreadEx_return);
        PPP_REG_CB("syscalls2", on_NtRaiseException_enter, on_cb_NtRaiseException_enter);
        PPP_REG_CB("syscalls2", on_NtRaiseException_return, on_cb_NtRaiseException_return);
        PPP_REG_CB("syscalls2", on_NtRaiseHardError_enter, on_cb_NtRaiseHardError_enter);
        PPP_REG_CB("syscalls2", on_NtRaiseHardError_return, on_cb_NtRaiseHardError_return);
        PPP_REG_CB("syscalls2", on_NtReadFile_enter, on_cb_NtReadFile_enter);
        PPP_REG_CB("syscalls2", on_NtReadFile_return, on_cb_NtReadFile_return);
        PPP_REG_CB("syscalls2", on_NtReadFileScatter_enter, on_cb_NtReadFileScatter_enter);
        PPP_REG_CB("syscalls2", on_NtReadFileScatter_return, on_cb_NtReadFileScatter_return);
        PPP_REG_CB("syscalls2", on_NtReadOnlyEnlistment_enter, on_cb_NtReadOnlyEnlistment_enter);
        PPP_REG_CB("syscalls2", on_NtReadOnlyEnlistment_return, on_cb_NtReadOnlyEnlistment_return);
        PPP_REG_CB("syscalls2", on_NtReadRequestData_enter, on_cb_NtReadRequestData_enter);
        PPP_REG_CB("syscalls2", on_NtReadRequestData_return, on_cb_NtReadRequestData_return);
        PPP_REG_CB("syscalls2", on_NtReadVirtualMemory_enter, on_cb_NtReadVirtualMemory_enter);
        PPP_REG_CB("syscalls2", on_NtReadVirtualMemory_return, on_cb_NtReadVirtualMemory_return);
        PPP_REG_CB("syscalls2", on_NtRecoverEnlistment_enter, on_cb_NtRecoverEnlistment_enter);
        PPP_REG_CB("syscalls2", on_NtRecoverEnlistment_return, on_cb_NtRecoverEnlistment_return);
        PPP_REG_CB("syscalls2", on_NtRecoverResourceManager_enter, on_cb_NtRecoverResourceManager_enter);
        PPP_REG_CB("syscalls2", on_NtRecoverResourceManager_return, on_cb_NtRecoverResourceManager_return);
        PPP_REG_CB("syscalls2", on_NtRecoverTransactionManager_enter, on_cb_NtRecoverTransactionManager_enter);
        PPP_REG_CB("syscalls2", on_NtRecoverTransactionManager_return, on_cb_NtRecoverTransactionManager_return);
        PPP_REG_CB("syscalls2", on_NtRegisterProtocolAddressInformation_enter, on_cb_NtRegisterProtocolAddressInformation_enter);
        PPP_REG_CB("syscalls2", on_NtRegisterProtocolAddressInformation_return, on_cb_NtRegisterProtocolAddressInformation_return);
        PPP_REG_CB("syscalls2", on_NtRegisterThreadTerminatePort_enter, on_cb_NtRegisterThreadTerminatePort_enter);
        PPP_REG_CB("syscalls2", on_NtRegisterThreadTerminatePort_return, on_cb_NtRegisterThreadTerminatePort_return);
        PPP_REG_CB("syscalls2", on_NtReleaseKeyedEvent_enter, on_cb_NtReleaseKeyedEvent_enter);
        PPP_REG_CB("syscalls2", on_NtReleaseKeyedEvent_return, on_cb_NtReleaseKeyedEvent_return);
        PPP_REG_CB("syscalls2", on_NtReleaseMutant_enter, on_cb_NtReleaseMutant_enter);
        PPP_REG_CB("syscalls2", on_NtReleaseMutant_return, on_cb_NtReleaseMutant_return);
        PPP_REG_CB("syscalls2", on_NtReleaseSemaphore_enter, on_cb_NtReleaseSemaphore_enter);
        PPP_REG_CB("syscalls2", on_NtReleaseSemaphore_return, on_cb_NtReleaseSemaphore_return);
        PPP_REG_CB("syscalls2", on_NtReleaseWorkerFactoryWorker_enter, on_cb_NtReleaseWorkerFactoryWorker_enter);
        PPP_REG_CB("syscalls2", on_NtReleaseWorkerFactoryWorker_return, on_cb_NtReleaseWorkerFactoryWorker_return);
        PPP_REG_CB("syscalls2", on_NtRemoveIoCompletion_enter, on_cb_NtRemoveIoCompletion_enter);
        PPP_REG_CB("syscalls2", on_NtRemoveIoCompletion_return, on_cb_NtRemoveIoCompletion_return);
        PPP_REG_CB("syscalls2", on_NtRemoveIoCompletionEx_enter, on_cb_NtRemoveIoCompletionEx_enter);
        PPP_REG_CB("syscalls2", on_NtRemoveIoCompletionEx_return, on_cb_NtRemoveIoCompletionEx_return);
        PPP_REG_CB("syscalls2", on_NtRemoveProcessDebug_enter, on_cb_NtRemoveProcessDebug_enter);
        PPP_REG_CB("syscalls2", on_NtRemoveProcessDebug_return, on_cb_NtRemoveProcessDebug_return);
        PPP_REG_CB("syscalls2", on_NtRenameKey_enter, on_cb_NtRenameKey_enter);
        PPP_REG_CB("syscalls2", on_NtRenameKey_return, on_cb_NtRenameKey_return);
        PPP_REG_CB("syscalls2", on_NtRenameTransactionManager_enter, on_cb_NtRenameTransactionManager_enter);
        PPP_REG_CB("syscalls2", on_NtRenameTransactionManager_return, on_cb_NtRenameTransactionManager_return);
        PPP_REG_CB("syscalls2", on_NtReplaceKey_enter, on_cb_NtReplaceKey_enter);
        PPP_REG_CB("syscalls2", on_NtReplaceKey_return, on_cb_NtReplaceKey_return);
        PPP_REG_CB("syscalls2", on_NtReplacePartitionUnit_enter, on_cb_NtReplacePartitionUnit_enter);
        PPP_REG_CB("syscalls2", on_NtReplacePartitionUnit_return, on_cb_NtReplacePartitionUnit_return);
        PPP_REG_CB("syscalls2", on_NtReplyPort_enter, on_cb_NtReplyPort_enter);
        PPP_REG_CB("syscalls2", on_NtReplyPort_return, on_cb_NtReplyPort_return);
        PPP_REG_CB("syscalls2", on_NtReplyWaitReceivePort_enter, on_cb_NtReplyWaitReceivePort_enter);
        PPP_REG_CB("syscalls2", on_NtReplyWaitReceivePort_return, on_cb_NtReplyWaitReceivePort_return);
        PPP_REG_CB("syscalls2", on_NtReplyWaitReceivePortEx_enter, on_cb_NtReplyWaitReceivePortEx_enter);
        PPP_REG_CB("syscalls2", on_NtReplyWaitReceivePortEx_return, on_cb_NtReplyWaitReceivePortEx_return);
        PPP_REG_CB("syscalls2", on_NtReplyWaitReplyPort_enter, on_cb_NtReplyWaitReplyPort_enter);
        PPP_REG_CB("syscalls2", on_NtReplyWaitReplyPort_return, on_cb_NtReplyWaitReplyPort_return);
        PPP_REG_CB("syscalls2", on_NtRequestPort_enter, on_cb_NtRequestPort_enter);
        PPP_REG_CB("syscalls2", on_NtRequestPort_return, on_cb_NtRequestPort_return);
        PPP_REG_CB("syscalls2", on_NtRequestWaitReplyPort_enter, on_cb_NtRequestWaitReplyPort_enter);
        PPP_REG_CB("syscalls2", on_NtRequestWaitReplyPort_return, on_cb_NtRequestWaitReplyPort_return);
        PPP_REG_CB("syscalls2", on_NtResetEvent_enter, on_cb_NtResetEvent_enter);
        PPP_REG_CB("syscalls2", on_NtResetEvent_return, on_cb_NtResetEvent_return);
        PPP_REG_CB("syscalls2", on_NtResetWriteWatch_enter, on_cb_NtResetWriteWatch_enter);
        PPP_REG_CB("syscalls2", on_NtResetWriteWatch_return, on_cb_NtResetWriteWatch_return);
        PPP_REG_CB("syscalls2", on_NtRestoreKey_enter, on_cb_NtRestoreKey_enter);
        PPP_REG_CB("syscalls2", on_NtRestoreKey_return, on_cb_NtRestoreKey_return);
        PPP_REG_CB("syscalls2", on_NtResumeProcess_enter, on_cb_NtResumeProcess_enter);
        PPP_REG_CB("syscalls2", on_NtResumeProcess_return, on_cb_NtResumeProcess_return);
        PPP_REG_CB("syscalls2", on_NtResumeThread_enter, on_cb_NtResumeThread_enter);
        PPP_REG_CB("syscalls2", on_NtResumeThread_return, on_cb_NtResumeThread_return);
        PPP_REG_CB("syscalls2", on_NtRollbackComplete_enter, on_cb_NtRollbackComplete_enter);
        PPP_REG_CB("syscalls2", on_NtRollbackComplete_return, on_cb_NtRollbackComplete_return);
        PPP_REG_CB("syscalls2", on_NtRollbackEnlistment_enter, on_cb_NtRollbackEnlistment_enter);
        PPP_REG_CB("syscalls2", on_NtRollbackEnlistment_return, on_cb_NtRollbackEnlistment_return);
        PPP_REG_CB("syscalls2", on_NtRollbackTransaction_enter, on_cb_NtRollbackTransaction_enter);
        PPP_REG_CB("syscalls2", on_NtRollbackTransaction_return, on_cb_NtRollbackTransaction_return);
        PPP_REG_CB("syscalls2", on_NtRollforwardTransactionManager_enter, on_cb_NtRollforwardTransactionManager_enter);
        PPP_REG_CB("syscalls2", on_NtRollforwardTransactionManager_return, on_cb_NtRollforwardTransactionManager_return);
        PPP_REG_CB("syscalls2", on_NtSaveKey_enter, on_cb_NtSaveKey_enter);
        PPP_REG_CB("syscalls2", on_NtSaveKey_return, on_cb_NtSaveKey_return);
        PPP_REG_CB("syscalls2", on_NtSaveKeyEx_enter, on_cb_NtSaveKeyEx_enter);
        PPP_REG_CB("syscalls2", on_NtSaveKeyEx_return, on_cb_NtSaveKeyEx_return);
        PPP_REG_CB("syscalls2", on_NtSaveMergedKeys_enter, on_cb_NtSaveMergedKeys_enter);
        PPP_REG_CB("syscalls2", on_NtSaveMergedKeys_return, on_cb_NtSaveMergedKeys_return);
        PPP_REG_CB("syscalls2", on_NtSecureConnectPort_enter, on_cb_NtSecureConnectPort_enter);
        PPP_REG_CB("syscalls2", on_NtSecureConnectPort_return, on_cb_NtSecureConnectPort_return);
        PPP_REG_CB("syscalls2", on_NtSerializeBoot_enter, on_cb_NtSerializeBoot_enter);
        PPP_REG_CB("syscalls2", on_NtSerializeBoot_return, on_cb_NtSerializeBoot_return);
        PPP_REG_CB("syscalls2", on_NtSetBootEntryOrder_enter, on_cb_NtSetBootEntryOrder_enter);
        PPP_REG_CB("syscalls2", on_NtSetBootEntryOrder_return, on_cb_NtSetBootEntryOrder_return);
        PPP_REG_CB("syscalls2", on_NtSetBootOptions_enter, on_cb_NtSetBootOptions_enter);
        PPP_REG_CB("syscalls2", on_NtSetBootOptions_return, on_cb_NtSetBootOptions_return);
        PPP_REG_CB("syscalls2", on_NtSetContextThread_enter, on_cb_NtSetContextThread_enter);
        PPP_REG_CB("syscalls2", on_NtSetContextThread_return, on_cb_NtSetContextThread_return);
        PPP_REG_CB("syscalls2", on_NtSetDebugFilterState_enter, on_cb_NtSetDebugFilterState_enter);
        PPP_REG_CB("syscalls2", on_NtSetDebugFilterState_return, on_cb_NtSetDebugFilterState_return);
        PPP_REG_CB("syscalls2", on_NtSetDefaultHardErrorPort_enter, on_cb_NtSetDefaultHardErrorPort_enter);
        PPP_REG_CB("syscalls2", on_NtSetDefaultHardErrorPort_return, on_cb_NtSetDefaultHardErrorPort_return);
        PPP_REG_CB("syscalls2", on_NtSetDefaultLocale_enter, on_cb_NtSetDefaultLocale_enter);
        PPP_REG_CB("syscalls2", on_NtSetDefaultLocale_return, on_cb_NtSetDefaultLocale_return);
        PPP_REG_CB("syscalls2", on_NtSetDefaultUILanguage_enter, on_cb_NtSetDefaultUILanguage_enter);
        PPP_REG_CB("syscalls2", on_NtSetDefaultUILanguage_return, on_cb_NtSetDefaultUILanguage_return);
        PPP_REG_CB("syscalls2", on_NtSetDriverEntryOrder_enter, on_cb_NtSetDriverEntryOrder_enter);
        PPP_REG_CB("syscalls2", on_NtSetDriverEntryOrder_return, on_cb_NtSetDriverEntryOrder_return);
        PPP_REG_CB("syscalls2", on_NtSetEaFile_enter, on_cb_NtSetEaFile_enter);
        PPP_REG_CB("syscalls2", on_NtSetEaFile_return, on_cb_NtSetEaFile_return);
        PPP_REG_CB("syscalls2", on_NtSetEvent_enter, on_cb_NtSetEvent_enter);
        PPP_REG_CB("syscalls2", on_NtSetEvent_return, on_cb_NtSetEvent_return);
        PPP_REG_CB("syscalls2", on_NtSetEventBoostPriority_enter, on_cb_NtSetEventBoostPriority_enter);
        PPP_REG_CB("syscalls2", on_NtSetEventBoostPriority_return, on_cb_NtSetEventBoostPriority_return);
        PPP_REG_CB("syscalls2", on_NtSetHighEventPair_enter, on_cb_NtSetHighEventPair_enter);
        PPP_REG_CB("syscalls2", on_NtSetHighEventPair_return, on_cb_NtSetHighEventPair_return);
        PPP_REG_CB("syscalls2", on_NtSetHighWaitLowEventPair_enter, on_cb_NtSetHighWaitLowEventPair_enter);
        PPP_REG_CB("syscalls2", on_NtSetHighWaitLowEventPair_return, on_cb_NtSetHighWaitLowEventPair_return);
        PPP_REG_CB("syscalls2", on_NtSetInformationDebugObject_enter, on_cb_NtSetInformationDebugObject_enter);
        PPP_REG_CB("syscalls2", on_NtSetInformationDebugObject_return, on_cb_NtSetInformationDebugObject_return);
        PPP_REG_CB("syscalls2", on_NtSetInformationEnlistment_enter, on_cb_NtSetInformationEnlistment_enter);
        PPP_REG_CB("syscalls2", on_NtSetInformationEnlistment_return, on_cb_NtSetInformationEnlistment_return);
        PPP_REG_CB("syscalls2", on_NtSetInformationFile_enter, on_cb_NtSetInformationFile_enter);
        PPP_REG_CB("syscalls2", on_NtSetInformationFile_return, on_cb_NtSetInformationFile_return);
        PPP_REG_CB("syscalls2", on_NtSetInformationJobObject_enter, on_cb_NtSetInformationJobObject_enter);
        PPP_REG_CB("syscalls2", on_NtSetInformationJobObject_return, on_cb_NtSetInformationJobObject_return);
        PPP_REG_CB("syscalls2", on_NtSetInformationKey_enter, on_cb_NtSetInformationKey_enter);
        PPP_REG_CB("syscalls2", on_NtSetInformationKey_return, on_cb_NtSetInformationKey_return);
        PPP_REG_CB("syscalls2", on_NtSetInformationObject_enter, on_cb_NtSetInformationObject_enter);
        PPP_REG_CB("syscalls2", on_NtSetInformationObject_return, on_cb_NtSetInformationObject_return);
        PPP_REG_CB("syscalls2", on_NtSetInformationProcess_enter, on_cb_NtSetInformationProcess_enter);
        PPP_REG_CB("syscalls2", on_NtSetInformationProcess_return, on_cb_NtSetInformationProcess_return);
        PPP_REG_CB("syscalls2", on_NtSetInformationResourceManager_enter, on_cb_NtSetInformationResourceManager_enter);
        PPP_REG_CB("syscalls2", on_NtSetInformationResourceManager_return, on_cb_NtSetInformationResourceManager_return);
        PPP_REG_CB("syscalls2", on_NtSetInformationThread_enter, on_cb_NtSetInformationThread_enter);
        PPP_REG_CB("syscalls2", on_NtSetInformationThread_return, on_cb_NtSetInformationThread_return);
        PPP_REG_CB("syscalls2", on_NtSetInformationToken_enter, on_cb_NtSetInformationToken_enter);
        PPP_REG_CB("syscalls2", on_NtSetInformationToken_return, on_cb_NtSetInformationToken_return);
        PPP_REG_CB("syscalls2", on_NtSetInformationTransaction_enter, on_cb_NtSetInformationTransaction_enter);
        PPP_REG_CB("syscalls2", on_NtSetInformationTransaction_return, on_cb_NtSetInformationTransaction_return);
        PPP_REG_CB("syscalls2", on_NtSetInformationTransactionManager_enter, on_cb_NtSetInformationTransactionManager_enter);
        PPP_REG_CB("syscalls2", on_NtSetInformationTransactionManager_return, on_cb_NtSetInformationTransactionManager_return);
        PPP_REG_CB("syscalls2", on_NtSetInformationWorkerFactory_enter, on_cb_NtSetInformationWorkerFactory_enter);
        PPP_REG_CB("syscalls2", on_NtSetInformationWorkerFactory_return, on_cb_NtSetInformationWorkerFactory_return);
        PPP_REG_CB("syscalls2", on_NtSetIntervalProfile_enter, on_cb_NtSetIntervalProfile_enter);
        PPP_REG_CB("syscalls2", on_NtSetIntervalProfile_return, on_cb_NtSetIntervalProfile_return);
        PPP_REG_CB("syscalls2", on_NtSetIoCompletion_enter, on_cb_NtSetIoCompletion_enter);
        PPP_REG_CB("syscalls2", on_NtSetIoCompletion_return, on_cb_NtSetIoCompletion_return);
        PPP_REG_CB("syscalls2", on_NtSetIoCompletionEx_enter, on_cb_NtSetIoCompletionEx_enter);
        PPP_REG_CB("syscalls2", on_NtSetIoCompletionEx_return, on_cb_NtSetIoCompletionEx_return);
        PPP_REG_CB("syscalls2", on_NtSetLdtEntries_enter, on_cb_NtSetLdtEntries_enter);
        PPP_REG_CB("syscalls2", on_NtSetLdtEntries_return, on_cb_NtSetLdtEntries_return);
        PPP_REG_CB("syscalls2", on_NtSetLowEventPair_enter, on_cb_NtSetLowEventPair_enter);
        PPP_REG_CB("syscalls2", on_NtSetLowEventPair_return, on_cb_NtSetLowEventPair_return);
        PPP_REG_CB("syscalls2", on_NtSetLowWaitHighEventPair_enter, on_cb_NtSetLowWaitHighEventPair_enter);
        PPP_REG_CB("syscalls2", on_NtSetLowWaitHighEventPair_return, on_cb_NtSetLowWaitHighEventPair_return);
        PPP_REG_CB("syscalls2", on_NtSetQuotaInformationFile_enter, on_cb_NtSetQuotaInformationFile_enter);
        PPP_REG_CB("syscalls2", on_NtSetQuotaInformationFile_return, on_cb_NtSetQuotaInformationFile_return);
        PPP_REG_CB("syscalls2", on_NtSetSecurityObject_enter, on_cb_NtSetSecurityObject_enter);
        PPP_REG_CB("syscalls2", on_NtSetSecurityObject_return, on_cb_NtSetSecurityObject_return);
        PPP_REG_CB("syscalls2", on_NtSetSystemEnvironmentValue_enter, on_cb_NtSetSystemEnvironmentValue_enter);
        PPP_REG_CB("syscalls2", on_NtSetSystemEnvironmentValue_return, on_cb_NtSetSystemEnvironmentValue_return);
        PPP_REG_CB("syscalls2", on_NtSetSystemEnvironmentValueEx_enter, on_cb_NtSetSystemEnvironmentValueEx_enter);
        PPP_REG_CB("syscalls2", on_NtSetSystemEnvironmentValueEx_return, on_cb_NtSetSystemEnvironmentValueEx_return);
        PPP_REG_CB("syscalls2", on_NtSetSystemInformation_enter, on_cb_NtSetSystemInformation_enter);
        PPP_REG_CB("syscalls2", on_NtSetSystemInformation_return, on_cb_NtSetSystemInformation_return);
        PPP_REG_CB("syscalls2", on_NtSetSystemPowerState_enter, on_cb_NtSetSystemPowerState_enter);
        PPP_REG_CB("syscalls2", on_NtSetSystemPowerState_return, on_cb_NtSetSystemPowerState_return);
        PPP_REG_CB("syscalls2", on_NtSetSystemTime_enter, on_cb_NtSetSystemTime_enter);
        PPP_REG_CB("syscalls2", on_NtSetSystemTime_return, on_cb_NtSetSystemTime_return);
        PPP_REG_CB("syscalls2", on_NtSetThreadExecutionState_enter, on_cb_NtSetThreadExecutionState_enter);
        PPP_REG_CB("syscalls2", on_NtSetThreadExecutionState_return, on_cb_NtSetThreadExecutionState_return);
        PPP_REG_CB("syscalls2", on_NtSetTimer_enter, on_cb_NtSetTimer_enter);
        PPP_REG_CB("syscalls2", on_NtSetTimer_return, on_cb_NtSetTimer_return);
        PPP_REG_CB("syscalls2", on_NtSetTimerEx_enter, on_cb_NtSetTimerEx_enter);
        PPP_REG_CB("syscalls2", on_NtSetTimerEx_return, on_cb_NtSetTimerEx_return);
        PPP_REG_CB("syscalls2", on_NtSetTimerResolution_enter, on_cb_NtSetTimerResolution_enter);
        PPP_REG_CB("syscalls2", on_NtSetTimerResolution_return, on_cb_NtSetTimerResolution_return);
        PPP_REG_CB("syscalls2", on_NtSetUuidSeed_enter, on_cb_NtSetUuidSeed_enter);
        PPP_REG_CB("syscalls2", on_NtSetUuidSeed_return, on_cb_NtSetUuidSeed_return);
        PPP_REG_CB("syscalls2", on_NtSetValueKey_enter, on_cb_NtSetValueKey_enter);
        PPP_REG_CB("syscalls2", on_NtSetValueKey_return, on_cb_NtSetValueKey_return);
        PPP_REG_CB("syscalls2", on_NtSetVolumeInformationFile_enter, on_cb_NtSetVolumeInformationFile_enter);
        PPP_REG_CB("syscalls2", on_NtSetVolumeInformationFile_return, on_cb_NtSetVolumeInformationFile_return);
        PPP_REG_CB("syscalls2", on_NtShutdownSystem_enter, on_cb_NtShutdownSystem_enter);
        PPP_REG_CB("syscalls2", on_NtShutdownSystem_return, on_cb_NtShutdownSystem_return);
        PPP_REG_CB("syscalls2", on_NtShutdownWorkerFactory_enter, on_cb_NtShutdownWorkerFactory_enter);
        PPP_REG_CB("syscalls2", on_NtShutdownWorkerFactory_return, on_cb_NtShutdownWorkerFactory_return);
        PPP_REG_CB("syscalls2", on_NtSignalAndWaitForSingleObject_enter, on_cb_NtSignalAndWaitForSingleObject_enter);
        PPP_REG_CB("syscalls2", on_NtSignalAndWaitForSingleObject_return, on_cb_NtSignalAndWaitForSingleObject_return);
        PPP_REG_CB("syscalls2", on_NtSinglePhaseReject_enter, on_cb_NtSinglePhaseReject_enter);
        PPP_REG_CB("syscalls2", on_NtSinglePhaseReject_return, on_cb_NtSinglePhaseReject_return);
        PPP_REG_CB("syscalls2", on_NtStartProfile_enter, on_cb_NtStartProfile_enter);
        PPP_REG_CB("syscalls2", on_NtStartProfile_return, on_cb_NtStartProfile_return);
        PPP_REG_CB("syscalls2", on_NtStopProfile_enter, on_cb_NtStopProfile_enter);
        PPP_REG_CB("syscalls2", on_NtStopProfile_return, on_cb_NtStopProfile_return);
        PPP_REG_CB("syscalls2", on_NtSuspendProcess_enter, on_cb_NtSuspendProcess_enter);
        PPP_REG_CB("syscalls2", on_NtSuspendProcess_return, on_cb_NtSuspendProcess_return);
        PPP_REG_CB("syscalls2", on_NtSuspendThread_enter, on_cb_NtSuspendThread_enter);
        PPP_REG_CB("syscalls2", on_NtSuspendThread_return, on_cb_NtSuspendThread_return);
        PPP_REG_CB("syscalls2", on_NtSystemDebugControl_enter, on_cb_NtSystemDebugControl_enter);
        PPP_REG_CB("syscalls2", on_NtSystemDebugControl_return, on_cb_NtSystemDebugControl_return);
        PPP_REG_CB("syscalls2", on_NtTerminateJobObject_enter, on_cb_NtTerminateJobObject_enter);
        PPP_REG_CB("syscalls2", on_NtTerminateJobObject_return, on_cb_NtTerminateJobObject_return);
        PPP_REG_CB("syscalls2", on_NtTerminateProcess_enter, on_cb_NtTerminateProcess_enter);
        PPP_REG_CB("syscalls2", on_NtTerminateProcess_return, on_cb_NtTerminateProcess_return);
        PPP_REG_CB("syscalls2", on_NtTerminateThread_enter, on_cb_NtTerminateThread_enter);
        PPP_REG_CB("syscalls2", on_NtTerminateThread_return, on_cb_NtTerminateThread_return);
        PPP_REG_CB("syscalls2", on_NtTestAlert_enter, on_cb_NtTestAlert_enter);
        PPP_REG_CB("syscalls2", on_NtTestAlert_return, on_cb_NtTestAlert_return);
        PPP_REG_CB("syscalls2", on_NtThawRegistry_enter, on_cb_NtThawRegistry_enter);
        PPP_REG_CB("syscalls2", on_NtThawRegistry_return, on_cb_NtThawRegistry_return);
        PPP_REG_CB("syscalls2", on_NtThawTransactions_enter, on_cb_NtThawTransactions_enter);
        PPP_REG_CB("syscalls2", on_NtThawTransactions_return, on_cb_NtThawTransactions_return);
        PPP_REG_CB("syscalls2", on_NtTraceControl_enter, on_cb_NtTraceControl_enter);
        PPP_REG_CB("syscalls2", on_NtTraceControl_return, on_cb_NtTraceControl_return);
        PPP_REG_CB("syscalls2", on_NtTraceEvent_enter, on_cb_NtTraceEvent_enter);
        PPP_REG_CB("syscalls2", on_NtTraceEvent_return, on_cb_NtTraceEvent_return);
        PPP_REG_CB("syscalls2", on_NtTranslateFilePath_enter, on_cb_NtTranslateFilePath_enter);
        PPP_REG_CB("syscalls2", on_NtTranslateFilePath_return, on_cb_NtTranslateFilePath_return);
        PPP_REG_CB("syscalls2", on_NtUmsThreadYield_enter, on_cb_NtUmsThreadYield_enter);
        PPP_REG_CB("syscalls2", on_NtUmsThreadYield_return, on_cb_NtUmsThreadYield_return);
        PPP_REG_CB("syscalls2", on_NtUnloadDriver_enter, on_cb_NtUnloadDriver_enter);
        PPP_REG_CB("syscalls2", on_NtUnloadDriver_return, on_cb_NtUnloadDriver_return);
        PPP_REG_CB("syscalls2", on_NtUnloadKey_enter, on_cb_NtUnloadKey_enter);
        PPP_REG_CB("syscalls2", on_NtUnloadKey_return, on_cb_NtUnloadKey_return);
        PPP_REG_CB("syscalls2", on_NtUnloadKey2_enter, on_cb_NtUnloadKey2_enter);
        PPP_REG_CB("syscalls2", on_NtUnloadKey2_return, on_cb_NtUnloadKey2_return);
        PPP_REG_CB("syscalls2", on_NtUnloadKeyEx_enter, on_cb_NtUnloadKeyEx_enter);
        PPP_REG_CB("syscalls2", on_NtUnloadKeyEx_return, on_cb_NtUnloadKeyEx_return);
        PPP_REG_CB("syscalls2", on_NtUnlockFile_enter, on_cb_NtUnlockFile_enter);
        PPP_REG_CB("syscalls2", on_NtUnlockFile_return, on_cb_NtUnlockFile_return);
        PPP_REG_CB("syscalls2", on_NtUnlockVirtualMemory_enter, on_cb_NtUnlockVirtualMemory_enter);
        PPP_REG_CB("syscalls2", on_NtUnlockVirtualMemory_return, on_cb_NtUnlockVirtualMemory_return);
        PPP_REG_CB("syscalls2", on_NtUnmapViewOfSection_enter, on_cb_NtUnmapViewOfSection_enter);
        PPP_REG_CB("syscalls2", on_NtUnmapViewOfSection_return, on_cb_NtUnmapViewOfSection_return);
        PPP_REG_CB("syscalls2", on_NtVdmControl_enter, on_cb_NtVdmControl_enter);
        PPP_REG_CB("syscalls2", on_NtVdmControl_return, on_cb_NtVdmControl_return);
        PPP_REG_CB("syscalls2", on_NtWaitForDebugEvent_enter, on_cb_NtWaitForDebugEvent_enter);
        PPP_REG_CB("syscalls2", on_NtWaitForDebugEvent_return, on_cb_NtWaitForDebugEvent_return);
        PPP_REG_CB("syscalls2", on_NtWaitForKeyedEvent_enter, on_cb_NtWaitForKeyedEvent_enter);
        PPP_REG_CB("syscalls2", on_NtWaitForKeyedEvent_return, on_cb_NtWaitForKeyedEvent_return);
        PPP_REG_CB("syscalls2", on_NtWaitForMultipleObjects_enter, on_cb_NtWaitForMultipleObjects_enter);
        PPP_REG_CB("syscalls2", on_NtWaitForMultipleObjects_return, on_cb_NtWaitForMultipleObjects_return);
        PPP_REG_CB("syscalls2", on_NtWaitForMultipleObjects32_enter, on_cb_NtWaitForMultipleObjects32_enter);
        PPP_REG_CB("syscalls2", on_NtWaitForMultipleObjects32_return, on_cb_NtWaitForMultipleObjects32_return);
        PPP_REG_CB("syscalls2", on_NtWaitForSingleObject_enter, on_cb_NtWaitForSingleObject_enter);
        PPP_REG_CB("syscalls2", on_NtWaitForSingleObject_return, on_cb_NtWaitForSingleObject_return);
        PPP_REG_CB("syscalls2", on_NtWaitForWorkViaWorkerFactory_enter, on_cb_NtWaitForWorkViaWorkerFactory_enter);
        PPP_REG_CB("syscalls2", on_NtWaitForWorkViaWorkerFactory_return, on_cb_NtWaitForWorkViaWorkerFactory_return);
        PPP_REG_CB("syscalls2", on_NtWaitHighEventPair_enter, on_cb_NtWaitHighEventPair_enter);
        PPP_REG_CB("syscalls2", on_NtWaitHighEventPair_return, on_cb_NtWaitHighEventPair_return);
        PPP_REG_CB("syscalls2", on_NtWaitLowEventPair_enter, on_cb_NtWaitLowEventPair_enter);
        PPP_REG_CB("syscalls2", on_NtWaitLowEventPair_return, on_cb_NtWaitLowEventPair_return);
        PPP_REG_CB("syscalls2", on_NtWorkerFactoryWorkerReady_enter, on_cb_NtWorkerFactoryWorkerReady_enter);
        PPP_REG_CB("syscalls2", on_NtWorkerFactoryWorkerReady_return, on_cb_NtWorkerFactoryWorkerReady_return);
        PPP_REG_CB("syscalls2", on_NtWriteFile_enter, on_cb_NtWriteFile_enter);
        PPP_REG_CB("syscalls2", on_NtWriteFile_return, on_cb_NtWriteFile_return);
        PPP_REG_CB("syscalls2", on_NtWriteFileGather_enter, on_cb_NtWriteFileGather_enter);
        PPP_REG_CB("syscalls2", on_NtWriteFileGather_return, on_cb_NtWriteFileGather_return);
        PPP_REG_CB("syscalls2", on_NtWriteRequestData_enter, on_cb_NtWriteRequestData_enter);
        PPP_REG_CB("syscalls2", on_NtWriteRequestData_return, on_cb_NtWriteRequestData_return);
        PPP_REG_CB("syscalls2", on_NtWriteVirtualMemory_enter, on_cb_NtWriteVirtualMemory_enter);
        PPP_REG_CB("syscalls2", on_NtWriteVirtualMemory_return, on_cb_NtWriteVirtualMemory_return);
        PPP_REG_CB("syscalls2", on_NtYieldExecution_enter, on_cb_NtYieldExecution_enter);
        PPP_REG_CB("syscalls2", on_NtYieldExecution_return, on_cb_NtYieldExecution_return);
        PPP_REG_CB("syscalls2", on_unknown_sys_enter, on_cb_unknown_enter);
        PPP_REG_CB("syscalls2", on_unknown_sys_return, on_cb_unknown_return);
    } else {
        printf("Sorry, not support linux for now!");
        return false;
    }
    return true;
#endif // TARGET_I386
    printf("Only support x86");
    return false;
}

void uninit_plugin(void *self) {
    if (outFile) {
        fprintf(outFile, "{}]\n");
        fclose(outFile);
    }
}
